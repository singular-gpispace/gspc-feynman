

proc OneSectorComputation(labeledgraph G1, list tailInts, list sector_lab)
"USAGE:  OneSectorComputation(G1, tailInts, sector_lab); G1 labeledgraph, tailInts list of lists, sector_lab list
ASSUME:  G1 is a labeled graph, tailInts is a list of lists containing integrals, sector_lab is a list of sector labels
RETURN:  list(reducedIBPs, MIs, OutputtailInts) where reducedIBPs is a setIBP, MIs and OutputtailInts are lists
KEYWORDS: Feynman graph, IBPs"
{ 
 
 
  list targetInt;
  setIBP reducedIBPs;
  reducedIBPs.over = G1.baikovover;
  reducedIBPs.seed = sector_lab;
  reducedIBPs.IBP = list();
  list MIs;
  list OutputtailInts;
  
  // Extract target integrals for current sector
  for(int i = 1; i <= size(tailInts); i++) {
    
    for(int j = 1; j <= size(tailInts[i]); j++) {
      list current_sector = getSector(tailInts[i][j])[2];
     
      if(string(current_sector) == string(sector_lab)) {
        targetInt[size(targetInt) + 1] = tailInts[i][j];
      }
    }
  }

  if(size(targetInt) == 0) {
    print("No input integrals found for sector " + string(sector_lab));
    return(list(reducedIBPs, MIs, OutputtailInts));
  }
  
//2. Computations related to sector
  setIBP totalIBP=computeManyIBP(G1,targetInt);
  list L=getRedIBPs(totalIBP,7853);    //L[1]=set of independent IBPs, L[2]=master and tail integrals

  reducedIBPs.seed=sector_lab;
  reducedIBPs.over=G1.baikovover;
  reducedIBPs.IBP=L[1];
  for(int i=1;i<=size(L[2]);i++){
    if(string(getSector(L[2][i])[2])==string(sector_lab)){
      MIs[size(MIs)+1]=L[2][i];
    }
    else{
      OutputtailInts[size(OutputtailInts)+1]=L[2][i];
    }
  }
  
  return(list(reducedIBPs, MIs, OutputtailInts));
}