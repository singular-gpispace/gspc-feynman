////////////////////////////////////////////////////////////
version="version classify2.lib 4.3.2.0 Jan_2022 "; // $Id:  $
category="Commutative Algebra";
info="
LIBRARY: feynman.lib   Feynman integrals and IBP

OVERVIEW:
We generate the Feynman integrand associated to a Feynman diagram and compute reduced IBP system to reduce given target integers to master integrals.

KEYWORDS:
Feynman integral;

PROCEDURES:
makeGraph(list, list)                                   generate a graph from a list of vertices and a list of edges
makeLabeledGraph(list, list)                            generate a labeled graph from a list of vertices and a list of edges
printGraph(graph)                                       print procedure for graphs
labelGraph(graph)                                       label a graph with variables for vertices and edges
balancingIdeal(labeledgraph)                            ideal of balancing conditions
eliminateVariables(labeledgraph)                        eliminate variables according to balancing condition
propagators(labeledgraph)         	                    generate ideal generated by denominators of the Feynman integral assocated to graph
ISP(labeledgraph)			                                  extend the propagators to a basis of the quadratic forms
removeElimVars(labeledgraph)                            Removes the variables from G.elimvars. This key is generated by the procedure eliminateVariables.
computeBaikovMatrix(graph)                              computes the Baikov matrix of G defined in G1.baikovover and stores it in G1.baikovmatrix
computeM1(labeledgraph)                                 generate the module M1 over G1.baikovover that requires to compute IBP identities 
computeM2(labeledgraph,list)                            generate the module M2 over G1.baikovover that requires to compute IBP identities 
computeIBP(labeledgraph,list)                           generate the set of IBPS correspond to the given indices of denominators of the feynman integral.
getSector(list)                                         returns the sector (a list of 1s and 0s) that the integral belongs
listCombintions(list,int)                               returns the list of r-combinations of the elements in the list L
generateWebSectors(list)                                generate the Web structure of the sectors L, where L is the list and L[1] is the sector that correspond to the seed and 
                                                        L[i]  contain the subsectors of the sectors in L[i-1]. Not that sector maps between the sectors have not been setted.
isSubList(l1,l2)                                        return 1 if elements in l1 contain in l2  0 if elements in l1 do not contain in l2
getSectorMap(L1,L2)                                     L1 where sectorMap  of each sector in the list L1 is filled.
setSectorMap(sectorWeb)                                 sectorWeb where the field sectorMap field of each sector in sectorWeb is filled.
findSector(sectorWeb,currentPosition,L)                 return position of the sector in the sectorWeb, where the L belongs. return -1, if the sector is not found
updateOneSector(sectorWeb,currentPosition,oneInt)       updated sectorWeb, where the oneInt is assigned to the targetInts field of the seector correspond to provided oneInt
updateWeb(sectorWeb,currentPosition,setInt)             return a list(sectorWeb,MasterInt,notInWeb) where,sectorWeb is the updated web by assingning integrals to correspondng sectors, masterInt is the list integrals belong to the sector at currentPosition notInWeb is the list of integrals that are not belong the integral family associated the SectorWeb.
pickHighestSector(targetInt)                            return the intgral that belong to the heighest sector, if all integrals belong to the same sector web; otherwise, it returns a list of collection of integrals each need to be handled using different sector webs
getSortMeasures(l)                                      return list of sort measures that are used in Laporta Algorithm
extractCoef(I,ind,l)                                    return list of values where, the i-th element is the evaluation of coefficient function  at values in the list l of the IBP relation oneIBP, whose index is i=ind[i][1]. Columns of the matrix correspond to the all used indices in the setIBP which are ordered with respect to the output ofgetSortMeasures.
setMat(S,val)                                           return matrix,where i-th row correspond to the evaluation of coefficient functions of i-th IBP in setIBP. 
getRedIBPs(S,p)                                         list L, L[1]=indIBP, L[2]=seed where, indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. seed contain the indeces correspond to the non-free columns in rref.
getSortedIntegrals(I)                                            return list ind where each entry is a pair (indv,sortmeasures), indv is the list of indices(seed) appered in the setIBP and sortmeasures is the output of getSortMeasures(indv).The function getSortedIntegrals extract the seeds appeared in the IBP identities of the setIBP, sort them lexicographically based on the values got from getSortMeasures and return the output.
computeManyIBP(G0,setNu)                                return setIBP S, where it contains all the IBP relations obtained by module intersection and seeding
getReducedIBPSystem(G,targetInt )                       return reduced IBP systerm together with master integrals which are sufficent for reduction of targetInt to master integrals
";

LIB "linalg.lib";
LIB "ellipticcovers.lib"; //For integer partition

proc mod_init()
{
LIB "general.lib";
newstruct("graph","list vertices, list edges");
newstruct("labeledgraph","list vertices, list edges, ring over, list labels, ring overpoly, list elimvars, ring baikovover, matrix baikovmatrix");
newstruct("Net","list rows");
newstruct("oneIBP","list c, list i");
newstruct("setIBP","ring over,list seed,list IBP");
newstruct("oneSector","list lab, list sectorMap ,list targetInts ");
newstruct("MI","list masterIntegrals");
system("install","labeledgraph","print",printLabeledGraph,1);
system("install","graph","print",printGraph,1);
system("install","oneIBP","print",printIBP,1);
system("install","MI","print",printMI,1);
system("install","setIBP","print",printsetIBP,1);
system("install","Net","print",printNet,1);

system("install","Net","+",catNet,2);
option(noredefine);
}

  /////////////////////////////////////
  //     Compute Baikov matrix      //
  ////////////////////////////////////


static proc catNet(Net N, Net M)
{
list L;
list LN=N.rows;
list LM=M.rows;
int widthN=size(LN[1]);
int widthM=size(LM[1]);
int nm=max(size(LN),size(LM));
for (int j=1; j<=nm; j++)
{
    if (j>size(LN)){LN[j]=emptyString(widthN);}
    if (j>size(LM)){LM[j]=emptyString(widthM);}
    L[j]=LN[j]+LM[j];
}
Net NM;
NM.rows=L;
return(NM);}


static proc netList(list L1)
{
  Net N=net("[");
  for (int j=1; j<=size(L1)-1; j++)
  {
     N=N+net(L1[j])+net(", ");
  }
  N=N+net(L1[size(L1)])+net("]");
  return(N);
}

static proc printNet(Net N)
{
list L = N.rows;
for (int j=1; j<=size(L); j++)
{
   print(L[j]);
}
}

static proc net(def M){
  if (typeof(M)=="Net"){
    return(M);
  }
  if (typeof(M)=="list"){
    return(netList(M));
  }
  Net N;
  list L;
  L[1]=string(M);
  N.rows=L;
return(N);}


proc printMat(matrix M)
"USAGE:  printMat(M); M matrix@*
ASSUME:  M is a matrix.
THEORY:  This is the print function used by Singular to print a matrix.
KEYWORDS: matrix
EXAMPLE:  example printMat; shows an example
"
{
  int r=nrows(M);
  int c=ncols(M);
  list mWidth;

  for(int j=1;j <= c;j++)
  { 
    int m=0;
    for(int i=1 ; i <= r ;i++)
    {
      int entr=size(string(M[i,j]));
      if(entr>m)
      {
        m=entr;
      }
    }
    mWidth[j]=m;
  }


  for(int i=1;i <= r ; i++)
  {
    string rstar="[";
    for(int j=1;j <= c;j++)
    {
      string ent = string(M[i,j]);
      int p=mWidth[j]-size(ent);
      rstar=rstar+ent;
      if(j<c)
      {
        for(int k=1;k<=p+2;k++)
        {
          rstar=rstar+" ";
        }
        rstar=rstar+",";
      }

    }
    rstar=rstar+"]";
    print(rstar);
  }
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x),lp;
  matrix M[2][3]=1,243,3,4,522222,6;
  printMat(M);
}

proc printGraph(graph G)
"USAGE:  printGraph(G); G graph@*
ASSUME:  G is a graph.
THEORY:  This is the print function used by Singular to print a graph.
KEYWORDS: graph
EXAMPLE:  example printGraph; shows an example
"
{
  print(netList(G.edges));
  int ct = 0;
  for (int i =1 ; i<=size(G.edges); i++){if (size((G.edges)[i])==1){ct=ct+1;}}
  if (ct!=0)
  {
      print("Graph with "+string(size(G.vertices))+" vertices, "+string(size(G.edges)-ct)+" bounded edges and "+string(ct)+" unbounded edges");
  } else {
      print("Graph with "+string(size(G.vertices))+" vertices and "+string(size(G.edges))+" edges");
  }
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  G;
}


proc printLabeledGraph(labeledgraph G)
"USAGE:  printLabeledGraph(G); G labeledgraph@*
ASSUME:  G is a labeled graph.
THEORY:  This is the print function used by Singular to print a labeled graph.
KEYWORDS: Feynman graph
EXAMPLE:  example printLabeledGraph; shows an example
"
{
  print(netList(G.edges));
  int ct;
  for (int i =1 ; i<=size(G.edges); i++){if (size((G.edges)[i])==1){ct=ct+1;}}
  if (ct!=0)
  {
      print("Graph with "+string(size(G.vertices))+" vertices, "+string(size(G.edges)-ct)+" bounded edges and "+string(ct)+" unbounded edges");
  } else {
      print("Graph with "+string(size(G.vertices))+" vertices and "+string(size(G.edges))+" edges");
  }
  int ringdef = (typeof(basering)=="ring");
  if (ringdef){def R1 = basering;}
  def R2 = G.over;
  setring R2;
  list labels =G.labels;
  "";
  print("Edgeterms: ");
  list ev;
  Net ne;
  for (i = 1; i<=size(G.edges);i++){
     ne = net(G.edges[i])+net(" => ")+net(string(labels[i]));
     ev[i]=ne;
  }
  print(netList(ev));
  kill labels;
  if (ringdef){setring R1;}

}
example
{ "EXAMPLE:"; echo=2;
  ring R=(0),q(1..6),dp;
  labeledgraph G = makeLabeledGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4)),R, list (q(1),q(2),q(3),q(4),q(5),q(6)),R);
  G;
}

proc printIBP(oneIBP I)
"USAGE:  printIBP(I); I oneIBP@*
ASSUME:  I is an IBP identity computed using computeIBP.
THEORY:  This is the print function used by Singular to print an IBP relation.
KEYWORDS: Feynman graph
EXAMPLE:  example printLabeledGraph; shows an example
"
{
Net ne;
ne = net("(")+net(string(I.c[1]))+net(")")+net("G")+net("[")+net(string(I.i[1]))+net("]");
  for (int j = 2; j<=size(I.c);j++){
     ne = ne+net("+")+net("(")+net(string(I.c[j]))+net(")")+net("G")+net("[")+net(string(I.i[j]))+net("]");
     
  }
 // ne=ne+net("=0");
printNet(ne);
}

proc printMI(MI I)
{
Net ne;
ne = net("G")+net("[")+net(string(I.masterIntegrals[1]))+net("]");
  for (int j = 2; j<=size(I.masterIntegrals);j++){
     ne = ne+net(",")+net("G")+net("[")+net(string(I.masterIntegrals[j]))+net("]");
     
  }
 // ne=ne+net("=0");
printNet(ne);
}

proc printsetIBP(setIBP I)
"USAGE:  printIBP(I); I setIBP@*
ASSUME:  I is the set of IBP identities computed using computeIBP.
THEORY:  This is the print function used by Singular to print setIBP.
KEYWORDS: Feynman graph
EXAMPLE:  example printLabeledGraph; shows an example
"
{
  setring I.over;
print("Collection of IBP identities of the given graph with respect to the seed "+string(I.seed)+".");
print("Total number of identities= "+string(size(I.IBP)));
}


proc makeGraph(list v, list e)
"USAGE:  makeGraph(v,e); v list, e list@*
ASSUME:  v is a list of integers, e is a list of two element lists of v.
RETURN:  graph with vertices v and edges e
THEORY:  Creates a graph from a list of vertices and edges. The vertices can be any type. The data structure 
         respects the ordering of vertices of edges, so can be used for directed graphs,
KEYWORDS: graph
EXAMPLE:  example makeGraph; shows an example
"
{
  graph G;
  G.vertices = v;
  G.edges = e;
  return(G);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4)));
  G;
}

proc makeLabeledGraph(list v, list e, def R, list lab, def Rpoly)
"USAGE:  makeLabeledGraph(v,e,R,l,P); v list, e list, R ring, l list, P ring @*
ASSUME:  v is a list of integers, e is a list of two element lists of pairwise different elements of v, R is a ring, l is a list of labels, P is a ring
RETURN:  labeled graph with vertices v and edges e with labels of the edges in R with infinite edges being constants
KEYWORDS: Feynman graph
EXAMPLE:  example makeLabeledGraph; shows an example
"
{
  labeledgraph G;
  G.vertices = v;
  G.edges = e;
  G.over = R;
  G.overpoly = Rpoly;
  G.labels = lab;
  return(G);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=(0),q(1..6),dp;
  labeledgraph G = makeLabeledGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4)),R, list (q(1),q(2),q(3),q(4),q(5),q(6)),R);
  G;
}



proc labelGraph(graph G, int ch)
"USAGE:  labelGraph(G); G graph@*
ASSUME:  G is a graph and ch is either zero or a prime.
RETURN:  labeled graph with polynomial variables q_i at the bounded edges and function field variables p_i at the unbounded edges over a prime field of characteristic ch
KEYWORDS: Feynman graph
EXAMPLE:  example labelGraph; shows an example
"
{
  int ringdef = (typeof(basering)=="ring");
  if (ringdef){def R1 = basering;}
  int ct;
  for (int i = 1 ; i<=size(G.edges); i++){if (size((G.edges)[i])==1){ct=ct+1;}}
  int anzq = size(G.edges)-ct;
  ring P = (ch),(p(1..ct),q(1..anzq)),ip;   
  ring R = (ch,p(1..ct)),(q(1..anzq)),ip;   
  list lab;
  int pidx = 1;
  int qidx = 1;
  for (i = 1 ; i<=size(G.edges); i++){
      if (size((G.edges)[i])==1){
          lab[i]=p(pidx);
          pidx = pidx+1;
      } else {
          lab[i]=q(qidx);
          qidx = qidx+1;
      }
  }
  labeledgraph lG = makeLabeledGraph(G.vertices,G.edges,R, lab,P);
  if (ringdef){setring R1;}
  return(lG);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  lG;
}

proc balancingIdeal(labeledgraph G)
"USAGE:  balancingIdeal(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  ideal of balancing condition of the graph, basering is assumed to be G.over
KEYWORDS: Feynman graph
EXAMPLE:  example balancingIdeal; shows an example
"
{
 
  list v = G.vertices;
  list e = G.edges;
  list lab = G.labels;
  int i,j;
  ideal I;
  poly edg;
  poly rel;
  for (i = 1; i<=size(v); i++){
    edg=0;
    for (j = 1; j<=size(e); j++){
     if (size(e[j])==2){
       if (e[j][1]==v[i]){edg=edg+lab[j];}
       if (e[j][2]==v[i]){edg=edg-lab[j];}
     } else {
       if (e[j][1]==v[i]){edg=edg+lab[j];}
     }
    }
    I=I+ideal(edg);
  }
  for (j = 1; j<=size(e); j++){
   if (size(e[j])==1){
     rel=rel+lab[j];
   }
  }
  I=I,rel;
  return(I);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  def R= lG.over;
  setring R;
  ideal I = balancingIdeal(lG);
}


proc eliminateVariables(labeledgraph G)
"USAGE:  eliminateVariables(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  labeled graph with variables of the bounded edges eliminated according to balancing condition
KEYWORDS: Feynman graph
EXAMPLE:  example eliminateVariables; shows an example
"
{
  int ringdef = (typeof(basering)=="ring");
  if (ringdef){def R1 = basering;}
  def RP=G.overpoly;
  def R=G.over;
  setring R;
  ideal I = balancingIdeal(G);
  setring RP;
  ideal I = imap(R,I);
  option(redSB);
  I=std(I);
  poly ld;
  poly ta;
  labeledgraph G1=G;
  list eliminatedVariables;
  for (int i = 1; i<=size(I);i++){
     ld=lead(I[i]);
     ta=ld-I[i];
     setring R;
     poly ld = imap(RP,ld);
     eliminatedVariables[i]=ld;
     poly ta = imap(RP,ta);
     G1=substituteGraph(G1,ld,ta);
     kill ld,ta;
     setring RP; 
  ;}
  kill ld,ta;
  setring R;
  kill I;
  G1.elimvars=eliminatedVariables;
  kill eliminatedVariables;
  setring RP;
  kill I;
  if (ringdef){setring R1;}
return(G1);}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  eliminateVariables(lG);
}

proc deleteFromIntvec(intvec v, int j){
intvec w;
int idx=1;
for (int i = 1;i<=size(v);i++){
   if (j != i){w[idx]=v[i];idx=idx+1;}
}
return(w);}


proc removeVariable(def R, int j)
"USAGE:  removeVariable(R); R ring@*
ASSUME:  R is a polynomial ring
RETURN:  polynomial ring with j-th variable removed
KEYWORDS: ring
EXAMPLE:  example removeVariable; shows an example
"
{
list L = ringlist(R);
int nv;
if ((j<1) or (j>(nvars(R)))){ERROR("Index out of range");}
L[2]=delete(L[2],j);
for (int i = 1;i<=size(L[3])-1;i++){
   nv=nv+size(L[3][i][2]);
   if (nv>=j){
      if (size(L[3][i][2])==1){L[3]=delete(L[3],i);break;}
      L[3][i][2]=deleteFromIntvec(L[3][i][2],j-nv+size(L[3][i][2]));
      break;
   }
}
def S = ring(L);
return(S);}
example
{ "EXAMPLE:"; echo=2;
ring R=0,(x,y,z),(lp(2),dp(1));
def S= removeVariable(R,2);
S;
}


proc removeParameter(def R, int j)
"USAGE:  removeParameter(R); R ring@*
ASSUME:  R is a polynomial ring
RETURN:  polynomial ring with j-th variable removed
KEYWORDS: ring
EXAMPLE:  example removeParameter; shows an example
"
{
list L0 = ringlist(R);
list L = L0[1];
int nv;
if ((j<1) or (j>(size(L[2])))){ERROR("Index out of range");}
L[2]=delete(L[2],j);
for (int i = 1;i<=size(L[3])-1;i++){
   nv=nv+size(L[3][i][2]);
   if (nv>=j){
      if (size(L[3][i][2])==1){L[3]=delete(L[3],i);break;}
      L[3][i][2]=deleteFromIntvec(L[3][i][2],j-nv+size(L[3][i][2]));
      break;
   }
}
L0[1]=L;
def S = ring(L0);
return(S);}
example
{ "EXAMPLE:"; echo=2;
ring R=(0,p(1),p(2),p(3)),(x,y,z),(lp(2),dp(1));
def S= removeParameter(R,2);
S;
}




proc substituteGraph(labeledgraph G, poly a, poly b)
"USAGE:  substituteGraph(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  substitute the variable a in the labeling by b
KEYWORDS: Feynman graph
EXAMPLE:  example eliminateVariables; shows an example
"
{
  list L=G.labels;
  for (int i = 1; i<=size(L);i++){
    L[i]=subst(L[i],a,b);
  }
  labeledgraph G1 = makeLabeledGraph(G.vertices,G.edges,G.over,L,G.overpoly);
return(G1);
}



proc feynmanDenominators(labeledgraph G)
"USAGE:  feynmanDenominators(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  ideal containing the propagators in the Feynman integral
KEYWORDS: Feynman graph
EXAMPLE:  example feynmanDenominators; shows an example
"
{
  list L = G.labels;
  def S= G.over;
  setring S;
  ideal J;
  for (int i = 1; i<=size(L);i++){
      if (size(G.edges[i])==2){J[i]=L[i]^2;}
  }
  return(J);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph lGelim = eliminateVariables(lG);
  def R = lGelim.over;
  setring R;
  ideal I = feynmanDenominators(lGelim);
  I;
}


proc propagators(labeledgraph G)
"USAGE:  propagators(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  ideal, containing the denominators in the Feynman integral
KEYWORDS: Feynman graph
EXAMPLE:  example propagators; shows an example
"
{
  list L = G.labels;
  def S= G.over;
  def RP= G.overpoly;
  setring S;
  ideal J;
  for (int i = 1; i<=size(L);i++){
      if (size(G.edges[i])==2){J[i]=L[i]^2;}
  }
  ideal infedges;
  for (i = 1; i<=size(G.edges);i++){
      if(size(G.edges[i])==1){infedges[i]=G.labels[i]^2;}
  }
  setring RP;
  ideal J = imap(S,J);
  ideal infedges = imap(S,infedges);
  J=reduce(J,std(infedges));
  setring S;
 ideal J=imap(RP,J);
  return(J);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph lGelim = eliminateVariables(lG);
  def R = lGelim.over;
  setring R;
  ideal I = propagators(lGelim);
  I;
}

proc ISP(labeledgraph G)
"USAGE:   ISP(G); G labeledgraph@*
ASSUME:   G is a labeled graph
RETURN:   ideal, containing the irreducible scalar products, that is, those scalar product which are not 
          linearly dependent on the propagators.
KEYWORDS: Feynman graph
EXAMPLE:  example ISP; shows an example
"
{
  int i;
  def S= G.over;
  def RP = G.overpoly;
  setring S;
  ideal J = propagators(G);
  list el = G.elimvars;
  ideal infedges;
  for (i = 1; i<=size(G.edges);i++){
      if(size(G.edges[i])==1){infedges[i]=G.labels[i];}
  }
  setring RP;
  ideal J = imap(S,J);
  ideal infedges = imap(S,infedges);
  J=J+infedges^2;
  if (not defined(el)){list el = imap(S,el);}
  for (i = 1; i<=size(el);i++){
      J=J+ideal(el[i]);
  }
  J=std(J);
  list L = kbase(J,2);
  ideal I = L[1..size(L)];
  kill J,infedges,el,L;
  setring S;
  ideal K=imap(RP,I);
  return(K);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(1,2),list(3,6),list(4,5),list(1,6),list(2,3),list(5,6),list(3,4),list(1),list(2),list(5),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  G1;
  ring R= G1.over;
  setring R;
  R;
  ISP(G1);
}

proc removeElimVars(labeledgraph G)
"USAGE:  removeElimVars(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  Removes the variables from G.elimvars. This key is generated by the procedure eliminateVariables.
KEYWORDS: Feynman graph
EXAMPLE:  removeElimVars G; shows an example
"
{
labeledgraph G1;
def R= G.over;
def RP = G.overpoly;
G1.vertices=G.vertices;
G1.edges = G.edges;
setring R;
list el = G.elimvars;
list lb = G.labels;
list iv,ip;
int j,i;
for (i = 1; i<=size(el);i++){
  if (rvar(el[i]) != 0){
     iv[size(iv)+1]=rvar(el[i]);
  } else {
     for (j=1;j<=npars(R);j++){ 
       if (par(j)==el[i]){ip[size(ip)+1]=j;break;}
     }
  }
}
iv = sort(iv)[1];
ip = sort(ip)[1];
def R1 = R;
for (i = size(iv); i>=1;i--){
  R1 = removeVariable(R1,iv[i]);
}
for (i = size(ip); i>=1;i--){
  R1 = removeParameter(R1,ip[i]);
}
kill iv;
setring RP;
list el = imap(R,el);
list iv;
for (i = 1; i<=size(el);i++){
  iv[size(iv)+1]=rvar(el[i]);
}
iv = sort(iv)[1];
def RP1 = RP;
for (int i = size(iv); i>=1;i--){
  RP1 = removeVariable(RP1,iv[i]);
}
setring R1;
list tr =imap(R,lb);
G1.labels = tr;
G1.over = R1;
G1.overpoly = RP1;
G1.elimvars =list();
return(G1);}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(1,2),list(3,6),list(4,5),list(1,6),list(2,3),list(5,6),list(3,4),list(1),list(2),list(5),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);
  G2;
  ring R= G2.over;
  setring R;
  R;
  G2;
}


proc computeBaikovMatrix(def G0)
"USAGE:  computeBaikovMatrix(G); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
RETURN:  a labeled graph G1, computes the Baikov matrix of G defined in G1.baikovover and stores it in G1.baikovmatrix
KEYWORDS: Feynman graph
EXAMPLE:  removeElimVars G; shows an example
"
{
  
if (typeof(G0)=="graph"){
  labeledgraph lG = labelGraph(G0,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);
  //return(computeBaikovMatrix(G2));
  kill G0;
  labeledgraph G0 = G2;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
def RP = G.overpoly;
setring R;
ideal P = propagators(G);
ideal I = ISP(G);
ideal PI=P,I;
setring RP;
ideal PI = imap(R,PI);
int i,j;
ideal gram;
int idx=1;
int startvars= npars(R)+1;
//-----------------------
print("Assignment of Baikov variables:");
for(int i=1; i<=size(PI);i++){
print("z("+string(i)+")"+"=>"+string(PI[i]));
}
//-----------------------

for (i = 1;i<=nvars(RP);i++){
   for (j = 1;j<=nvars(RP);j++){
     if ((i>=startvars) or (j>=startvars)){
        gram[idx] = var(i)*var(j);
     } else {
        gram[idx] = 0;
     }
     idx++;
   }
}
for (i = 1;i<startvars;i++){
   for (j = i+1;j<startvars;j++){
      PI=PI,var(i)*var(j);
  }
}
matrix A = lift(PI,gram);
int m = npars(R);
int m2 = (m*(m-1)) div 2;
//----------------------------
int mt;
if(m2==0){
mt=1;
}
else{
mt=m2-1;
}
//----------------------------
//int mt= m2-1;

int n = ncols(PI)-m2;
ring Z = (0,(t(1..mt),D)),(z(1..n)),dp; //change this
//ring Z = (0,t(1..mt)),(z(1..n)),dp;
matrix B[nvars(RP)][nvars(RP)];
int idx=1;
poly sumt;
list pq;
for (i=1; i<=m;i++){
  for (j=i+1; j<=m;j++){
    if (idx<=mt){
      B[i,j]=1/2*t(idx);
      sumt=sumt+1/2*t(idx);
      pq[idx] = 1/2*t(idx);
    } else {
      B[i,j]=-sumt;
      pq[idx]=-sumt;
    }
    B[j,i]=B[i,j];
    idx++;
  }
}


matrix zvars[1][n+m2] = z(1..n),pq[1..m2];
matrix A = imap(RP,A);
matrix Bentries = zvars * A;
matrix B1[nvars(RP)][nvars(RP)] = Bentries[1,1..ncols(Bentries)];
B=B+B1;
labeledgraph GG =G;
GG.baikovover=Z;
GG.baikovmatrix = B;
return(GG);}
example
{ "EXAMPLE:"; echo=2;labeledgraph G1 = computeBaikovMatrix(G);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB= G1.baikovover;
  setring RB;
  RB;
  matrix B = G1.baikovmatrix;
  printMat(B);
}


//////////////////////////////////////////////////////////////////
//     Generate IBP identities using Module Intersecation       //
//////////////////////////////////////////////////////////////////


proc computeM1(def G0)
"USAGE:  computeM1(G0); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
RETURN:  The module M1 over G1.baikovover that requires to compute IBP identities 
KEYWORDS: Feynman graph
"

{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
 // return(computeM1(G1));
 kill G0;
 labeledgraph G0=G1;
 
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
matrix C[n][n];
int tem=0;
int E = m;
int L = nvars(R);
list x;
for(int i=1;i<=E;i++){
  for(int j=E+1;j<=E+L;j++){ 
    tem=tem+1;
    x[tem]=[i,j];   
    for(int k=1;k<=n;k++){
      C[tem,k]=diff(B[i,j],z(k));
    }
  }
}
for(int i=E+1;i<=E+L;i++){
  for(int j=i;j<=E+L;j++){ 
    tem=tem+1;   
    x[tem]=[i,j];
    for(int k=1;k<=n;k++){
      C[tem,k]=diff(B[i,j],z(k));
    }
  }
}

matrix D=inverse(C);
module M;
int tem=1;
for(int i=E+1;i<=E+L;i++){
  for(int j=1;j<=E+L;j++){
    
    vector t=0*gen(n+1);
    for(int l=1;l<=n;l++){
      poly a=0;
      for(int k=1;k<=E+L;k++){
        //find the right row correspond to derivative
            int o=0;
            int c1;
            poly c2=0;
            if(i==k){
              c1=2;
            } else {
              c1=1;
            }
            
          for(int r=1;r<=size(x);r++){
            if([i,k]==x[r] or [k,i]==x[r] ){
              o=r;
              
            }
          }

          if(o != 0){
            c2=D[l,o];
          }
          a=a+c1*c2*B[j,k];
      }
    t=t+a*gen(l);
    }
    if(i==j){
      t=t-2*gen(n+1);
    } else {
      t=t+0*gen(n+1);
    }
    M[tem]=t;
    tem=tem+1;
  }
}
//Test the computation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
    }
  testP=testP+M[j][n+1]*F;
  if(testP != 0){
    print("Something wrong");
  }

}

return(M);
}

example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
}

proc computeM2(def G0,list Nu)
"USAGE:  computeM2(G,Nu); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The module M2 over G1.baikovover that requires to compute IBP identities 
KEYWORDS: Feynman graph
"
{
  if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
 // return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0 = G1;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}

labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);

if(size(Nu) != n){
   ERROR("The length of the vector nu must equal to number of Baikov variables");
}

int tem=0;
int E = m;
int L = nvars(R);

module M2;

for(int i=1;i<=n;i++){
  if(Nu[i]>0){
              M2[i]=z(i)*gen(i);
              } else {
                      M2[i]=1*gen(i);
                      }
}
M2[n+1]=1*gen(n+1);
return(M2);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module M2=computeM2(G1,list(1,1,1,0,0,1,0,0,0));
    module M2=computeM2(G1, list(1,1,1,1,1,1,1,-5,0));
   
    M2;
}



proc computeIBP(def G0,list Nu)
"USAGE:  computeIBP(G0,Nu); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The set of IBPS correspond to G0 and given Nu.
KEYWORDS: Feynman graph
"
{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  //return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0 = G1; 
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}

labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);

if(size(Nu) != n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}

module M1=computeM1(G,Nu);
module M2=computeM2(G,Nu);
timer=0;

option(redSB);
module M=std(intersect(M1,M2));
int elapsed_time=timer;
print("time elapsed for compute module intersection: " + string(elapsed_time));
// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
    }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}
//

ring Z=RB;
setIBP S;


S.over=Z;


S.seed=Nu;
//setring Z;
//module M=imap(RB,M);
int p=1;
for(int i=1;i<=size(M);i++){
  list y;
  list l;
  //computation of polynomial
  poly f=0;
  for(int j=1;j<=n;j++){
    f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));  
  }
  poly h=(D-L-E-1)/2;
  f=f-M[i][n+1]*h; 
  if(f != 0){
    int t=1;
      while(f != 0){
        y[t]=leadcoef(f);
        list nu;
        for(int k=1;k<=size(Nu);k++){
          nu[k]=Nu[k]-leadexp(f)[k];
        }
      l[t]=nu;
      t=t+1;
      f=f-lead(f);
      }
    oneIBP I;
    I.c=y;
    I.i=l;
    S.IBP[p]=I;
    p=p+1;  
  }

}
//ring Z= 0,(t(1..(m-1)),D),dp;
//S.over=Z;
return(S);

}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  S;
  oneIBP I=S.IBP[1];
  I;

}

///////////////////////////////////////////////////////////////
// Getting reduced IBP system to solve the reduction problem //
//for given target integrals                                 //
///////////////////////////////////////////////////////////////


//**Steps(to solve the problem sequentially)
//0. We are given the feynman graph and list of target integrals assocated to the graph which we need to solve the reduction problem
//1. Create the labelled graph and compute Baikov matrix
//2. Decide whether we need one sector web or more than one web (there are more than one integral family), to solve the problem. If there are more than one web, we have to handle them sepeately
//   so that we have different set of reduced IBP relations for each integral class.
// ** Assume we can solve the problem using one sector web
//3. Create the initial sector Web structure. Also create two lists to store independent IBP identities (say indIBPs), and master integrals (MI)
//4. Upadate the web including target integrals to the web
//5. Starting from the top layer of the web,
//6. For each sector in that layer, generate IBP relations correspond to each integrals belong to that sector.
//7. Then using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
//8. update indIBPs and ML
//9. using tail integrals, update the sector Web.
//10.If we have done step 6-8 for each sector in that layer, then move to next layer and so on.

// ** master integrals are the integrals (in our consideration) are the integrals correspond to nonzero coefficients in rref  that are belong to 
//    corresponding sector. others will be tail integrals


proc getSector(list l)
"USAGE:   getSector(l); l list@*
ASSUME:   l is a list of integer indices of a Feynman integral 
RETURN:   list L, L[1]=s The sector (a list of 1s and 0s) that the corresponding integral belongs
          L[2]=n The sector in that the integral belongs 
KEYWORDS: Feynman graph
"
{
  list s;
  list n;
  for(int i=1;i<=size(l);i++){
    if(l[i]>0){ //changed
      s[i]=1;
      n[size(n)+1]=i;
    }
    else
    {
      s[i]=0;
    }
  }
  return(list(s,n));
}
example
{ "EXAMPLE:"; echo=2;
  list l=list(1,2,-3,-4,0,1);
  list s=getSector(l);
  s;
}


proc getCombinations(list L,int r,list pre)
{
  int n=size(L);
  list op;
  if(size(pre)==r){
    op[size(op)+1]=pre;
    return(op);
  }
  if(n==0)
  {
    return(list());
  }
  list remL=delete(L,1);
  list npre=pre;
  npre[size(npre)+1]=L[1];
  list ex1=getCombinations(remL,r,npre);
  list ex2=getCombinations(remL,r,pre);
return(ex1+ex2);
}


proc listCombinations(list L,int r)
"USAGE:   listCombintions(L,r); L list, r int@*
ASSUME:  
RETURN:   list of r-combinations of the elements in the list L 
KEYWORDS: feynman graph
EXAMPLE:  example listCombinations; shows an example
"
{
  
  return(getCombinations(L,r,list()));
}

example{"EXAMPLE:"; echo=2;
ring R=0,(x,y,z),dp;
list L=listCombinations(list(1,2,3,4),3);
L[1];

}


proc generateWebSectors(list seed)
"USAGE:   generateWebSectors(seed);seed list@*
ASSUME:   seed is a list of integer values.
RETURN:   Web structure of the sectors L, where L is the list and L[1] is the sector that correspond to the  given seed and L[i] 
          contain the subsectors of the sectors in L[i-1]. Note that sector maps between the sectors have not been setted. 
KEYWORDS: feynman graph
EXAMPLE:  example generateWebSectors; shows an example
"
{
list L=getSector(seed);
list sector=L[1];
int nSectors=2^size(L[2]);
list sectorWeb;
for(int i=0;i<size(L[2]);i++)
  {
    list comb=listCombinations(L[2],size(L[2])-i);
    list l;
    for(int j=1;j<=size(comb);j++){
      oneSector s;
      s.lab=comb[j];
      l[j]=s;
    }
  sectorWeb[i+1]=l;
  }
return(sectorWeb);
}
example{

  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
}



proc isSubList(list l1,list l2)
"USAGE:   isSubList(l1,l2); l1 list, l2 list@*
ASSUME:   l1 and l2 are list of positive integers
RETURN:   1 if elements in l1 contain in l2
          0 if elements in l1 do not contain in l2
KEYWORDS: 
EXAMPLE:  isSubList; shows an example
"
{
  if(size(l1) > size(l2)){
    return(-1);
  }
  else{
    int ind=0;
    for(int i=1;i <= size(l1);i++){
      for(int j=1;j <= size(l2);j++){
        if(l2[j]==l1[i]){
          ind=ind+1;
        }
      }
    }
    if(ind==size(l1)){
      return(1);
    }
    else{
      return(0);
    }
  }
}
example{"EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  list l1=list(1,2,3,4,5,6,7);
  list l2=list(1,4,6);
  list l3=list(1,2,8);
  list l4=list(1,4,6);
  isSubList(l2,l1);
  isSubList(l3,l1);
  isSubList(l1,l2);
  isSubList(l2,l4);
}





proc getSectorMap(list L1,list L2)
"USAGE:   getSectorMap(L1,L2); L1 list, L2 list, sector@*
ASSUME:   L1 and L2 are lists of sectors where the lab field of each sector in both lists are filled(i.e. two layers of a sector web)
RETURN:   L1 where sectorMap  of each sector in the list L1 is filled.
KEYWORDS: sector,graph,feynman,setIBP
EXAMPLE:  getSectorMap; shows an example
"

{
//compare the containment
for(int i=1;i<=size(L1);i++)
{

  for(int j=1;j<=size(L2);j++)
  {
    oneSector s=L2[j];
    if(isSubList(L2[j].lab,L1[i].lab)==1)
    {
      L1[i].sectorMap[size(L1[i].sectorMap)+1]=j;
    }
  }
}
return(L1);
}
example{"EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=getSectorMap(w[1],w[2]);
  w1[1].sectorMap;
  list w2=getSectorMap(w[2],w[3]);
  w2[2].sectorMap;
}


proc setSectorMap(list sectorWeb)
"USAGE:   setSectorMap(sectorWeb); sectorWeb list, sector@*
ASSUME:   sectorWeb is an output produced by the function @*generateWebSectors
RETURN:   sectorWeb where the field sectorMap field of each sector in sectorWeb is filled.
KEYWORDS: sector, generateWebSectors, getSectorMap
EXAMPLE:  setSectorMap; shows an example
"
{
  for(int i=1;i<=size(sectorWeb)-1;i++)
  {
    list L1=sectorWeb[i];
    list L2=sectorWeb[i+1];
    sectorWeb[i]=getSectorMap(L1,L2);
  }
  return(sectorWeb);
}
example{
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=setSectorMap(w);

}

proc findSector(list sectorWeb, list currentPosition, list L)
"USAGE:   findSector(sectorWeb,currentPosition,L); sectorWeb list,currentPosition list,L list,
ASSUME:   sectorWeb is an output produced by the function generateWebSectors@*, L is an output produced by the function getSector@*
RETURN:   position of the sector in the sectorWeb, where the L belongs. 
          -1, if the sector is not found
KEYWORDS: sector, generateWebSectors, getSectorMap
EXAMPLE:  findSector; shows an example
"
{ 
  list pos;
  for(int i=currentPosition[1];i <= size(sectorWeb);i++)
  {
    for(int j=currentPosition[2]; j<= size(sectorWeb[i]);j++)
    {
      if(isSubList(L,sectorWeb[i][j].lab) ==  1 and isSubList(sectorWeb[i][j].lab,L)  ==  1)
      {
          pos[1]=i;
          pos[2]=j;
      } 
    }

  }
  if(size(pos)==0){
    return(-1);
  }
  else
  {
    return(pos);
  }

}
example{
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=setSectorMap(w);
  list oneInt=list(4,-1,-1,0,-1,-2);
  list L=getSector(oneInt);
  def pos=findSector(w1,list(1,1),L[2]);
  isSubList(w[pos[1]][pos[2]].lab,L[2])==1 && isSubList(L[2],w[pos[1]][pos[2]].lab); //this returns 1, since the given integral is in the sector at pos.

  //example for a integral that is not in the set
  list oneInt=list(4,1,0,-1,-2,3);
  list L=getSector(oneInt);
  def pos=findSector(w1,list(1,1),L[2]);
  pos;
  
}



proc updateOneSector(list sectorWeb, list currentPosition,list oneInt)
"USAGE:   updateOneSector(sectorWeb,currentPosition,oneInt); sectorWeb list, sector@*
ASSUME:   sectorWeb is an output produced by the function generateWebSectors@*, oneInt is a list of indeces of the denominators 
          associated to an integral correspond to a given feynman graph. Also assume the sectorweb isalso  associated to the same feynman graph.
RETURN:   updated sectorWeb, where the oneInt is assigned to the targetInts field of the seector correspond to provided oneInt
KEYWORDS: sector, generateWebSectors, getSectorMap,updateWeb,findSector
EXAMPLE:  updateOneSector; shows an example
"
{
  list L=getSector(oneInt);
  list a=findSector(sectorWeb,currentPosition,L[2]);
  if(size(a)<=1)
  {
    print("given integral is not belong to the given Web");
    return(sectorWeb);
  }
  
  sectorWeb[a[1]][a[2]].targetInts[size(sectorWeb[a[1]][a[2]].targetInts)+1]=oneInt;
  return(sectorWeb);
}
example{"EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=setSectorMap(w);
  list oneInt=list(4,-1,-1,0,-1,-2);
  list w2=updateOneSector(w1,list(1,1),oneInt);
  list L=getSector(oneInt);
  L[2];
  w2[3][2].lab;
}

proc updateWeb(list sectorWeb, list currentPosition,list setInt)

"USAGE:   updateWeb(sectorWeb,currentPosition,setInt); sectorWeb list, sector@*
ASSUME:   sectorWeb is an output produced by the function generateWebSectors@*, setInt is a list of indeces of the denominators 
          associated to  integrals correspond to a given feynman graph. Also assume the sectorweb is also  associated to the same feynman graph.
RETURN:   list (sectorWeb,MasterInt,notInWeb) where,
          sectorWeb is the updated web by assingning integrals to correspondng sectors,
          masterInt is the list integrals belong to the sector at currentPosition
          notInWeb is the list of integrals that are not belong the integral family associated the SectorWeb.
KEYWORDS: generateWebSectors, getSector,findSector
EXAMPLE:  updateWeb; shows an example
"

{ 
  list masterInt;
  list notInWeb;
  for(int i=1;i <= size(setInt);i++)
  { list oneInt=setInt[i];
    list L=getSector(oneInt);
    list a=findSector(sectorWeb,currentPosition,L[2]);
    if(size(a) <= 1)
    {
      notInWeb[size(notInWeb)+1]=oneInt;
    }
  
    else
    {
      sectorWeb[a[1]][a[2]].targetInts[size(sectorWeb[a[1]][a[2]].targetInts)+1]=oneInt;
      if(a[1] == currentPosition[1] and a[2] == currentPosition[2])
      {
        masterInt[size(masterInt)+1]=oneInt;
      }
    }
  }

  return(list(sectorWeb,masterInt,notInWeb));
}
example{
  "EXAMPLE:"; echo=2;
  ring R=(0,(t,D)),(x,y,z),dp;
  list l=list(1,2,1);
  list w=generateWebSectors(l);
  list w1=setSectorMap(w);
  list setInt=list(list(1,2,3),list(-1,1,2),list(1,1,-1),list(-1,0,-2));
  list setInt=list(list(1,2,3));
  list setInt=list(l);
  
  list L1=pickHighestSector(setInt);
  list w2=updateWeb(w1,list(1,1),L1[1]);
  w2[2]; //master integrals
  w2[3];//integrals not in the web
}
example{
"EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  
  list w2=updateWeb(web,list(1,1),L1[1]); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web
  web=w2[1]; 
  setIBP S=computeIBP(G1,L1[1][1]);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101); //L[1]=list of independent IBPs,L[2]=list of master integrals
  list independIBPs=L[1];
  list masterAndTailIntgrals=L[2];
  size(independIBPs) < size(S.IBP); //number of linearly independent set of IBPs are less than the number of orginal IBPs. So this returns true
  
  oneIBP I1=independIBPs[18];     //Here is an example for one IBP i
  I1;
  list w3=updateWeb(web,list(1,1),masterAndTailIntgrals); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web
  web=w3[1];   
  size(web[1][1].targetInts);
}

//-------------------------------------------------------------------------------
proc getHighestSectorIndex(list targetInt)
"USAGE:  pickHighestSector(targetInt); G is a list of list of integers of same length
ASSUME:  targetInt is the list of target integrals 
RETURN:  the intgral that belong to the heighest sector, if all integrals belong to the same sector web; otherwise, it returns a list of collection of integrals 
         each need to be handled using different sector webs,
KEYWORDS: Feynman graph
"
{
  list sortedInt1;
  list sortedInt2;
  list intsWithSectors;
  
  for(int i=1;i <= size(targetInt);i++)
  {
    list L=getSector(targetInt[i]);
    intsWithSectors[size(intsWithSectors)+1]=list(list(L[2],targetInt[i],i),list(size(L[2])));
  }
  list L=lexSort(intsWithSectors);
 return(L[size(L)][1][3]);
}


proc pickHighestSector(list targetInt)
"USAGE:  pickHighestSector(targetInt); G is a list of list of integers of same length
ASSUME:  targetInt is the list of target integrals 
RETURN:  the intgral that belong to the heighest sector, if all integrals belong to the same sector web; otherwise, it returns a list of collection of integrals 
         each need to be handled using different sector webs,
KEYWORDS: Feynman graph
"
{
  list sortedInt1;
  list sortedInt2;
  list intsWithSectors;
  
  for(int i=1;i <= size(targetInt);i++)
  {
    list L=getSector(targetInt[i]);
    intsWithSectors[size(intsWithSectors)+1]=list(list(L[2],targetInt[i]),list(size(L[2])));
  }
  list L=lexSort(intsWithSectors);
  for(int i=size(L);i>=1;i--)
  {
    if(size(sortedInt1)==0)
    {
      sortedInt1[1]=L[i][1][1];
      sortedInt2[1]=list(L[i][1][2]);
    }
    else
    { 
      int id=0;
      for(int j=1;j<=size(sortedInt1);j++)
      { 
        if( isSubList(L[i][1][1],sortedInt1[j])==1)
        {
          sortedInt2[j][size(sortedInt2[j])+1]=L[i][1][2];
          id=id+1;
        }
      }
      if(id==0)
      {
        sortedInt1[size(sortedInt1)+1]=L[i][1][1];
        sortedInt2[size(sortedInt2)+1]=list(L[i][1][2]);
      }
    }
  } 
 
return(sortedInt2);
}
example{"EXAMPLE:"; echo=2;
  list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web
  list L=pickHighestSector(setInt);
  size(L);

  list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2)); //here we need more than one web
  list L=pickHighestSector(setInt);
  size(L);
}

proc setSerial(list L)
{
  string s= "";
  for(int i=1;i<=size(L);i++){
    s=s+string(L[i])+",";
  }
  return(s);
}


proc isInList(list l,string a)
{
int ind=0;
int t;
for(int m=1;m <= size(l);m++){
 // t=0;
 // for(int j=1;j<=size(a);j++){
 //     if(l[m][j]!=a[j]){
 //       t++;
 //     }
  //  }
  
  if(l[m]==a){
    ind++;
  }
          
}
    if(ind==0)
    {
      return(0);
    }
    else
    {
      return(1);
    }
}

//return 1 for true
proc alreadyIntheList(list l,list a)
{
int ind=0;
int t;
for(int m=1;m <= size(l);m++)
{
 // t=0;
 // for(int j=1;j<=size(a);j++){
 //     if(l[m][j]!=a[j]){
 //       t++;
 //     }
  //  }
  
  if(t!=0){
    ind++;
  }
          
}
    if(ind==size(l))
    {
      return(0);
    }
    else
    {
      return(1);
    }
}

proc heaviside(number x)
{
  if(x<0)
  {
    return(0);
  }
  else{
    return(1);
  }
}


proc getSortMeasures(list l)
"USAGE:   getSortMeasures(l); l list, 
ASSUME:   l is a list of integers (i.e a seed). 
RETURN:   list of sort measures that are used in Laporta Algorithm
KEYWORDS: Feynman graph
EXAMPLE:  getSortMeasures; shows an example
"
{
 int Nprop=0;
 int   Nid=0;
 int   r=0;
 int   s=0;
 list rv;
 list sv;
 for(int j=1;j<=size(l);j++){
      Nprop=Nprop+heaviside(l[j]-1/2);
        Nid=Nid+heaviside(l[j]-1/2)*2^(j-1);
        r=r+l[j]*heaviside(l[j]-1/2);
        s=s+absValue(l[j])*heaviside(-l[j]+1/2);
        //--------
        if(l[j]>0){
          rv[size(rv)+1]=l[j];
        }
        else{
          sv[size(sv)+1]=l[j];
        }
        //---------
 }
//return(list(Nprop,Nid,r,s));
list L=list(Nprop,Nid,r,s)+rv+sv;
return(L);
}
example{
  "EXAMPLE:"; echo=2;
  list l=list(1,2,3);
  getSortMeasures(l);
}

proc comp_lex(list l1,list l2)
{
  for(int i=1;i <= size(l1);i++){
    if(l1[i]<l2[i]) {return(-1);} //l1<l2
    if(l1[i]>l2[i]) {return(1);} //l1>l2 
  }
  return(0); // l1=l2
}

proc lexSort(list L)
{
  int n=size(L);
  for(int i=1;i<n;i++)
  {
    for(int j=1;j <= n-i;j++)
    {
      if(comp_lex(L[j][2],L[j+1][2])==1)
      {
        list temp=L[j];
        L[j]=L[j+1];
        L[j+1]=temp;
      }
    }
  }
  return(L);
}


proc substituteList(poly f,list l)
{
  for(int i=1;i <= size(l);i++)
  { f=subst(f,par(i),l[i]);
  }
  return(f);
}
example
{ "EXAMPLE:"; echo=2;
ring R= (0,t,D),(x,y),dp;
poly f=t*D*y+t+D;
list l=list(1,2);
substituteList(f,l);
}

proc extractCoef(oneIBP I,list ind,list l)
"USAGE:   extractCoef(I,ind,l); I oneIBP,ind list,l list,
ASSUME:   ind is the output of getSortedIntegrals, and l is the list of values over the base field I.baikovover. 
          size(l)=npars(I.baikovover)
RETURN:   list of values where, the i-th element is the evaluation of coefficient function  at values in the list l of the IBP relation oneIBP, whose index is i=ind[i][1].
KEYWORDS: feynman graph,IBPs
EXAMPLE:  extractCoef; shows an example
"
{ list v;

  for(int j=1;j <= size(ind);j++){
    int tem=0;
    for(int k=1;k <= size(I.c);k++){
      if(comp_lex(ind[j][1],I.i[k])==0){
        v[j]=substituteList(I.c[k],l);
        tem++;
      }
      if(tem==0){
        v[j]=0;
      }
    }
  } 
  return(v); 
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  oneIBP I=S.IBP[1];
  I;
  list rowCorrespondToI=extractCoef(I,ind,list(1,2,9)); 
  
  // the nonzero coefficient of the IBP relation correspond to integral I(1,1,0,1,0,0,0,1,0).
  // when we use lex ordering to order the used integrals in set of IBPs, this integral correspond to the 82th place.
 // so we get only a nonzero value at position 82 and the below, the output will be -14.

  rowCorrespondToI[82]; //output will be -14
}

proc setMat(setIBP S,list val)
"USAGE:   setMat(S,val); I oneIBP,ind list,l list,
ASSUME:   size(val)=npars(I.baikovover)
RETURN:   matrix,where i-th row correspond to the evaluation of coefficient functions of i-th IBP in setIBP. 
          Columns of the matrix correspond to the all used indices in the setIBP which are ordered with respect 
          to the output ofgetSortMeasures. 
KEYWORDS: feynman graph,IBPs
EXAMPLE:  setMat; shows an example
"
{
  ring RZ=S.over;
  list ind = getSortedIntegrals(S);
  matrix X[size(S.IBP)][size(ind)];
  for(int j=1;j <= size(S.IBP);j++){
    oneIBP L=S.IBP[j];
    list v=extractCoef(L,ind,val);
    for(int k=1;k <= size(v);k++){
      X[j,k]=v[k];
    }
  }

  return(X);
}


proc setMat(setIBP S,list val,list ind){
  ring RZ=S.over;
 // list ind = getSortedIntegrals(S);
  matrix X[size(S.IBP)][size(ind)];
  for(int j=1;j <= size(S.IBP);j++){
    oneIBP L=S.IBP[j];
    list v=extractCoef(L,ind,val);
    for(int k=1;k <= size(v);k++){
      X[j,k]=v[k];
    }
  }

  return(X);
}

example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  matrix N=setMat(S,list(1,2,3),ind);
  
}


proc getRandom(int p,int s)
"USAGE:   getRandom(p,s); 
ASSUME:   p and s are positive integers.
RETURN:   a list of randomly generted integers between 0-(p-1)  size s.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRandom; shows an example
"
{
list L;
intmat m=random(p-1,1,s);
for(int i=1;i <= s;i++)
{
  L[i]=m[1,i];
}
return(L);
}

proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"

{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }

  }

  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }

  }

  return(list(indIBP,seed));
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
  size(L[1])<size(S.IBP);
}



proc getSortedIntegrals(setIBP I)
"USAGE:  getSortedIntegrals(I); I setIBP,
ASSUME:   
RETURN:  list ind where each entry is a pair (indv,sortmeasures),
          indv is the list of indices(seed) appered in the setIBP 
          and sortmeasures is the output of getSortMeasures(indv).
          The function getSortedIntegrals extract the seeds appeared in the IBP identities of the setIBP,
          sort them lexicographically based on the values got from getSortMeasures and return the output.
KEYWORDS: Feynman graph
"
{
  ring RZ=I.over;
  list ind;
  list indS;
  for(int j=1;j<=size(I.IBP);j++)
  {
      oneIBP oneI=I.IBP[j];
      for(int k=1;k <= size(oneI.i);k++)
      {
        list indv=oneI.i[k];
        if(size(ind)==0){
          ind[size(ind)+1]=list(indv,getSortMeasures(indv));
          indS[size(indS)+1]=setSerial(indv);
        }
        else
        { 
          if(isInList(indS,setSerial(indv))==0){
              ind[size(ind)+1]=list(indv,getSortMeasures(indv));
              indS[size(indS)+1]=setSerial(indv);
          }
        }
      }
  }
  

  list indc=lexSort(ind);
return(indc);
}

example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
  list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeManyIBP(G1, targetInt);

  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); //L list of pair of sorted integrals and the corresponding sorting measures
L[1];
}

proc web_g(list targetInt)
{

  //print("targetInt: " + string(targetInt[1]));
  list L = pickHighestSector(targetInt[1]);
  // print L
  //print("L=pickHighestSector(targetInt[1]): " + string(L));
  //print("L[1][1]: " + string(L[1][1]));

  list web = generateWebSectors(L[1][1]);

  return(web);
}


proc getlabels(list web, int i, int j)
{
  list labs = web[i][j].lab;
  return(labs);  
}


proc computeManyIBP(def G0,list setNu)

"USAGE:  computeManyIBP(G0,setNu); G0 graph@*,
ASSUME:  setNu is a list of seeds correspond to the graph G0 which are belong to the same sector 
RETURN:  setIBP S, where it contains all the IBP relations obtained by module intersection and seeding
KEYWORDS: Feynman graph,IBPs
"

{ 
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  //return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0=G1;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
list Nu=setNu[1];
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);

if(size(Nu) != n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}

module M1=computeM1(G,Nu);
module M2=computeM2(G,Nu);
timer=0;
option(redSB);
module M=std(intersect(M1,M2));
//module M=intersect(M1,M2);
int elapsed_time=timer;
print("time elapsed for the computation of  module intersection: " + string(elapsed_time));

// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
  }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}
//

//ring Z= (0,t(1..(m-1)),D),(z(1..n)),dp;
ring Z=RB;
setIBP S;

S.over=Z;
//S.over=RB;

S.seed=Nu;
//setring Z;
//module M=imap(RB,M);
int p=1;
for(int b=1;b<=size(setNu);b++)
{
  list Nu=setNu[b];

  for(int i=1;i<=size(M);i++)
  {
    list y;
    list l;
  //computation of polynomial
    poly f=0;
    for(int j=1;j<=n;j++)
    {
      f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));  
    }
    poly h=(D-L-E-1)/2;
    f=f-M[i][n+1]*h; 
    if(f != 0)
    {
      int t=1;
        while(f != 0)
        {
          y[t]=leadcoef(f);
          list nu;
          for(int k=1;k<=size(Nu);k++)
          {
            nu[k]=Nu[k]-leadexp(f)[k];
          }
        l[t]=nu;
        t=t+1;
        f=f-lead(f);
        }
      oneIBP I;
      I.c=y;
      I.i=l;
      S.IBP[p]=I;
      p=p+1;  
    }

  }
}
//ring Z= 0,(t(1..(m-1)),D),dp;
//S.over=Z;
return(S);
}
example{"EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);

  //here we compute set of IBPs correspond to two seeds seperately
  setIBP IBP1=computeIBP(G1,list(1,1,0,1,0,1,0,-1,0));
  setIBP IBP2=computeIBP(G1,list(1,2,0,3,0,1,0,-2,0));
  size(IBP1.IBP);
  size(IBP2.IBP);
  
  //here we compute set of IBPs correspond both seeds simultaneously 
  //We can use this only when both integrals belongs to the same sector

  setIBP S=computeManyIBP(G,list(list(1,1,0,1,0,1,0,-1,0),list(1,2,0,3,0,1,0,-2,0)));
  size(S.IBP);  
  

}

proc getReducedIBPSystem(graph G,list targetInt )
"USAGE:  getReducedIBPSystem(G,targetInt); targetInt list,G graph@*,
ASSUME:  G is a graph and targetInt is a list of seeds of target integrals. 
RETURN:  list (reducedIBPs,MI) where  reducedIBPs::setIBP, MI::list.
          reducedIBPs contain the reduced IBP system for the target integrals
          MI contain the master integrals

KEYWORDS: Feynman graph,IBPs
"

{
  //Better to check that the provided integrals belong to the same integral family
    
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral family");
    }

   // L[1] is the list of target integrals belong to one integral family but it has arranged so that.. 
   //..L[1][1] is the integral belong to the superior sector.
  // we use this seed (i.e. target integral) to create the web structure 


  //When we do computation sequentially, it is better to have web structure of the sectors upfront.
  //We denote it by a list web, where web[i] contains the sectors belong to that layer.

  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);

  //After creating the web, we have to update it by including the target integrals to the corresponding sectors
  //Because, when we do the intended computation in sectors, we read seeds from this updated 
  //This update step need to perform with tail integrals of each sector, once the computations correspond to sectors in each layer are done. 
  //If the computation done correctly, tail integrals will only be assigned to the sectors in the below layers.

  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];

  // *this return a list w4, where w4[1] is the updated web and
  // w4[2] is the list of integrals that do not belong to the current web (usually contain integrals where all propagator powers are nonpositive!) 

  // We set two places to store reduced IBP relations (a setIBP), and master integrals (a list) that are comes from..
  //..the intended computations relevent to each sector   
  
  //before we go further,we first create the labelled graph G1 of G computing Baikov matrix
  
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MIs;
  int te=0;
  reducedIBPs.seed=targetInt;
  

  int nLayers=size(web);
  for(int j=1; j <= nLayers; j++)
    {

//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.

      int nSectors=size(web[j]);
      for(int k=1; k <= nSectors; k++)
      {
        print("------------------------------------------------------------------------------");
        print("Started the computation in the sector:"+string(k)+ " at layer "+string(j)+". ");
        if(size(web[j][k].targetInts)>=1)
        {
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            reducedIBPs.over=totalIBP.over;
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
//using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
          list L=getRedIBPs(totalIBP,7853);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
// update reducedIBPs. 
          setring R;
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];

            }
          }
    kill R;
//Update the sectors below to the current sector using masterAndTailIntgrals. In this step, we can also.. 
//..distingush the master integrals which will be assigned to MI.
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
          list masterIntgralsInSector=w[2];
         
         // if(size(w[3])<>0){
         //   print("wrong assignement");
            
         //   print("number of master integrals that are in the current sector: "+string(size(w[2])));
         // }
          
          if(size(MIs)==0)
          { 
            MIs=masterIntgralsInSector;
          }
          else
          {
            for(int i=1;i <= size(masterIntgralsInSector);i++)
            {
            //  if(alreadyIntheList(MI,masterIntgralsInSector[i])==0)
            //  {
            //    MI[size(MI)+1]=masterIntgralsInSector[i];
            //  }
                MIs[size(MIs)+1]=masterIntgralsInSector[i];
            }
          }
          print("completed the computation in the sector:"+string(k)+ " at layer "+string(j)+". ");
          
        }   
      }

    }
return(list(reducedIBPs,MIs));
}
example{"EXAMPLE:"; echo=2;

rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  //list targetInt=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
  list finalset=getReducedIBPSystem(G,targetInt);

rtimer-t;
print("timer for sector computations in ms: " + string(rtimer));
  setIBP S=finalset[1];
  ring R=S.over;
  setring R;
  oneIBP I=S.IBP[5];
  I;
  size(finalset[2]);


}

proc OneSectorComputation(labeledgraph G1,list tailInts,list sector_lab )
"USAGE:  
ASSUME:  
RETURN:  
KEYWORDS: Feynman graph,IBPs
"
{ 
  list targetInt;
  setIBP reducedIBPs; //a place to store the independent IBPs coming out from current sector
  list MIs;  //a place to store the Master integrals coming out from current sector
  list OutputtailInts;  //a place to store the tail integrals coming out from current sector
  
//1.Extract target integrals for current sector (which are tail integrals coming from parent 
//sectors)

  for(int i=1;i<=size(tailInts);i++)
  {
    for(int j=1;j<=size(tailInts[i]);j++)
    {
            if(string(getSector(tailInts[i][j])[2])==string(sector_lab)){
        targetInt[size(targetInt)+1]=tailInts[i][j];
      }
    }

  }
  print("size of targetInt: "+string(size(targetInt)));
  if(size(targetInt)==0){
    print("No input integrals came from the parents");
    return(reducedIBPs,MIs,OutputtailInts);
  }
  

//2. Computations related to sector

  setIBP totalIBP=computeManyIBP(G1,targetInt);
  //print("v: "+string(targetInt));
  //print("size(totalIBP.IBP): "+string(size(totalIBP.IBP)));
  list L=getRedIBPs(totalIBP,7853);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
  //print("size(L[1]): "+string(size(L[1])));
  //print("size(L[2]): "+string(size(L[2])));
  reducedIBPs.seed=sector_lab;
  reducedIBPs.over=G1.baikovover;
  reducedIBPs.IBP=L[1];
  for(int i=1;i<=size(L[2]);i++){
    if(string(getSector(L[2][i])[2])==string(sector_lab)){
      MIs[size(MIs)+1]=L[2][i];
    }
    else{
      OutputtailInts[size(OutputtailInts)+1]=L[2][i];
    }
  }
  print("size of reducedIBPs.IBP: "+string(size(reducedIBPs.IBP)));
  print("size of MIs: "+string(size(MIs)));
  print("size of OutputtailInts: "+string(size(OutputtailInts)));
  return(list(reducedIBPs,MIs,OutputtailInts));
}
example{"EXAMPLE:"; echo=2;
//Setting the graph details and Baikov computations

  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
  

 
//sector at(1,1), label:{1,2,3} computations
  list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
  list tail123=SectOutput123[3];

//For sector at(2,1), label:{1,2} computations
  list input12;
  input12[1]=userInput[1];
  input12[2]=tail123;
  list SectOutput12=OneSectorComputation(G1,input12,list(1,2));
  list tail12=SectOutput12[3];

//For sector at(2,2), label:{2,3} computations
  list input23;
  input23[1]=userInput[1];
  input23[2]=tail123;
  list SectOutput23=OneSectorComputation(G1,input23,list(2,3));
  list tail23=SectOutput23[3];
  
//For sector at(2,3), label:{1,3} computations
  list input13;
  input13[1]=userInput[1];
  input13[2]=tail123;
  list SectOutput13=OneSectorComputation(G1,input13,list(1,3));
  list tail13=SectOutput13[3];

//For sector at(3,1) , label :{1} computations
  list input31; //Note that sector at (3,1) has two parents ({1,2} and {1,3}) and one grandparent ({1,2,3})
  input31[1]=userInput[1];
  input31[2]=tail12;
  input31[3]=tail13;
  input31[4]=tail123;
  list SectOutput1=OneSectorComputation(G1,input31,list(1));
  list tail1=SectOutput1[3];

//likewise can go through all the sectors.....

// If we want to see the output for the sector123
///reduced IBPS
  for(int i=1;i<=size(SectOutput123[1].IBP);i++){
    oneIBP I=SectOutput123[1].IBP[i];
    I;
  }
///Master Integrals
   for(int i=1;i<=size(SectOutput123[2]);i++){
    string s="G("+string(SectOutput123[2][i])+"), ";
    s;
    };
///Tail integrals
for(int i=1;i<=size(SectOutput123[3]);i++){
    string s="G("+string(SectOutput123[3][i])+"), ";
    s;
    };


}

proc print_web(list web)
"USAGE: print_web(web); web = list of lists of oneSector structs"
{
  print(" web is :");
  if (size(web) == 0) {
    print("  (empty list)");
    return;
  }
  for (int i = 1; i <= size(web); i++) {
    print("  Layer " + string(i) + ":");
    list layer = web[i];
    for (int j = 1; j <= size(layer); j++) {
      if (typeof(layer[j]) == "oneSector" && defined(layer[j].lab)) {
        print("    Sector " + string(j) + ":");
        print("      lab = " + string(layer[j].lab));
        print("      sectorMap = " + string(layer[j].sectorMap));
        print("      targetInts:");
        for (int k = 1; k <= size(layer[j].targetInts); k++) {
          string s = "        [" + string(k) + "] = ";
          for (int l = 1; l <= size(layer[j].targetInts[k]); l++) {
            s = s + string(layer[j].targetInts[k][l]);
            if (l < size(layer[j].targetInts[k])) { s = s + ","; }
          }
          print(s);
        }
      } else {
        print("    Sector " + string(j) + " = (invalid or undefined)");
      }
    }
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////
/// The following functions can be used for similar computations as above, with user defined//////
/// denominators, propagators and replacement rules.                                        //////
//////////////////////////////////////////////////////////////////////////////////////////////////


////1. Make Baikov matrix

proc makeBaikovMatrix(def G,list internalmomenta,list externalmomenta,list mandelsonvars,list propagat,list replacementRules)
"USAGE:  makeBaikovMatrix(G,internalmomenta,externalmomenta, mandelsonvars, propagat, replacementRules); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
RETURN:  a labeled graph G1, computes the Baikov matrix of G defined in G1.baikovover and stores it in G1.baikovmatrix
KEYWORDS: Feynman graph
EXAMPLE:  removeElimVars G; shows an example
"
{

labeledgraph G1=G;
ideal PI;
//set ideal PI;
for(int i=1;i<=size(propagat);i++){
  PI[size(PI)+1]=propagat[i];
}

//applying replacements for external momenta
ideal infedges;
list pq;
list pqt;
list pqp;
int idx=1;
for(int i=1;i<=size(replacementRules) div 2;i++){
  pqp[size(pqp)+1]=replacementRules[2*i-1];
  pqt[size(pqt)+1]=replacementRules[2*i];
if(replacementRules[2*i]==0){
  infedges[size(infedges)+1]=replacementRules[2*i-1]-replacementRules[2*i];

}
else{
  pq[size(pq)+1]=replacementRules[2*i];
  PI[size(PI)+1]=replacementRules[2*i-1];
  
}
}

if(size(infedges)!=size(externalmomenta)){
ERROR("This is not the situation that we considered in this package. for any external momenta p, it should hold p^2=0.");
}

 PI=reduce(PI,std(infedges));

  ideal gram;
  int ine=size(externalmomenta);
  int bde=size(internalmomenta);
  list labls=externalmomenta;
  for(int i=1;i<=size(internalmomenta);i++){
    labls[size(labls)+1]=internalmomenta[i];
  }

  for (int i = 1;i<=ine+bde;i++){
    for (int j = 1;j<=ine+bde;j++){
          if(i<=ine and j<=ine){
            gram[idx]=0;
          }
          else{
            gram[idx] = labls[i]*labls[j];
          }
      idx++;
    }
  }

//-----------------------------
gram=reduce(gram,std(infedges));

  matrix A = lift(PI,gram);
  int mt=size(mandelsonvars);
  matrix B[bde+ine][bde+ine];
  int idx=1;
  poly sumt;
  for (i=1; i<=bde+ine;i++){
    for (j=i+1; j<=bde+ine;j++){

      for(int k=1;k<=size(pqp);k++){
        if(labls[i]*labls[j]==pqp[k] or labls[j]*labls[i]==pqp[k]){
          B[i,j]=pqt[k];
        }
      }
      if(B[i,j]<>0){
        B[j,i]=B[i,j];
      }
      
  
    }
  }
  //set ring baikov over

  int sizeProp=size(propagat);
  int sizePq=size(pq);
  string parat=string(mandelsonvars);
  string zi;
 
  for(int i=1;i<=size(propagat)-1;i++){
  zi=zi+"z"+string(i)+",";
  }
  zi=zi+"z"+string(size(propagat));
 
  ring Z;
  string cmd="ring Z = (0,("+parat+",D)),("+zi+"),dp";
  execute(cmd);
  setring Z;
  list zl;
  for(int i=1;i<=nvars(Z);i++){
    zl[size(zl)+1]=var(i);
  }
  matrix B=imap(R,B);
  list pq=imap(R,pq);
  matrix zvars[1][sizeProp+sizePq] = zl[1..size(zl)],pq[1..sizePq];
  matrix A = imap(R,A);
  matrix Bentries = zvars * A;
  matrix B1[bde+ine][bde+ine] = Bentries[1,1..ncols(Bentries)];
  B=B+B1;
  printMat(B);
  
  G1.elimvars=list();
  G1.baikovover=Z;
  G1.baikovmatrix=B;
  return(G1);
  
}
example
{ "EXAMPLE:"; echo=2;
  //Setting the graph information
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  //include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
  
  //compute Baikov matrix
  labeledgraph G1=makeBaikovMatrix(G2,internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
}

//// 2. generate IBP relations
//////2.1 compute M1
proc makeM1(def G0)
"USAGE:  makeM1(G0); G labeledgraph, or G graph@*
ASSUME:  G0 is a Graph, or@*
         G0 is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
RETURN:  The module M1 over G1.baikovover that requires to compute IBP identities 
KEYWORDS: Feynman graph
"

{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
 // return(computeM1(G1));
 kill G0;
 labeledgraph G0=G1;
 
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
matrix C[n][n];
int tem=0;
int E = m;
int L = nvars(R);
list x;
for(int i=1;i<=E;i++){
  for(int j=E+1;j<=E+L;j++){ 
    tem=tem+1;
    x[tem]=[i,j];   
    for(int k=1;k<=n;k++){
      //C[tem,k]=diff(B[i,j],z(k));
      C[tem,k]=diff(B[i,j],var(k));
    }
  }
}
for(int i=E+1;i<=E+L;i++){
  for(int j=i;j<=E+L;j++){ 
    tem=tem+1;   
    x[tem]=[i,j];
    for(int k=1;k<=n;k++){
      //C[tem,k]=diff(B[i,j],z(k));
      C[tem,k]=diff(B[i,j],var(k));
    }
  }
}

matrix D=inverse(C);
module M;
int tem=1;
for(int i=E+1;i<=E+L;i++){
  for(int j=1;j<=E+L;j++){
    
    vector t=0*gen(n+1);
    for(int l=1;l<=n;l++){
      poly a=0;
      for(int k=1;k<=E+L;k++){
        //find the right row correspond to derivative
            int o=0;
            int c1;
            poly c2=0;
            if(i==k){
              c1=2;
            } else {
              c1=1;
            }
            
          for(int r=1;r<=size(x);r++){
            if([i,k]==x[r] or [k,i]==x[r] ){
              o=r;
              
            }
          }

          if(o != 0){
            c2=D[l,o];
          }
          a=a+c1*c2*B[j,k];
      }
    t=t+a*gen(l);
    }
    if(i==j){
      t=t-2*gen(n+1);
    } else {
      t=t+0*gen(n+1);
    }
    M[tem]=t;
    tem=tem+1;
  }
}
//Test the computation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
   // testP=testP+M[j][i]*diff(F,z(i));
    testP=testP+M[j][i]*diff(F,var(i));
    }
  testP=testP+M[j][n+1]*F;
  if(testP != 0){
    print("Something wrong");
  }

}

return(M);
}

example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=makeM1(G1);
}

//////2.2 compute M2

proc makeM2(def G0,list Nu)
"USAGE:  computeM2(G,Nu); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The module M2 over G1.baikovover that requires to compute IBP identities 
KEYWORDS: Feynman graph
"
{
  if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
 // return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0 = G1;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}

labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);

if(size(Nu) != n){
   ERROR("The length of the vector nu must equal to number of Baikov variables");
}

int tem=0;
int E = m;
int L = nvars(R);

module M2;

for(int i=1;i<=n;i++){
  if(Nu[i]>0){
              M2[i]=var(i)*gen(i);
              } else {
                      M2[i]=1*gen(i);
                      }
}
M2[n+1]=1*gen(n+1);
return(M2);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module M2=makeM2(G1,list(1,1,1,0,0,1,0,0,0));
    M2;
}

//////2.3 Make formal IBPs

proc makeFormalIBP(def G0,list sector)
"USAGE:  makeFormalIBP(G0,sector); G0 graph@*,
ASSUME:   G0 is the labelled graph and is the output of makeBaikovMatrix. 
          sector is the list of integers represent a sector of G.
RETURN:  generators of the standard basis of  the module M1 intersect M2.
KEYWORDS: Feynman graph,IBPs
"
{ 
  if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  //return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0=G1;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}

labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);

if (size(sector) > n){
  ERROR("Wrong sector");
}

//setting binary encoding of the sector
list Nu;
for(int i=1;i<=n;i++){
  Nu[i]=0;
}

for(int i=1;i<=size(sector);i++){
  Nu[sector[i]]=1;
}

module M1=makeM1(G);
module M2=makeM2(G,Nu);
timer=0;
option(redSB);
module M=std(intersect(M1,M2));
//module M=intersect(M1,M2);
int elapsed_time=timer;
print("time elapsed for the computation of  module intersection: " + string(elapsed_time));

// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    //testP=testP+M[j][i]*diff(F,z(i));
    testP=testP+M[j][i]*diff(F,var(i));
  }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}

return(M);
}
example{"EXAMPLE:"; echo=2;
  //graph information
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  //include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
  
  labeledgraph G1=makeBaikovMatrix(G2,internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;
  list sector=list(1,2,3); //sector that we are interested
  module M=makeFormalIBP(G1,sector);
  size(M);
}


///** Working over vectors for much faster computations

/// 1.Make IBPs so that the denominator powers as vectors

proc makeIBPVec(def G0,def M12, list setNu)
"USAGE:  computeManyIBP(G0,setNu); G0 graph@*,
ASSUME:  setNu is a list of seed correspond to the graph G0 which are belong to the same sector 
          M12 is the formal IBP of the corresponding sector (output of makeFormalIBP).
RETURN:  setIBP S, where it contains all the IBP relations obtained by module intersection and seeding
KEYWORDS: Feynman graph,IBPs
"
{ 
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0=G1;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
list Nu=setNu[1];
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
//int m=exm;
ring RB=G.baikovover;
//ring RB=bR;
matrix B=G.baikovmatrix;
//matrix B=bM;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);
//int L=inm;
if(size(Nu) != n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}
module M=M12;

// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    //testP=testP+M[j][i]*diff(F,z(i));
    testP=testP+M[j][i]*diff(F,var(i));
  }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}
//

ring Z=RB;
setIBP S;

S.over=Z;
//S.over=RB;

S.seed=Nu;
//setring Z;
//module M=imap(RB,M);
int p=1;
for(int b=1;b<=size(setNu);b++)
{
  list Nu=setNu[b];

  for(int i=1;i<=size(M);i++)
  {
    list y;
    list l;
    
  //computation of polynomial
    poly f=0;
    for(int j=1;j<=n;j++)
    {
     // f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));
     f=f+(diff(M[i][j],var(j))-Nu[j]*M[i][j]/var(j));  
    }
    poly h=(D-L-E-1)/2;
    f=f-M[i][n+1]*h; 
    if(f != 0)
    {
      int t=1;
        while(f != 0)
        {
          y[t]=leadcoef(f);
          list nu;
          vector v;
          for(int k=1;k<=size(Nu);k++)
          {
            nu[k]=Nu[k]-leadexp(f)[k];
            v=v+nu[k]*gen(k);
          }
       // l[t]=nu;
       l[t]=v;
        t=t+1;
        f=f-lead(f);
        }
      oneIBP I;
      I.c=y;
      I.i=l;
      S.IBP[p]=I;
      p=p+1;  
    }

  }
}

return(S);
//return(S.IBP);
}
example{"EXAMPLE:"; echo=2;
  //include graph information
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  //include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
  
  labeledgraph G1=makeBaikovMatrix(G2,internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;

  //Assume the seed belong to the same sector
  list sector=list(1,2,3,4,5,6,7);
  list seeds=list(list(1,1,1,1,1,1,1,0,0));

  module M=makeFormalIBP(G1,sector);
  setIBP S=makeIBPVec(G1,M,seeds);

    oneIBP I=L[1];
    I;
  
}

/// 2.get sorting measures as vectors

proc getSortMeasuresVec(vector l,int x)
"USAGE:   getSortMeasures(l,x); l list, x int; 
ASSUME:   l is a list of integers (i.e a seed) and x is number of Baikov variables. 
RETURN:   a vector of sort measures that are used in Laporta Algorithm
KEYWORDS: Feynman graph
EXAMPLE:  getSortMeasures; shows an example
"
{
 int Nprop=0;
 int   Nid=0;
 int   r=0;
 int   s=0;
 list rv;
 list sv;
 for(int j=1;j<=x;j++){
      Nprop=Nprop+heaviside(int(l[j])-1/2);
        Nid=Nid+heaviside(int(l[j])-1/2)*2^(j-1);
        r=r+int(l[j])*heaviside(int(l[j])-1/2);
        s=s+absValue(int(l[j]))*heaviside(-int(l[j])+1/2);
        //--------
        if(int(l[j])>0){
          rv[size(rv)+1]=int(l[j]);
        }
        else{
          sv[size(sv)+1]=int(l[j]);
        }
        //---------
 }
//return(list(Nprop,Nid,r,s));
list L=list(Nprop,Nid,r,s)+rv+sv;
vector v;
for(int i=1;i<=size(L);i++){
  v=v+L[i]*gen(i);
}
return(v);
}

//check whether a vector is in the list of vectors
proc isInListVec(list l,vector a)
{
int ind=0;
for(int m=1;m <= size(l);m++){
  
  
  if(l[m][1]==a){
    ind++;
  }
          
}
    if(ind==0)
    {
      return(0);
    }
    else
    {
      return(1);
    }
}
//


// lex sort for vector
proc lexSortVec(list L)
{
  int n=size(L);
  for(int i=1;i<n;i++)
  {
    for(int j=1;j <= n-i;j++)
    {
      if(L[j][2]>L[j+1][2])
      {
        list temp=L[j];
        L[j]=L[j+1];
        L[j+1]=temp;
      }
    }
  }
  return(L);
}

//3.get sorted integrals as a vector

proc getSortedIntegralsVec(setIBP I)
"USAGE:  getSortedIntegrals(I); I setIBP,
ASSUME:   
RETURN:  list ind where each entry is a pair (indv,sortmeasures),
          indv is the list of indices(seed) appered in the setIBP 
          and sortmeasures is the output of getSortMeasuresVec(indv,x).
          The function getSortedIntegrals extract the seeds appeared in the IBP identities of the setIBP,
          sort them lexicographically based on the values got from getSortMeasuresVec and return the output.
KEYWORDS: Feynman graph
"
{
  ring RZ=I.over;
  list ind;
  list indS;
  for(int j=1;j<=size(I.IBP);j++)
  {
      oneIBP oneI=I.IBP[j];
      for(int k=1;k <= size(oneI.i);k++)
      {
        vector indv=oneI.i[k];
        if(size(ind)==0){
          ind[size(ind)+1]=list(indv,getSortMeasuresVec(indv,nvars(RZ)));
          
        }
        else
        { 
          if(isInListVec(ind,indv)==0){
              ind[size(ind)+1]=list(indv,getSortMeasuresVec(indv,nvars(RZ)));
              
          }
        }
      }
  }
  

  list indc=lexSortVec(ind);
return(indc);
}
example{"EXAMPLE:"; echo=2;
  //include graph information
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  //include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
  
  labeledgraph G1=makeBaikovMatrix(G2,internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  
  ring RZ=G1.baikovover;
  list sector=list(1,2,3,4,5,6,7);
  list seeds=list(list(1,1,1,1,1,1,1,-4,0),list(1,1,1,1,1,1,1,-1,-3),list(1,1,1,1,1,1,1,-2,-2),list(1,1,1,1,1,1,1,-3,-1),list(1,1,1,1,1,1,1,0,-4));
 
  module M=makeFormalIBP(G1,sector);
  setIBP S=makeIBPVec(G1,M,seeds);
  list L =getSortedIntegralsVec(S);
}

//4.Extract coefficients

proc extractCoefVec(oneIBP I,list ind,list l,list sector)
"USAGE:   extractCoefVec(I,ind,l,sector); I oneIBP,ind list,l list,
ASSUME:   ind is the output of getSortedIntegralsVec, and l is the list of values over the base field I.baikovover. 
          size(l)=npars(I.baikovover)
RETURN:   list of values where, the i-th element is the evaluation of coefficient function  at values in the list l 
          of the IBP relation oneIBP, whose index is i=ind[i][1].
KEYWORDS: feynman graph,IBPs
EXAMPLE:  extractCoefVec; shows an example
"
{ list v;
  vector sect1;
  for(int i=1;i<=size(sector);i++){
    sect1=sect1+sector[i]*gen(i);
  }

  for(int j=1;j <= size(ind);j++){
    int tem=0;
    for(int k=1;k <= size(I.c);k++){
      if(ind[j][1]==I.i[k]){
        v[j]=substituteList(I.c[k],l);

        tem++;
      }

      /// gettng sector of the itegral
      vector sect2;
      for(int w=1;w<=size(ind[j][1]);w++){
        if(int(ind[j][1][w])>0){
          sect2=sect2+w*gen(w);
        }
        else{
          sect2=sect2+0*gen(w);
        }
      }

      if(tem==0 or sect1<>sect2 ){
        v[j]=0;
      }
    }
  } 
  return(v); 
}

//5.Create the matrix using IBPs to determine the independent IBPs

proc makeMatVec(setIBP S,list val,list ind,list sector)
"USAGE:   makeMatVec(S,val,ind,sector); S setIBP,ind list,l list,sector list;
ASSUME:   size(val)=npars(S.over)
RETURN:   matrix,where i-th row correspond to the evaluation of coefficient functions of i-th IBP in setIBP. 
          Columns of the matrix correspond to the all used indices in the setIBP which are ordered with 
          respect to the output ofgetSortMeasures. 
KEYWORDS: feynman graph,IBPs
EXAMPLE:  setMat; shows an example
"
{
  ring RZ=S.over;
 // list ind = getSortedIntegralsVec(S);
  matrix X[size(S.IBP)][size(ind)];
  for(int j=1;j <= size(S.IBP);j++){
    oneIBP L=S.IBP[j];
    list v=extractCoefVec(L,ind,val,sector);
    for(int k=1;k <= size(v);k++){
      X[j,k]=v[k];
      
    }
  //  print("completed IBP= "+string(j));
  }

  return(X);
}
example{"EXAMPLE:"; echo=2;
// include graph information
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  //include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
  
  labeledgraph G1=makeBaikovMatrix(G2,internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  
  ring RZ=G1.baikovover;

  list sector=list(1,2,3,4,5,6,7);
  list seeds=list(list(1,1,1,1,1,1,1,-4,0),list(1,1,1,1,1,1,1,-1,-3),list(1,1,1,1,1,1,1,-2,-2),list(1,1,1,1,1,1,1,-3,-1),list(1,1,1,1,1,1,1,0,-4));
  
  list val=getRandom(93187,npars(RZ));
  
  module M=makeFormalIBP(G1,sector);
  setIBP S=makeIBPVec(G1,M,seeds);
  
  list L =getSortedIntegralsVec(S);
  matrix N=makeMatVec(S,val,L,sector);
}

//6.Get independent IBPs where, the  integrals are in vector form

proc getReducedIBPVec(setIBP S,int p,list sector)
"USAGE:   getRedIBPVec(S,p,sector); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite 
          field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"

{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegralsVec(S);
  int elapsed_time=timer;
  print("Elapsed time to sort integrals involved in seconds:" + string( elapsed_time)); 
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  
  timer=0;
  matrix N=makeMatVec(S,val,ind,sector);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  

  //--set ring RZ
  string param;
  string varz;

  for(int i=1;i<=npars(R)-1;i++){
    string sr;
    for(int j=2;j<=size(string(par(i)))-1;j++){
      sr=sr+string(par(i))[j];
    } 
    if(i == npars(R)-1){
      param=param+sr;
    }
    else{
      param=param+sr+",";
    }
  
  }

  for(int i=1;i<nvars(R);i++){
    varz=varz+string(var(i))+",";
  }
  varz=varz+string(var(nvars(R)));

  //ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  
  ring RZ;
  string cmd="ring RZ = (p,("+param+",D)),("+varz+"),dp";
  execute(cmd);
//--

  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }

  }

  //identify non-zero columns
  //list seed;
  MI mi;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        //seed[l]=ind[k][1];
        mi.masterIntegrals[l]=ind[k][1];
        l++;
        break;
      }
    }

  }

  //return(list(indIBP,seed));
  return(list(indIBP,mi));
}
example
{ "EXAMPLE:"; echo=2;
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  ring R=0,(q1,q2,p1,p2,p4,s,t),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(s,t);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*s,p1*p4,1/2*t,p2*p4,-1/2*(s+t));
  
  labeledgraph G1=makeBaikovMatrix(G2,internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;
  list sector=list(1,2,3,4,5,6,7);
  list seeds=list(list(1,1,1,1,1,1,1,-4,0),list(1,1,1,1,1,1,1,-1,-3),list(1,1,1,1,1,1,1,-2,-2),list(1,1,1,1,1,1,1,-3,-1),list(1,1,1,1,1,1,1,0,-4));
  module M=makeFormalIBP(G1,sector);
  setIBP S=makeIBPVec(G1,M,seeds);

  list L=getReducedIBPVec(S,93187,sector);
  size(L[1])<size(S.IBP);
  ring RS=S.over;
  MI mi=L[2];
  size(mi.masterIntegrals);
  mi;
  //print of reduced IBPs
  for(int i=1;i<=size(L[1]);i++){
    oneIBP I=L[1][i];
    I;
  }
  //print of all IBPs
  for(int i=1;i<=1;i++){
    oneIBP I=S.IBP[i];
    I;
  }
  
}


//7.Get IBPs with Mask. i.e. We exclude the integrals that are not belong to the current sector from IBPs

proc getReleventIBPs(setIBP S,def sector)
"USAGE:   getReleventIBPs(S,sector); 
ASSUME:   S is setIBP. 
RETURN:   setIBP S, where for each IBP, the terms consist of the integrals that are not 
          belong to the given sector are removed (i.e., masking process is imposed).
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getReleventIBPs; shows an example
"
{
  //sector in vector form
  setIBP S1;
  S1.over=S.over;
 vector sect1;
 for(int k=1;k<=nvars(R);k++){
  int a=sector[k];
    sect1=sect1+a*gen(a); 
  }
 ring R=S.over;

  for(int j=1;j <= size(S.IBP);j++){
    oneIBP I=S.IBP[j];
    oneIBP Inew;
    for(int k=1;k <= size(I.i);k++){
      //getting sector of each integral
        vector sect2;
        for(int w=1;w<=nvars(R);w++){
          if(I.i[k][w]>0){
            sect2=sect2+w*gen(w);
          }
          else{
            sect2=sect2+0*gen(w);
          }
          
        }


      
      if((sect2==sect1)==1){
            Inew.c[size(Inew.c)+1]=I.c[k];
        Inew.i[size(Inew.i)+1]=I.i[k];   
      }
     
      
      /// gettng sector of the integral
      
    }
    if(size(Inew.i)<>0){
    //S.IBP[j]=Inew;
      S1.IBP[size(S1.IBP)+1]=Inew;
    }
    
  } 
  return(S1); 
}
example
{ "EXAMPLE:"; echo=2;
//include graph information
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

//include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,s,t),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(s,t);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*s,p1*p4,1/2*t,p2*p4,-1/2*(s+t));
  
  labeledgraph G1=makeBaikovMatrix(G2,internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;
  list sector=list(1,2,3,4,5,6,7);
  list seeds=list(list(1,1,1,1,1,1,1,-4,0),list(1,1,1,1,1,1,1,-1,-3),list(1,1,1,1,1,1,1,-2,-2),list(1,1,1,1,1,1,1,-3,-1),list(1,1,1,1,1,1,1,0,-4));
  
  
  module M=makeFormalIBP(G1,sector);
  
  setIBP S=makeIBPVec(G1,M,seeds);
  setIBP S1=getReleventIBPs(S,sector);

  oneIBP I = S1.IBP[1];
  I;
  
}

//8. Convert IBPs to the nice format

proc getProperIBPs(int nv, list L)
"USAGE:   getProperIBPs(nv,L); 
ASSUME:   L is a list of IBPs and nv is number of Baikov variables. 
RETURN:   a list of IBPs where the indeces of integrals (in vector format) in IBPs are converted to lists.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getProperIBP; shows an example
"
{ list Lnew;
  for(int j=1; j<=size(L);j++){
    oneIBP I=L[j];
    oneIBP Inew;
    
    for(int k=1;k<=size(I.i);k++){
      //make denominator powers as a list
      list indl;
      for(int l=1;l<=nv;l++){
        indl[size(indl)+1]=I.i[k][l];
      }
      Inew.i[k]=indl;
      Inew.c[k]=I.c[k];
      

    }
    Lnew[size(Lnew)+1]=Inew;
  }
return(Lnew);
}

//9.Genetate independent IBPs respecting the steps

proc getReducedIBPwithMask(def G1,def M,int p,list sector)
"USAGE:   getReducedIBPwithMask(G1,M,p,sector); 
ASSUME:   G is a graph, M is the output of the function makeFormalIBP, p is a prime number and sector 
          is a list. 
RETURN:   a list where the entry i contain the list of independent IBPs correspond to step i-1. Here we 
          consider steps upto 4.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getReducedIBPwithMask; shows an example
"
{
  labeledgraph G=G1;
 
  list Lcom;
  int bde=0;
  for(int i=1;i<=size(G.edges);i++){
    if(size(G.edges[i])==2){
      bde=bde+1;
    }
  }
  //list targetInt=list(1,1,1,1,1,1,1,0,0);
  list targetInt;
  for(int i=1;i<=nvars(G.baikovover);i++){
    targetInt[i]=0;
  }
  for(int i=1;i<=size(sector);i++){
    targetInt[sector[i]]=1;
  }
  
   ring R=G.baikovover;
  //Following the steps, we generate seeds
  
  for(int step=0;step<=4;step++){

    list negatindex=partitions(nvars(R)-bde,step);
    list seeds;
    for(int i=1;i<=size(negatindex);i++){
      list oneseed=getSector(targetInt)[1];
      for(int j=bde+1;j<=nvars(R);j++){
        oneseed[j]=-negatindex[i][j-bde];
      }
      seeds[size(seeds)+1]=oneseed;
    }
  
    setIBP S=makeIBPVec(G1,M,seeds);
    setIBP S1=getReleventIBPs(S,sector);
    list L=getReducedIBPVec(S1,p,sector);
    Lcom[size(Lcom)+1]=getProperIBPs(9,L[1]);
    //Lcom[size(Lcom)+1]=S1.IBP;
    print("Completed step :"+string(step));
  }
  
  return(Lcom);
  }
  example
{ "EXAMPLE:"; echo=2;
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  ring R=0,(q1,q2,p1,p2,p4,s,t),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(s,t);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*s,p1*p4,1/2*t,p2*p4,-1/2*(s+t));
  
  labeledgraph G1=makeBaikovMatrix(G2,internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;
  list sector=list(1,2,3,4,5,6,7);
  module M=makeFormalIBP(G1,sector);
  list  Lprop=getReducedIBPwithMask(G1,M,93187,sector);  
  //One can print the independent IBPs with mask correspond to step 0.
   for(int j=1;j<=size(Lprop[1]);j++){
    oneIBP I=Lprop[1][j];
    if(size(I.i)<>0){
      print(I);
    }
   } 
  
}

//10.Genetate  IBPs (before reduction) respecting the steps

proc getIBPwithMask(def G1,def M,int p,list sector)
"USAGE:   getIBPwithMask(G1,M,p,sector); 
ASSUME:   G is a graph, M is the output of the function makeFormalIBP, p is a prime number and sector
           is a list. 
RETURN:   a list where the entry i contain the list of IBPs correspond to step i-1. Here we consider 
          steps upto 4.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getReducedIBPwithMask; shows an example
"
{
  labeledgraph G=G1;
  
  list Lcom;
  int bde=0;
  for(int i=1;i<=size(G.edges);i++){
    if(size(G.edges[i])==2){
      bde=bde+1;
    }
  }
  //list targetInt=list(1,1,1,1,1,1,1,0,0);
  
  list targetInt;
  for(int i=1;i<=nvars(G.baikovover);i++){
    targetInt[i]=0;
  }
  for(int i=1;i<=size(sector);i++){
    targetInt[sector[i]]=1;
  }
  
  //Following the steps, we generate seeds
  ring R=G.baikovover;

  for(int step=0;step<=4;step++){
    print("Started step :"+string(step));
    list negatindex=partitions(nvars(R)-bde,step);
    list seeds;
    for(int i=1;i<=size(negatindex);i++){
      list oneseed=getSector(targetInt)[1];
      for(int j=bde+1;j<=nvars(R);j++){
        oneseed[j]=-negatindex[i][j-bde];
      }
      seeds[size(seeds)+1]=oneseed;
    }
  
    
    setIBP S=makeIBPVec(G1,M,seeds);
    setIBP S1=getReleventIBPs(S,sector);
   
    Lcom[size(Lcom)+1]=getProperIBPs(9,S1.IBP);
    print("Completed step :"+string(step));
  }
  
 return(Lcom);
  }

 example
{ "EXAMPLE:"; echo=2;
  //include graph information
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  ////include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,s,t),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(s,t);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*s,p1*p4,1/2*t,p2*p4,-1/2*(s+t));
  
  labeledgraph G1=makeBaikovMatrix(G2,internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;
  list sector=list(1,2,3,4,5,6,7);
  module M=makeFormalIBP(G1,sector);
  list Lprop=getIBPwithMask(G1,M,93187,sector);  

  //One can use the following to print the IBPs with mask correspond to step 0
   for(int j=1;j<=size(Lprop[1]);j++){
    oneIBP I=Lprop[1][j];
   
      print(I);
    
   } 
  
}

//////////////////////////////////
// Remove Graph from everything///
/////////////////////////////////

////1. Make Baikov matrix

proc makeBaikovMatrix1(list internalmomenta,list externalmomenta,list mandelsonvars,list propagat,list replacementRules)
"USAGE:  makeBaikovMatrix(G,internalmomenta,externalmomenta, mandelsonvars, propagat, replacementRules); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
RETURN:  a labeled graph G1, computes the Baikov matrix of G defined in G1.baikovover and stores it in G1.baikovmatrix
KEYWORDS: Feynman graph
EXAMPLE:  removeElimVars G; shows an example
"
{

labeledgraph G1;
ideal PI;
//set ideal PI;
for(int i=1;i<=size(propagat);i++){
  PI[size(PI)+1]=propagat[i];
}

//applying replacements for external momenta
ideal infedges;
list pq;
list pqt;
list pqp;
int idx=1;
for(int i=1;i<=size(replacementRules) div 2;i++){
  pqp[size(pqp)+1]=replacementRules[2*i-1];
  pqt[size(pqt)+1]=replacementRules[2*i];
if(replacementRules[2*i]==0){
  infedges[size(infedges)+1]=replacementRules[2*i-1]-replacementRules[2*i];

}
else{
  pq[size(pq)+1]=replacementRules[2*i];
  PI[size(PI)+1]=replacementRules[2*i-1];
  
}
}

if(size(infedges)!=size(externalmomenta)){
ERROR("This is not the situation that we considered in this package. for any external momenta p, it should hold p^2=0.");
}

 PI=reduce(PI,std(infedges));

  ideal gram;
  int ine=size(externalmomenta);
  int bde=size(internalmomenta);
  list labls=externalmomenta;
  for(int i=1;i<=size(internalmomenta);i++){
    labls[size(labls)+1]=internalmomenta[i];
  }

  for (int i = 1;i<=ine+bde;i++){
    for (int j = 1;j<=ine+bde;j++){
          if(i<=ine and j<=ine){
            gram[idx]=0;
          }
          else{
            gram[idx] = labls[i]*labls[j];
          }
      idx++;
    }
  }

//-----------------------------
gram=reduce(gram,std(infedges));

  matrix A = lift(PI,gram);
  int mt=size(mandelsonvars);
  matrix B[bde+ine][bde+ine];
  int idx=1;
  poly sumt;
  for (i=1; i<=bde+ine;i++){
    for (j=i+1; j<=bde+ine;j++){

      for(int k=1;k<=size(pqp);k++){
        if(labls[i]*labls[j]==pqp[k] or labls[j]*labls[i]==pqp[k]){
          B[i,j]=pqt[k];
        }
      }
      if(B[i,j]<>0){
        B[j,i]=B[i,j];
      }
      
  
    }
  }
  //set ring baikov over

  int sizeProp=size(propagat);
  int sizePq=size(pq);
  string parat=string(mandelsonvars);
  string zi;
 
  for(int i=1;i<=size(propagat)-1;i++){
  zi=zi+"z"+string(i)+",";
  }
  zi=zi+"z"+string(size(propagat));
 
  ring Z;
  string cmd="ring Z = (0,("+parat+",D)),("+zi+"),dp";
  execute(cmd);
  setring Z;
  list zl;
  for(int i=1;i<=nvars(Z);i++){
    zl[size(zl)+1]=var(i);
  }
  matrix B=imap(R,B);
  list pq=imap(R,pq);
  matrix zvars[1][sizeProp+sizePq] = zl[1..size(zl)],pq[1..sizePq];
  matrix A = imap(R,A);
  matrix Bentries = zvars * A;
  matrix B1[bde+ine][bde+ine] = Bentries[1,1..ncols(Bentries)];
  B=B+B1;
  printMat(B);
  
  G1.elimvars=list();
  G1.baikovover=Z;
  G1.baikovmatrix=B;
  return(G1);
  
}
example
{ "EXAMPLE:"; echo=2;
  
  //include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
  
  //compute Baikov matrix
  labeledgraph G1=makeBaikovMatrix1(internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
}

//// 2. generate IBP relations
//////2.1 compute M1
proc makeM11(def G0,int m, int L)
"USAGE:  makeM1(G0); G labeledgraph, or G graph@*
ASSUME:  G0 is a Graph, or@*
         G0 is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
RETURN:  The module M1 over G1.baikovover that requires to compute IBP identities 
KEYWORDS: Feynman graph
"

{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
 // return(computeM1(G1));
 kill G0;
 labeledgraph G0=G1;
 
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
//def R = G.over;
//int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
matrix C[n][n];
int tem=0;
int E = m;
//int L = nvars(R);
list x;
for(int i=1;i<=E;i++){
  for(int j=E+1;j<=E+L;j++){ 
    tem=tem+1;
    x[tem]=[i,j];   
    for(int k=1;k<=n;k++){
      //C[tem,k]=diff(B[i,j],z(k));
      C[tem,k]=diff(B[i,j],var(k));
    }
  }
}
for(int i=E+1;i<=E+L;i++){
  for(int j=i;j<=E+L;j++){ 
    tem=tem+1;   
    x[tem]=[i,j];
    for(int k=1;k<=n;k++){
      //C[tem,k]=diff(B[i,j],z(k));
      C[tem,k]=diff(B[i,j],var(k));
    }
  }
}

matrix D=inverse(C);
module M;
int tem=1;
for(int i=E+1;i<=E+L;i++){
  for(int j=1;j<=E+L;j++){
    
    vector t=0*gen(n+1);
    for(int l=1;l<=n;l++){
      poly a=0;
      for(int k=1;k<=E+L;k++){
        //find the right row correspond to derivative
            int o=0;
            int c1;
            poly c2=0;
            if(i==k){
              c1=2;
            } else {
              c1=1;
            }
            
          for(int r=1;r<=size(x);r++){
            if([i,k]==x[r] or [k,i]==x[r] ){
              o=r;
              
            }
          }

          if(o != 0){
            c2=D[l,o];
          }
          a=a+c1*c2*B[j,k];
      }
    t=t+a*gen(l);
    }
    if(i==j){
      t=t-2*gen(n+1);
    } else {
      t=t+0*gen(n+1);
    }
    M[tem]=t;
    tem=tem+1;
  }
}
//Test the computation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
   // testP=testP+M[j][i]*diff(F,z(i));
    testP=testP+M[j][i]*diff(F,var(i));
    }
  testP=testP+M[j][n+1]*F;
  if(testP != 0){
    print("Something wrong");
  }

}

return(M);
}

example
{ "EXAMPLE:"; echo=2;
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
  int m=size(externalmomenta);
  int L=size(internalmomenta);
  labeledgraph G1=makeBaikovMatrix1(internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
    ring RB=G1.baikovover;
    RB;
    module ML=makeM11(G1,m,L);
    ML;
}

//////2.2 compute M2

proc makeM21(def G0,list Nu)
"USAGE:  computeM2(G,Nu); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The module M2 over G1.baikovover that requires to compute IBP identities 
KEYWORDS: Feynman graph
"
{
  if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
 // return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0 = G1;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}

labeledgraph G = G0;
//def R = G.over;
//int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);

if(size(Nu) != n){
   ERROR("The length of the vector nu must equal to number of Baikov variables");
}

int tem=0;
//int E = m;
//int L = nvars(R);

module M2;

for(int i=1;i<=n;i++){
  if(Nu[i]>0){
              M2[i]=var(i)*gen(i);
              } else {
                      M2[i]=1*gen(i);
                      }
}
M2[n+1]=1*gen(n+1);
return(M2);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
  int m=size(externalmomenta);
  int L=size(internalmomenta);
  labeledgraph G1=makeBaikovMatrix1(internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
    ring RB=G1.baikovover;
    RB;
    module M2=makeM21(G1,list(1,1,1,0,0,1,0,0,0));
    M2;
}

//////2.3 Make formal IBPs

proc makeFormalIBP1(def G0,list sector,int m, int L)
"USAGE:  makeFormalIBP(G0,sector); G0 graph@*,
ASSUME:   G0 is the labelled graph and is the output of makeBaikovMatrix. 
          sector is the list of integers represent a sector of G.
RETURN:  generators of the standard basis of  the module M1 intersect M2.
KEYWORDS: Feynman graph,IBPs
"
{ 
  if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  //return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0=G1;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}

labeledgraph G = G0;
//def R = G.over;
//int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
//int E = m;
//int L = nvars(R);

if (size(sector) > n){
  ERROR("Wrong sector");
}

//setting binary encoding of the sector
list Nu;
for(int i=1;i<=n;i++){
  Nu[i]=0;
}

for(int i=1;i<=size(sector);i++){
  Nu[sector[i]]=1;
}

module M1=makeM11(G,m,L);
module M2=makeM21(G,Nu);
timer=0;
option(redSB);
module M=std(intersect(M1,M2));
//module M=intersect(M1,M2);
int elapsed_time=timer;
print("time elapsed for the computation of  module intersection: " + string(elapsed_time));

// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    //testP=testP+M[j][i]*diff(F,z(i));
    testP=testP+M[j][i]*diff(F,var(i));
  }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}

return(M);
}
example{"EXAMPLE:"; echo=2;
  
  //include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
  int m=size(externalmomenta);
  int L=size(internalmomenta);
  labeledgraph G1=makeBaikovMatrix1(internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;
  list sector=list(1,2,3); //sector that we are interested
  module M=makeFormalIBP1(G1,sector,m,L);
  size(M);
}


///** Working over vectors for much faster computations

/// 1.Make IBPs so that the denominator powers as vectors

proc makeIBPVec1(def G0,def M12, list setNu,int m,int L)
"USAGE:  computeManyIBP(G0,setNu); G0 graph@*,
ASSUME:  setNu is a list of seed correspond to the graph G0 which are belong to the same sector 
          M12 is the formal IBP of the corresponding sector (output of makeFormalIBP).
RETURN:  setIBP S, where it contains all the IBP relations obtained by module intersection and seeding
KEYWORDS: Feynman graph,IBPs
"
{ 
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0=G1;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
list Nu=setNu[1];
labeledgraph G = G0;
//def R = G.over;
//int m=npars(R);
//int m=exm;
ring RB=G.baikovover;
//ring RB=bR;
matrix B=G.baikovmatrix;
//matrix B=bM;
setring RB;
int n=nvars(RB);
int E = m;
//int L = nvars(R);
//int L=inm;
if(size(Nu) != n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}
module M=M12;

// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    //testP=testP+M[j][i]*diff(F,z(i));
    testP=testP+M[j][i]*diff(F,var(i));
  }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}
//

ring Z=RB;
setIBP S;

S.over=Z;
//S.over=RB;

S.seed=Nu;
//setring Z;
//module M=imap(RB,M);
int p=1;
for(int b=1;b<=size(setNu);b++)
{
  list Nu=setNu[b];

  for(int i=1;i<=size(M);i++)
  {
    list y;
    list l;
    
  //computation of polynomial
    poly f=0;
    for(int j=1;j<=n;j++)
    {
     // f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));
     f=f+(diff(M[i][j],var(j))-Nu[j]*M[i][j]/var(j));  
    }
    poly h=(D-L-E-1)/2;
    f=f-M[i][n+1]*h; 
    if(f != 0)
    {
      int t=1;
        while(f != 0)
        {
          y[t]=leadcoef(f);
          list nu;
          vector v;
          for(int k=1;k<=size(Nu);k++)
          {
            nu[k]=Nu[k]-leadexp(f)[k];
            v=v+nu[k]*gen(k);
          }
       // l[t]=nu;
       l[t]=v;
        t=t+1;
        f=f-lead(f);
        }
      oneIBP I;
      I.c=y;
      I.i=l;
      S.IBP[p]=I;
      p=p+1;  
    }

  }
}

return(S);
//return(S.IBP);
}
example{"EXAMPLE:"; echo=2;
  
  //include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
  int m=size(externalmomenta);
  int L=size(internalmomenta);
  labeledgraph G1=makeBaikovMatrix1(internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;
  //Assume the seed belong to the same sector
  list sector=list(1,2,3,4,5,6,7);
  list seeds=list(list(1,1,1,1,1,1,1,0,0));

  module M=makeFormalIBP1(G1,sector,m,L);
  setIBP S=makeIBPVec1(G1,M,seeds,m,L);

    oneIBP I=S.IBP[1];
    I;
  
}

/// 2.get sorting measures as vectors

proc getSortMeasuresVec(vector l,int x)
"USAGE:   getSortMeasures(l,x); l list, x int; 
ASSUME:   l is a list of integers (i.e a seed) and x is number of Baikov variables. 
RETURN:   a vector of sort measures that are used in Laporta Algorithm
KEYWORDS: Feynman graph
EXAMPLE:  getSortMeasures; shows an example
"
{
 int Nprop=0;
 int   Nid=0;
 int   r=0;
 int   s=0;
 list rv;
 list sv;
 for(int j=1;j<=x;j++){
      Nprop=Nprop+heaviside(int(l[j])-1/2);
        Nid=Nid+heaviside(int(l[j])-1/2)*2^(j-1);
        r=r+int(l[j])*heaviside(int(l[j])-1/2);
        s=s+absValue(int(l[j]))*heaviside(-int(l[j])+1/2);
        //--------
        if(int(l[j])>0){
          rv[size(rv)+1]=int(l[j]);
        }
        else{
          sv[size(sv)+1]=int(l[j]);
        }
        //---------
 }
//return(list(Nprop,Nid,r,s));
list L=list(Nprop,Nid,r,s)+rv+sv;
vector v;
for(int i=1;i<=size(L);i++){
  v=v+L[i]*gen(i);
}
return(v);
}

//check whether a vector is in the list of vectors
proc isInListVec(list l,vector a)
{
int ind=0;
for(int m=1;m <= size(l);m++){
  
  
  if(l[m][1]==a){
    ind++;
  }
          
}
    if(ind==0)
    {
      return(0);
    }
    else
    {
      return(1);
    }
}
//


// lex sort for vector
proc lexSortVec(list L)
{
  int n=size(L);
  for(int i=1;i<n;i++)
  {
    for(int j=1;j <= n-i;j++)
    {
      if(L[j][2]>L[j+1][2])
      {
        list temp=L[j];
        L[j]=L[j+1];
        L[j+1]=temp;
      }
    }
  }
  return(L);
}

//3.get sorted integrals as a vector

proc getSortedIntegralsVec(setIBP I)
"USAGE:  getSortedIntegrals(I); I setIBP,
ASSUME:   
RETURN:  list ind where each entry is a pair (indv,sortmeasures),
          indv is the list of indices(seed) appered in the setIBP 
          and sortmeasures is the output of getSortMeasuresVec(indv,x).
          The function getSortedIntegrals extract the seeds appeared in the IBP identities of the setIBP,
          sort them lexicographically based on the values got from getSortMeasuresVec and return the output.
KEYWORDS: Feynman graph
"
{
  ring RZ=I.over;
  list ind;
  list indS;
  for(int j=1;j<=size(I.IBP);j++)
  {
      oneIBP oneI=I.IBP[j];
      for(int k=1;k <= size(oneI.i);k++)
      {
        vector indv=oneI.i[k];
        if(size(ind)==0){
          ind[size(ind)+1]=list(indv,getSortMeasuresVec(indv,nvars(RZ)));
          
        }
        else
        { 
          if(isInListVec(ind,indv)==0){
              ind[size(ind)+1]=list(indv,getSortMeasuresVec(indv,nvars(RZ)));
              
          }
        }
      }
  }
  

  list indc=lexSortVec(ind);
return(indc);
}
example{"EXAMPLE:"; echo=2;
   //include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
   int m=size(externalmomenta);
  int L=size(internalmomenta);
  labeledgraph G1=makeBaikovMatrix1(internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
 
  ring RZ=G1.baikovover;
  list sector=list(1,2,3,4,5,6,7);
  list seeds=list(list(1,1,1,1,1,1,1,-4,0),list(1,1,1,1,1,1,1,-1,-3),list(1,1,1,1,1,1,1,-2,-2),list(1,1,1,1,1,1,1,-3,-1),list(1,1,1,1,1,1,1,0,-4));
 
  module M=makeFormalIBP1(G1,sector,m,L);
  setIBP S=makeIBPVec1(G1,M,seeds,m,L);
  list L =getSortedIntegralsVec(S);
}

//4.Extract coefficients

proc extractCoefVec(oneIBP I,list ind,list l,list sector)
"USAGE:   extractCoefVec(I,ind,l,sector); I oneIBP,ind list,l list,
ASSUME:   ind is the output of getSortedIntegralsVec, and l is the list of values over the base field I.baikovover. 
          size(l)=npars(I.baikovover)
RETURN:   list of values where, the i-th element is the evaluation of coefficient function  at values in the list l 
          of the IBP relation oneIBP, whose index is i=ind[i][1].
KEYWORDS: feynman graph,IBPs
EXAMPLE:  extractCoefVec; shows an example
"
{ list v;
  vector sect1;
  for(int i=1;i<=size(sector);i++){
    sect1=sect1+sector[i]*gen(i);
  }

  for(int j=1;j <= size(ind);j++){
    int tem=0;
    for(int k=1;k <= size(I.c);k++){
      if(ind[j][1]==I.i[k]){
        v[j]=substituteList(I.c[k],l);

        tem++;
      }

      /// gettng sector of the itegral
      vector sect2;
      for(int w=1;w<=size(ind[j][1]);w++){
        if(int(ind[j][1][w])>0){
          sect2=sect2+w*gen(w);
        }
        else{
          sect2=sect2+0*gen(w);
        }
      }

      if(tem==0 or sect1<>sect2 ){
        v[j]=0;
      }
    }
  } 
  return(v); 
}

//5.Create the matrix using IBPs to determine the independent IBPs

proc makeMatVec(setIBP S,list val,list ind,list sector)
"USAGE:   makeMatVec(S,val,ind,sector); S setIBP,ind list,l list,sector list;
ASSUME:   size(val)=npars(S.over)
RETURN:   matrix,where i-th row correspond to the evaluation of coefficient functions of i-th IBP in setIBP. 
          Columns of the matrix correspond to the all used indices in the setIBP which are ordered with 
          respect to the output ofgetSortMeasures. 
KEYWORDS: feynman graph,IBPs
EXAMPLE:  setMat; shows an example
"
{
  ring RZ=S.over;
 // list ind = getSortedIntegralsVec(S);
  matrix X[size(S.IBP)][size(ind)];
  for(int j=1;j <= size(S.IBP);j++){
    oneIBP L=S.IBP[j];
    list v=extractCoefVec(L,ind,val,sector);
    for(int k=1;k <= size(v);k++){
      X[j,k]=v[k];
      
    }
  //  print("completed IBP= "+string(j));
  }

  return(X);
}
example{"EXAMPLE:"; echo=2;
// include graph information
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  //include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,t1,t2),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(t1,t2);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*t1,p1*p4,1/2*t2,p2*p4,-1/2*(t1+t2));
   int m=size(externalmomenta);
  int L=size(internalmomenta);
  labeledgraph G1=makeBaikovMatrix1(internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  
  ring RZ=G1.baikovover;

  list sector=list(1,2,3,4,5,6,7);
  list seeds=list(list(1,1,1,1,1,1,1,-4,0),list(1,1,1,1,1,1,1,-1,-3),list(1,1,1,1,1,1,1,-2,-2),list(1,1,1,1,1,1,1,-3,-1),list(1,1,1,1,1,1,1,0,-4));
  
  list val=getRandom(93187,npars(RZ));
  
  module M=makeFormalIBP1(G1,sector,m,L);
  setIBP S=makeIBPVec1(G1,M,seeds,m,L);
  
  list LL =getSortedIntegralsVec(S);
  matrix N=makeMatVec(S,val,LL,sector);
}

//6.Get independent IBPs where, the  integrals are in vector form

proc getReducedIBPVec(setIBP S,int p,list sector)
"USAGE:   getRedIBPVec(S,p,sector); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite 
          field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"

{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegralsVec(S);
  int elapsed_time=timer;
  print("Elapsed time to sort integrals involved in seconds:" + string( elapsed_time)); 
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  
  timer=0;
  matrix N=makeMatVec(S,val,ind,sector);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  

  //--set ring RZ
  string param;
  string varz;

  for(int i=1;i<=npars(R)-1;i++){
    string sr;
    for(int j=2;j<=size(string(par(i)))-1;j++){
      sr=sr+string(par(i))[j];
    } 
    if(i == npars(R)-1){
      param=param+sr;
    }
    else{
      param=param+sr+",";
    }
  
  }

  for(int i=1;i<nvars(R);i++){
    varz=varz+string(var(i))+",";
  }
  varz=varz+string(var(nvars(R)));

  //ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  
  ring RZ;
  string cmd="ring RZ = (p,("+param+",D)),("+varz+"),dp";
  execute(cmd);
//--

  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }

  }

  //identify non-zero columns
  //list seed;
  MI mi;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        //seed[l]=ind[k][1];
        mi.masterIntegrals[l]=ind[k][1];
        l++;
        break;
      }
    }

  }

  //return(list(indIBP,seed));
  return(list(indIBP,mi));
}
example
{ "EXAMPLE:"; echo=2;
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  ring R=0,(q1,q2,p1,p2,p4,s,t),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(s,t);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*s,p1*p4,1/2*t,p2*p4,-1/2*(s+t));
   int m=size(externalmomenta);
  int L=size(internalmomenta);
  labeledgraph G1=makeBaikovMatrix1(internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;
  list sector=list(1,2,3,4,5,6,7);
  list seeds=list(list(1,1,1,1,1,1,1,-4,0),list(1,1,1,1,1,1,1,-1,-3),list(1,1,1,1,1,1,1,-2,-2),list(1,1,1,1,1,1,1,-3,-1),list(1,1,1,1,1,1,1,0,-4));
  module M=makeFormalIBP1(G1,sector,m,L);
  setIBP S=makeIBPVec1(G1,M,seeds,m,L);

  list L=getReducedIBPVec(S,93187,sector);
  size(L[1])<size(S.IBP);
  ring RS=S.over;
  MI mi=L[2];
  size(mi.masterIntegrals);
  mi;
  //print of reduced IBPs
  for(int i=1;i<=size(L[1]);i++){
    oneIBP I=L[1][i];
    I;
  }
  //print of all IBPs
  for(int i=1;i<=1;i++){
    oneIBP I=S.IBP[i];
    I;
  }
  
}


//7.Get IBPs with Mask. i.e. We exclude the integrals that are not belong to the current sector from IBPs

proc getReleventIBPs(setIBP S,def sector)
"USAGE:   getReleventIBPs(S,sector); 
ASSUME:   S is setIBP. 
RETURN:   setIBP S, where for each IBP, the terms consist of the integrals that are not 
          belong to the given sector are removed (i.e., masking process is imposed).
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getReleventIBPs; shows an example
"
{
  //sector in vector form
  setIBP S1;
  S1.over=S.over;
 vector sect1;
 for(int k=1;k<=nvars(R);k++){
  int a=sector[k];
    sect1=sect1+a*gen(a); 
  }
 ring R=S.over;

  for(int j=1;j <= size(S.IBP);j++){
    oneIBP I=S.IBP[j];
    oneIBP Inew;
    for(int k=1;k <= size(I.i);k++){
      //getting sector of each integral
        vector sect2;
        for(int w=1;w<=nvars(R);w++){
          if(I.i[k][w]>0){
            sect2=sect2+w*gen(w);
          }
          else{
            sect2=sect2+0*gen(w);
          }
          
        }


      
      if((sect2==sect1)==1){
            Inew.c[size(Inew.c)+1]=I.c[k];
        Inew.i[size(Inew.i)+1]=I.i[k];   
      }
     
      
      /// gettng sector of the integral
      
    }
    if(size(Inew.i)<>0){
    //S.IBP[j]=Inew;
      S1.IBP[size(S1.IBP)+1]=Inew;
    }
    
  } 
  return(S1); 
}
example
{ "EXAMPLE:"; echo=2;


//include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,s,t),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(s,t);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*s,p1*p4,1/2*t,p2*p4,-1/2*(s+t));
   int m=size(externalmomenta);
  int L=size(internalmomenta);
  labeledgraph G1=makeBaikovMatrix1(internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;
  list sector=list(1,2,3,4,5,6,7);
  list seeds=list(list(1,1,1,1,1,1,1,-4,0),list(1,1,1,1,1,1,1,-1,-3),list(1,1,1,1,1,1,1,-2,-2),list(1,1,1,1,1,1,1,-3,-1),list(1,1,1,1,1,1,1,0,-4));
  
  
  module M=makeFormalIBP1(G1,sector,m,L);
  
  setIBP S=makeIBPVec1(G1,M,seeds,m,L);
  setIBP S1=getReleventIBPs(S,sector);
   list LL=getReducedIBPVec(S1,93187,sector);

  oneIBP I = S1.IBP[1];
  I;
  
}

//8. Convert IBPs to the nice format

proc getProperIBPs(int nv, list L)
"USAGE:   getProperIBPs(nv,L); 
ASSUME:   L is a list of IBPs and nv is number of Baikov variables. 
RETURN:   a list of IBPs where the indeces of integrals (in vector format) in IBPs are converted to lists.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getProperIBP; shows an example
"
{ list Lnew;
  for(int j=1; j<=size(L);j++){
    oneIBP I=L[j];
    oneIBP Inew;
    
    for(int k=1;k<=size(I.i);k++){
      //make denominator powers as a list
      list indl;
      for(int l=1;l<=nv;l++){
        indl[size(indl)+1]=I.i[k][l];
      }
      Inew.i[k]=indl;
      Inew.c[k]=I.c[k];
      

    }
    Lnew[size(Lnew)+1]=Inew;
  }
return(Lnew);
}

//9.Genetate independent IBPs respecting the steps

proc getReducedIBPwithMask(def G1,def M,int p,list sector)
"USAGE:   getReducedIBPwithMask(G1,M,p,sector); 
ASSUME:   G is a graph, M is the output of the function makeFormalIBP, p is a prime number and sector 
          is a list. 
RETURN:   a list where the entry i contain the list of independent IBPs correspond to step i-1. Here we 
          consider steps upto 4.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getReducedIBPwithMask; shows an example
"
{
  labeledgraph G=G1;
 
  list Lcom;
  int bde=0;
  for(int i=1;i<=size(G.edges);i++){
    if(size(G.edges[i])==2){
      bde=bde+1;
    }
  }
  //list targetInt=list(1,1,1,1,1,1,1,0,0);
  list targetInt;
  for(int i=1;i<=nvars(G.baikovover);i++){
    targetInt[i]=0;
  }
  for(int i=1;i<=size(sector);i++){
    targetInt[sector[i]]=1;
  }
  
   ring R=G.baikovover;
  //Following the steps, we generate seeds
  
  for(int step=0;step<=4;step++){

    list negatindex=partitions(nvars(R)-bde,step);
    list seeds;
    for(int i=1;i<=size(negatindex);i++){
      list oneseed=getSector(targetInt)[1];
      for(int j=bde+1;j<=nvars(R);j++){
        oneseed[j]=-negatindex[i][j-bde];
      }
      seeds[size(seeds)+1]=oneseed;
    }
  
    setIBP S=makeIBPVec(G1,M,seeds);
    setIBP S1=getReleventIBPs(S,sector);
    list L=getReducedIBPVec(S1,p,sector);
    Lcom[size(Lcom)+1]=getProperIBPs(9,L[1]);
    //Lcom[size(Lcom)+1]=S1.IBP;
    print("Completed step :"+string(step));
  }
  
  return(Lcom);
  }
  example
{ "EXAMPLE:"; echo=2;
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  ring R=0,(q1,q2,p1,p2,p4,s,t),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(s,t);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*s,p1*p4,1/2*t,p2*p4,-1/2*(s+t));
  
  labeledgraph G1=makeBaikovMatrix(G2,internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;
  list sector=list(1,2,3,4,5,6,7);
  module M=makeFormalIBP(G1,sector);
  list  Lprop=getReducedIBPwithMask(G1,M,93187,sector);  
  //One can print the independent IBPs with mask correspond to step 0.
   for(int j=1;j<=size(Lprop[1]);j++){
    oneIBP I=Lprop[1][j];
    if(size(I.i)<>0){
      print(I);
    }
   } 
  
}

//10.Genetate  IBPs (before reduction) respecting the steps

proc getIBPwithMask(def G1,def M,int p,list sector)
"USAGE:   getIBPwithMask(G1,M,p,sector); 
ASSUME:   G is a graph, M is the output of the function makeFormalIBP, p is a prime number and sector
           is a list. 
RETURN:   a list where the entry i contain the list of IBPs correspond to step i-1. Here we consider 
          steps upto 4.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getReducedIBPwithMask; shows an example
"
{
  labeledgraph G=G1;
  
  list Lcom;
  int bde=0;
  for(int i=1;i<=size(G.edges);i++){
    if(size(G.edges[i])==2){
      bde=bde+1;
    }
  }
  //list targetInt=list(1,1,1,1,1,1,1,0,0);
  
  list targetInt;
  for(int i=1;i<=nvars(G.baikovover);i++){
    targetInt[i]=0;
  }
  for(int i=1;i<=size(sector);i++){
    targetInt[sector[i]]=1;
  }
  
  //Following the steps, we generate seeds
  ring R=G.baikovover;

  for(int step=0;step<=4;step++){
    print("Started step :"+string(step));
    list negatindex=partitions(nvars(R)-bde,step);
    list seeds;
    for(int i=1;i<=size(negatindex);i++){
      list oneseed=getSector(targetInt)[1];
      for(int j=bde+1;j<=nvars(R);j++){
        oneseed[j]=-negatindex[i][j-bde];
      }
      seeds[size(seeds)+1]=oneseed;
    }
  
    
    setIBP S=makeIBPVec(G1,M,seeds);
    setIBP S1=getReleventIBPs(S,sector);
   
    Lcom[size(Lcom)+1]=getProperIBPs(9,S1.IBP);
    print("Completed step :"+string(step));
  }
  
 return(Lcom);
  }

 example
{ "EXAMPLE:"; echo=2;
  //include graph information
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);

  ////include user specified propagators, replacement rules etc.
  ring R=0,(q1,q2,p1,p2,p4,s,t),dp;
  list internalmomenta=list(q1,q2);
  list externalmomenta=list(p1,p2,p4);
  list mandelsonvars=list(s,t);
  list propagat=list(q1^2,(q1-p1)^2,(q1-p1-p2)^2,(q2+p1+p2)^2,(q2-p4)^2,q2^2,(q1+q2)^2,(q1+p4)^2,(q2+p1)^2);
  list replacementRules=list(p1^2,0,p2^2,0,p4^2,0,p1*p2,1/2*s,p1*p4,1/2*t,p2*p4,-1/2*(s+t));
  
  labeledgraph G1=makeBaikovMatrix(G2,internalmomenta,externalmomenta,mandelsonvars,propagat,replacementRules);
  ring RZ=G1.baikovover;
  list sector=list(1,2,3,4,5,6,7);
  module M=makeFormalIBP(G1,sector);
  list Lprop=getIBPwithMask(G1,M,93187,sector);  

  //One can use the following to print the IBPs with mask correspond to step 0
   for(int j=1;j<=size(Lprop[1]);j++){
    oneIBP I=Lprop[1][j];
   
      print(I);
    
   } 
  
}


