<?xml version="1.0" encoding="UTF-8"?>
<defun name="template">
    <struct name="feynman">
        <field name="MI" type="string"/>
        <field name="reducedIBPs" type="string"/>
        <field name="web" type="string"/>
    </struct>

    <in name="base_filename" type="string" place="base_filename"/>
    <in name="library_name" type="string" place="library_name"/>
    <in name="input" type="string" place="input"/>
    <out name="output" type="feynman" place="final_data"/>

    <net>
        <place name="base_filename" type="string">
        </place>
        <place name="library_name" type="string">
        </place>
        <place name="input" type="string">
        </place>
        <place name="labeledgraph" type="string">
        </place>
        <place name="data" type="feynman">
        </place>
        <place name="control_11" type="control">
            <token><value>[]</value></token>
        </place>
        <place name="data_11" type="feynman">
        </place>
        <place name="control_21" type="control">
            <token><value>[]</value></token>
        </place>
        <place name="data_21" type="feynman">
        </place>
        <place name="control_22" type="control">
            <token><value>[]</value></token>
        </place>
        <place name="data_22" type="feynman">
        </place>
        <place name="control_23" type="control">
            <token><value>[]</value></token>
        </place>
        <place name="data_23" type="feynman">
        </place>
        <place name="control_31" type="control">
            <token><value>[]</value></token>
        </place>
        <place name="data_31" type="feynman">
        </place>
        <place name="control_32" type="control">
            <token><value>[]</value></token>
        </place>
        <place name="data_32" type="feynman">
        </place>
        <place name="control_33" type="control">
            <token><value>[]</value></token>
        </place>
        <place name="data_33" type="feynman">
        </place>
        <place name="control_T_0" type="control">
            <token><value>[]</value></token>
        </place>
        <place name="control_T_end" type="control">
            <token><value>[]</value></token>
        </place>
        <place name="final_data" type="feynman">
        </place>
        <transition name="T_11">
            <defun>
                <require key="worker" mandatory="true"/>
                <out name="data_11" type="feynman"/>
                <in name="data" type="feynman"/>
                <in name="base_filename" type="string"/>
                <in name="library_name" type="string"/>
                <in name="input" type="string"/>
                <in name="labeledgraph" type="string"/>
                <in name="control_11" type="control"/>
                <module name="singular_template" require_function_unloads_without_rest="false" function="f_T_11(control_11, data, base_filename, library_name, input, labeledgraph, data_11)">
                    <cinclude href="interface/template_interface.hpp"/>
                    <cinclude href="util-generic/dynamic_linking.hpp"/>
                    <code><![CDATA[
                        std::string reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_seed_gpi)(data.reducedIBPs, library_name, base_filename);
                        std::cout << "reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        std::string targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInt_gpi)(input, library_name, base_filename);
                        std::cout << "Target Integrals: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(targetInt, library_name) << std::endl;
                        int j = 1, k = 1;
                        std::string wjk = RESOLVE_INTERFACE_FUNCTION(singular_replace_two)(data.web, j, k, library_name, base_filename);
                        std::string wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInts_gpi)(wjk, library_name, base_filename);
                        std::cout << "web[" << j << "," << k << "].TARGET = " <<std::endl;
                        int size_wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(wjk_targetInt, library_name, base_filename);
                        std::cout << "size_wjk_targetInt = " << size_wjk_targetInt << std::endl;
                        reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(targetInt, library_name, base_filename);
                        std::cout << "Updated reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        if (size_wjk_targetInt >= 1) {
                            std::string totalIBP = RESOLVE_INTERFACE_FUNCTION(singular_computeManyIBPjk_gpi)(labeledgraph, wjk_targetInt, library_name, base_filename);
                            std::string totalIBP_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(totalIBP, library_name, base_filename);
                            int size_totalIBP_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(totalIBP_IBP, library_name, base_filename);
                            std::cout << "Size of totalIBP_IBP: " << size_totalIBP_ibp << std::endl;
                                std::string reducedibp_over = RESOLVE_INTERFACE_FUNCTION(singular_over_gpi)(data.reducedIBPs, library_name, base_filename);
                                std::string totalIBP_over = RESOLVE_INTERFACE_FUNCTION(singular_over_gpi)(totalIBP, library_name, base_filename);
                                reducedibp_over = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(totalIBP_over, library_name, base_filename);
                                std::cout << "Updated reducedibp_over: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedibp_over, library_name) << std::endl;
                            std::string L = RESOLVE_INTERFACE_FUNCTION(singular_getRedIBPs_gpi)(totalIBP, 101, library_name, base_filename);
                            std::string indpndIBP = RESOLVE_INTERFACE_FUNCTION(singular_indpndIBP_gpi)(L, library_name, base_filename);
                            std::string masterAndTailIntgrals = RESOLVE_INTERFACE_FUNCTION(singular_masterAndTailIntgrals_gpi)(L, library_name, base_filename);
                            std::cout << "size of indpndIBP: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename) << std::endl;
                            std::cout  << " size of  Master and Tail Integrals: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterAndTailIntgrals, library_name, base_filename) << std::endl;
                            std::string reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(data.reducedIBPs, library_name, base_filename);
                            int size_reducedIBPs_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(reducedIBPs_IBP, library_name, base_filename);
                            if (size_reducedIBPs_ibp == 0) {
                                reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP, library_name, base_filename);
                                std::cout << "Assigned indpndIBP to reducedIBPs_IBP." << std::endl;
                            } else {
                                int indpndIBP_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename);
                                for (int i = 1; i <= indpndIBP_size; ++i) {
                                    std::string indpndIBP_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(indpndIBP, i, library_name, base_filename);
                                    reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP_i, library_name, base_filename);
                                    std::cout << "Assigned independent IBP at index " << i << std::endl;
                                }
                            }
                            std::string w = RESOLVE_INTERFACE_FUNCTION(singular_updateWeb_later)(data.web, masterAndTailIntgrals, j, k, library_name, base_filename);
                            std::string w1 = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 1, library_name, base_filename);
                            RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.web , w1, library_name, base_filename);
                            std::string masterIntgralsInSector = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 2, library_name, base_filename);
                            int masterIntgralsInSector_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterIntgralsInSector, library_name, base_filename);
                            std::cout << "masterIntgralsInSector_size: " << masterIntgralsInSector_size << std::endl;
                            int MI_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(data.MI, library_name, base_filename);
                            if (MI_size == 0) {
                                RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI ,masterIntgralsInSector, library_name, base_filename);
                                std::cout << "Assigned master integrals to MI." << std::endl;
                            } else {
                                for (int i = 1; i <= masterIntgralsInSector_size; ++i) {
                                    std::string masterIntgralsInSector_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(masterIntgralsInSector, i, library_name, base_filename);
                                    int alreadyIntheList = RESOLVE_INTERFACE_FUNCTION(singular_alreadyIntheList_gpi)(data.MI, masterIntgralsInSector_i, library_name);
                                    if (!alreadyIntheList) {
                                        RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI , masterIntgralsInSector_i, library_name, base_filename);
                                        std::cout << "Added master integral from sector index " << i << std::endl;
                                    }
                                }
                            }
                        }
                    ]]></code>
                </module>
            </defun>
            <connect-in port="control_11" place="control_11"/>
            <connect-read port="data" place="data"/>
            <connect-read port="base_filename" place="base_filename"/>
            <connect-read port="library_name" place="library_name"/>
            <connect-read port="input" place="input"/>
            <connect-read port="labeledgraph" place="labeledgraph"/>
            <connect-out port="data_11" place="data_11"/>
        </transition>
        <transition name="T_21">
            <defun>
                <require key="worker" mandatory="true"/>
                <in name="data_11" type="feynman"/>
                <out name="data_21" type="feynman"/>
                <in name="data" type="feynman"/>
                <in name="base_filename" type="string"/>
                <in name="library_name" type="string"/>
                <in name="input" type="string"/>
                <in name="labeledgraph" type="string"/>
                <in name="control_21" type="control"/>
                <module name="singular_template" require_function_unloads_without_rest="false" function="f_T_21(control_21, data, base_filename, library_name, input, labeledgraph, data_11, data_21)">
                    <cinclude href="interface/template_interface.hpp"/>
                    <cinclude href="util-generic/dynamic_linking.hpp"/>
                    <code><![CDATA[
                        std::string reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_seed_gpi)(data.reducedIBPs, library_name, base_filename);
                        std::cout << "reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        std::string targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInt_gpi)(input, library_name, base_filename);
                        std::cout << "Target Integrals: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(targetInt, library_name) << std::endl;
                        int j = 2, k = 1;
                        std::string wjk = RESOLVE_INTERFACE_FUNCTION(singular_replace_two)(data.web, j, k, library_name, base_filename);
                        std::string wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInts_gpi)(wjk, library_name, base_filename);
                        std::cout << "web[" << j << "," << k << "].TARGET = " <<std::endl;
                        int size_wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(wjk_targetInt, library_name, base_filename);
                        std::cout << "size_wjk_targetInt = " << size_wjk_targetInt << std::endl;
                        reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(targetInt, library_name, base_filename);
                        std::cout << "Updated reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        if (size_wjk_targetInt >= 1) {
                            std::string totalIBP = RESOLVE_INTERFACE_FUNCTION(singular_computeManyIBPjk_gpi)(labeledgraph, wjk_targetInt, library_name, base_filename);
                            std::string totalIBP_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(totalIBP, library_name, base_filename);
                            int size_totalIBP_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(totalIBP_IBP, library_name, base_filename);
                            std::cout << "Size of totalIBP_IBP: " << size_totalIBP_ibp << std::endl;
                            std::string L = RESOLVE_INTERFACE_FUNCTION(singular_getRedIBPs_gpi)(totalIBP, 101, library_name, base_filename);
                            std::string indpndIBP = RESOLVE_INTERFACE_FUNCTION(singular_indpndIBP_gpi)(L, library_name, base_filename);
                            std::string masterAndTailIntgrals = RESOLVE_INTERFACE_FUNCTION(singular_masterAndTailIntgrals_gpi)(L, library_name, base_filename);
                            std::cout << "size of indpndIBP: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename) << std::endl;
                            std::cout  << " size of  Master and Tail Integrals: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterAndTailIntgrals, library_name, base_filename) << std::endl;
                            std::string reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(data.reducedIBPs, library_name, base_filename);
                            int size_reducedIBPs_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(reducedIBPs_IBP, library_name, base_filename);
                            if (size_reducedIBPs_ibp == 0) {
                                reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP, library_name, base_filename);
                                std::cout << "Assigned indpndIBP to reducedIBPs_IBP." << std::endl;
                            } else {
                                int indpndIBP_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename);
                                for (int i = 1; i <= indpndIBP_size; ++i) {
                                    std::string indpndIBP_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(indpndIBP, i, library_name, base_filename);
                                    reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP_i, library_name, base_filename);
                                    std::cout << "Assigned independent IBP at index " << i << std::endl;
                                }
                            }
                            std::string w = RESOLVE_INTERFACE_FUNCTION(singular_updateWeb_later)(data.web, masterAndTailIntgrals, j, k, library_name, base_filename);
                            std::string w1 = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 1, library_name, base_filename);
                            RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.web , w1, library_name, base_filename);
                            std::string masterIntgralsInSector = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 2, library_name, base_filename);
                            int masterIntgralsInSector_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterIntgralsInSector, library_name, base_filename);
                            std::cout << "masterIntgralsInSector_size: " << masterIntgralsInSector_size << std::endl;
                            int MI_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(data.MI, library_name, base_filename);
                            if (MI_size == 0) {
                                RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI ,masterIntgralsInSector, library_name, base_filename);
                                std::cout << "Assigned master integrals to MI." << std::endl;
                            } else {
                                for (int i = 1; i <= masterIntgralsInSector_size; ++i) {
                                    std::string masterIntgralsInSector_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(masterIntgralsInSector, i, library_name, base_filename);
                                    int alreadyIntheList = RESOLVE_INTERFACE_FUNCTION(singular_alreadyIntheList_gpi)(data.MI, masterIntgralsInSector_i, library_name);
                                    if (!alreadyIntheList) {
                                        RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI , masterIntgralsInSector_i, library_name, base_filename);
                                        std::cout << "Added master integral from sector index " << i << std::endl;
                                    }
                                }
                            }
                        }
                    ]]></code>
                </module>
            </defun>
            <connect-in port="control_21" place="control_21"/>
            <connect-in port="data_11" place="data_11"/>
            <connect-read port="data" place="data"/>
            <connect-read port="base_filename" place="base_filename"/>
            <connect-read port="library_name" place="library_name"/>
            <connect-read port="input" place="input"/>
            <connect-read port="labeledgraph" place="labeledgraph"/>
            <connect-out port="data_21" place="data_21"/>
        </transition>
        <transition name="T_22">
            <defun>
                <require key="worker" mandatory="true"/>
                <in name="data_11" type="feynman"/>
                <out name="data_22" type="feynman"/>
                <in name="data" type="feynman"/>
                <in name="base_filename" type="string"/>
                <in name="library_name" type="string"/>
                <in name="input" type="string"/>
                <in name="labeledgraph" type="string"/>
                <in name="control_22" type="control"/>
                <module name="singular_template" require_function_unloads_without_rest="false" function="f_T_22(control_22, data, base_filename, library_name, input, labeledgraph, data_11, data_22)">
                    <cinclude href="interface/template_interface.hpp"/>
                    <cinclude href="util-generic/dynamic_linking.hpp"/>
                    <code><![CDATA[
                        std::string reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_seed_gpi)(data.reducedIBPs, library_name, base_filename);
                        std::cout << "reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        std::string targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInt_gpi)(input, library_name, base_filename);
                        std::cout << "Target Integrals: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(targetInt, library_name) << std::endl;
                        int j = 2, k = 2;
                        std::string wjk = RESOLVE_INTERFACE_FUNCTION(singular_replace_two)(data.web, j, k, library_name, base_filename);
                        std::string wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInts_gpi)(wjk, library_name, base_filename);
                        std::cout << "web[" << j << "," << k << "].TARGET = " <<std::endl;
                        int size_wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(wjk_targetInt, library_name, base_filename);
                        std::cout << "size_wjk_targetInt = " << size_wjk_targetInt << std::endl;
                        reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(targetInt, library_name, base_filename);
                        std::cout << "Updated reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        if (size_wjk_targetInt >= 1) {
                            std::string totalIBP = RESOLVE_INTERFACE_FUNCTION(singular_computeManyIBPjk_gpi)(labeledgraph, wjk_targetInt, library_name, base_filename);
                            std::string totalIBP_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(totalIBP, library_name, base_filename);
                            int size_totalIBP_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(totalIBP_IBP, library_name, base_filename);
                            std::cout << "Size of totalIBP_IBP: " << size_totalIBP_ibp << std::endl;
                            std::string L = RESOLVE_INTERFACE_FUNCTION(singular_getRedIBPs_gpi)(totalIBP, 101, library_name, base_filename);
                            std::string indpndIBP = RESOLVE_INTERFACE_FUNCTION(singular_indpndIBP_gpi)(L, library_name, base_filename);
                            std::string masterAndTailIntgrals = RESOLVE_INTERFACE_FUNCTION(singular_masterAndTailIntgrals_gpi)(L, library_name, base_filename);
                            std::cout << "size of indpndIBP: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename) << std::endl;
                            std::cout  << " size of  Master and Tail Integrals: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterAndTailIntgrals, library_name, base_filename) << std::endl;
                            std::string reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(data.reducedIBPs, library_name, base_filename);
                            int size_reducedIBPs_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(reducedIBPs_IBP, library_name, base_filename);
                            if (size_reducedIBPs_ibp == 0) {
                                reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP, library_name, base_filename);
                                std::cout << "Assigned indpndIBP to reducedIBPs_IBP." << std::endl;
                            } else {
                                int indpndIBP_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename);
                                for (int i = 1; i <= indpndIBP_size; ++i) {
                                    std::string indpndIBP_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(indpndIBP, i, library_name, base_filename);
                                    reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP_i, library_name, base_filename);
                                    std::cout << "Assigned independent IBP at index " << i << std::endl;
                                }
                            }
                            std::string w = RESOLVE_INTERFACE_FUNCTION(singular_updateWeb_later)(data.web, masterAndTailIntgrals, j, k, library_name, base_filename);
                            std::string w1 = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 1, library_name, base_filename);
                            RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.web , w1, library_name, base_filename);
                            std::string masterIntgralsInSector = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 2, library_name, base_filename);
                            int masterIntgralsInSector_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterIntgralsInSector, library_name, base_filename);
                            std::cout << "masterIntgralsInSector_size: " << masterIntgralsInSector_size << std::endl;
                            int MI_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(data.MI, library_name, base_filename);
                            if (MI_size == 0) {
                                RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI ,masterIntgralsInSector, library_name, base_filename);
                                std::cout << "Assigned master integrals to MI." << std::endl;
                            } else {
                                for (int i = 1; i <= masterIntgralsInSector_size; ++i) {
                                    std::string masterIntgralsInSector_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(masterIntgralsInSector, i, library_name, base_filename);
                                    int alreadyIntheList = RESOLVE_INTERFACE_FUNCTION(singular_alreadyIntheList_gpi)(data.MI, masterIntgralsInSector_i, library_name);
                                    if (!alreadyIntheList) {
                                        RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI , masterIntgralsInSector_i, library_name, base_filename);
                                        std::cout << "Added master integral from sector index " << i << std::endl;
                                    }
                                }
                            }
                        }
                    ]]></code>
                </module>
            </defun>
            <connect-in port="control_22" place="control_22"/>
            <connect-in port="data_11" place="data_11"/>
            <connect-read port="data" place="data"/>
            <connect-read port="base_filename" place="base_filename"/>
            <connect-read port="library_name" place="library_name"/>
            <connect-read port="input" place="input"/>
            <connect-read port="labeledgraph" place="labeledgraph"/>
            <connect-out port="data_22" place="data_22"/>
        </transition>
        <transition name="T_23">
            <defun>
                <require key="worker" mandatory="true"/>
                <in name="data_11" type="feynman"/>
                <out name="data_23" type="feynman"/>
                <in name="data" type="feynman"/>
                <in name="base_filename" type="string"/>
                <in name="library_name" type="string"/>
                <in name="input" type="string"/>
                <in name="labeledgraph" type="string"/>
                <in name="control_23" type="control"/>
                <module name="singular_template" require_function_unloads_without_rest="false" function="f_T_23(control_23, data, base_filename, library_name, input, labeledgraph, data_11, data_23)">
                    <cinclude href="interface/template_interface.hpp"/>
                    <cinclude href="util-generic/dynamic_linking.hpp"/>
                    <code><![CDATA[
                        std::string reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_seed_gpi)(data.reducedIBPs, library_name, base_filename);
                        std::cout << "reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        std::string targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInt_gpi)(input, library_name, base_filename);
                        std::cout << "Target Integrals: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(targetInt, library_name) << std::endl;
                        int j = 2, k = 3;
                        std::string wjk = RESOLVE_INTERFACE_FUNCTION(singular_replace_two)(data.web, j, k, library_name, base_filename);
                        std::string wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInts_gpi)(wjk, library_name, base_filename);
                        std::cout << "web[" << j << "," << k << "].TARGET = " <<std::endl;
                        int size_wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(wjk_targetInt, library_name, base_filename);
                        std::cout << "size_wjk_targetInt = " << size_wjk_targetInt << std::endl;
                        reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(targetInt, library_name, base_filename);
                        std::cout << "Updated reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        if (size_wjk_targetInt >= 1) {
                            std::string totalIBP = RESOLVE_INTERFACE_FUNCTION(singular_computeManyIBPjk_gpi)(labeledgraph, wjk_targetInt, library_name, base_filename);
                            std::string totalIBP_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(totalIBP, library_name, base_filename);
                            int size_totalIBP_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(totalIBP_IBP, library_name, base_filename);
                            std::cout << "Size of totalIBP_IBP: " << size_totalIBP_ibp << std::endl;
                            std::string L = RESOLVE_INTERFACE_FUNCTION(singular_getRedIBPs_gpi)(totalIBP, 101, library_name, base_filename);
                            std::string indpndIBP = RESOLVE_INTERFACE_FUNCTION(singular_indpndIBP_gpi)(L, library_name, base_filename);
                            std::string masterAndTailIntgrals = RESOLVE_INTERFACE_FUNCTION(singular_masterAndTailIntgrals_gpi)(L, library_name, base_filename);
                            std::cout << "size of indpndIBP: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename) << std::endl;
                            std::cout  << " size of  Master and Tail Integrals: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterAndTailIntgrals, library_name, base_filename) << std::endl;
                            std::string reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(data.reducedIBPs, library_name, base_filename);
                            int size_reducedIBPs_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(reducedIBPs_IBP, library_name, base_filename);
                            if (size_reducedIBPs_ibp == 0) {
                                reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP, library_name, base_filename);
                                std::cout << "Assigned indpndIBP to reducedIBPs_IBP." << std::endl;
                            } else {
                                int indpndIBP_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename);
                                for (int i = 1; i <= indpndIBP_size; ++i) {
                                    std::string indpndIBP_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(indpndIBP, i, library_name, base_filename);
                                    reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP_i, library_name, base_filename);
                                    std::cout << "Assigned independent IBP at index " << i << std::endl;
                                }
                            }
                            std::string w = RESOLVE_INTERFACE_FUNCTION(singular_updateWeb_later)(data.web, masterAndTailIntgrals, j, k, library_name, base_filename);
                            std::string w1 = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 1, library_name, base_filename);
                            RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.web , w1, library_name, base_filename);
                            std::string masterIntgralsInSector = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 2, library_name, base_filename);
                            int masterIntgralsInSector_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterIntgralsInSector, library_name, base_filename);
                            std::cout << "masterIntgralsInSector_size: " << masterIntgralsInSector_size << std::endl;
                            int MI_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(data.MI, library_name, base_filename);
                            if (MI_size == 0) {
                                RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI ,masterIntgralsInSector, library_name, base_filename);
                                std::cout << "Assigned master integrals to MI." << std::endl;
                            } else {
                                for (int i = 1; i <= masterIntgralsInSector_size; ++i) {
                                    std::string masterIntgralsInSector_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(masterIntgralsInSector, i, library_name, base_filename);
                                    int alreadyIntheList = RESOLVE_INTERFACE_FUNCTION(singular_alreadyIntheList_gpi)(data.MI, masterIntgralsInSector_i, library_name);
                                    if (!alreadyIntheList) {
                                        RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI , masterIntgralsInSector_i, library_name, base_filename);
                                        std::cout << "Added master integral from sector index " << i << std::endl;
                                    }
                                }
                            }
                        }
                    ]]></code>
                </module>
            </defun>
            <connect-in port="control_23" place="control_23"/>
            <connect-in port="data_11" place="data_11"/>
            <connect-read port="data" place="data"/>
            <connect-read port="base_filename" place="base_filename"/>
            <connect-read port="library_name" place="library_name"/>
            <connect-read port="input" place="input"/>
            <connect-read port="labeledgraph" place="labeledgraph"/>
            <connect-out port="data_23" place="data_23"/>
        </transition>
        <transition name="T_31">
            <defun>
                <require key="worker" mandatory="true"/>
                <in name="data_21" type="feynman"/>
                <in name="data_23" type="feynman"/>
                <out name="data_31" type="feynman"/>
                <in name="data" type="feynman"/>
                <in name="base_filename" type="string"/>
                <in name="library_name" type="string"/>
                <in name="input" type="string"/>
                <in name="labeledgraph" type="string"/>
                <in name="control_31" type="control"/>
                <module name="singular_template" require_function_unloads_without_rest="false" function="f_T_31(control_31, data, base_filename, library_name, input, labeledgraph, data_21, data_23, data_31)">
                    <cinclude href="interface/template_interface.hpp"/>
                    <cinclude href="util-generic/dynamic_linking.hpp"/>
                    <code><![CDATA[
                        std::vector<std::string> feynman_inputs;

                // Serialize data_21
                std::string data_21_str = "{web=\"" + data_21.web + "\", reducedIBPs=\"" + data_21.reducedIBPs + "\", MI=\"" + data_21.MI + "\"}";
                feynman_inputs.push_back(data_21_str);

                // Serialize data_23
                std::string data_23_str = "{web=\"" + data_23.web + "\", reducedIBPs=\"" + data_23.reducedIBPs + "\", MI=\"" + data_23.MI + "\"}";
                feynman_inputs.push_back(data_23_str);

                // Create the serialized data_list
                std::string data_list = RESOLVE_INTERFACE_FUNCTION(create_feynman_data_list)(feynman_inputs, library_name, base_filename);

                // Merge using singular_mergeFeynman_gpi
                std::string merged_token_str = RESOLVE_INTERFACE_FUNCTION(singular_mergeFeynman_gpi)(data_list, library_name, base_filename);

                // Deserialize into data_out
                std::string merged_data_str = RESOLVE_INTERFACE_FUNCTION(singular_deserialize_feynman_token)(merged_token_str, library_name, base_filename);
                
                // Parse the JSON-like string into data_out (simplified parsing)
                size_t mi_pos = merged_data_str.find("\"MI\":\"");
                if (mi_pos != std::string::npos) {
                    mi_pos += 6;
                    size_t mi_end = merged_data_str.find("\"", mi_pos);
                    data.MI = merged_data_str.substr(mi_pos, mi_end - mi_pos);
                }
                size_t red_pos = merged_data_str.find("\"reducedIBPs\":\"");
                if (red_pos != std::string::npos) {
                    red_pos += 14;
                    size_t red_end = merged_data_str.find("\"", red_pos);
                    data.reducedIBPs = merged_data_str.substr(red_pos, red_end - red_pos);
                }
                size_t web_pos = merged_data_str.find("\"web\":\"");
                if (web_pos != std::string::npos) {
                    web_pos += 7;
                    size_t web_end = merged_data_str.find("\"", web_pos);
                    data_out.web = merged_data_str.substr(web_pos, web_end - web_pos);
                }

                // Continue with the rest of the logic
                std::string reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_seed_gpi)(data_out.reducedIBPs, library_name, base_filename);   std::cout << "reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        std::cout << "reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        std::string targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInt_gpi)(input, library_name, base_filename);
                        std::cout << "Target Integrals: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(targetInt, library_name) << std::endl;
                        int j = 3, k = 1;
                        std::string wjk = RESOLVE_INTERFACE_FUNCTION(singular_replace_two)(data.web, j, k, library_name, base_filename);
                        std::string wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInts_gpi)(wjk, library_name, base_filename);
                        std::cout << "web[" << j << "," << k << "].TARGET = " <<std::endl;
                        int size_wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(wjk_targetInt, library_name, base_filename);
                        std::cout << "size_wjk_targetInt = " << size_wjk_targetInt << std::endl;
                        reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(targetInt, library_name, base_filename);
                        std::cout << "Updated reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        if (size_wjk_targetInt >= 1) {
                            std::string totalIBP = RESOLVE_INTERFACE_FUNCTION(singular_computeManyIBPjk_gpi)(labeledgraph, wjk_targetInt, library_name, base_filename);
                            std::string totalIBP_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(totalIBP, library_name, base_filename);
                            int size_totalIBP_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(totalIBP_IBP, library_name, base_filename);
                            std::cout << "Size of totalIBP_IBP: " << size_totalIBP_ibp << std::endl;
                            std::string L = RESOLVE_INTERFACE_FUNCTION(singular_getRedIBPs_gpi)(totalIBP, 101, library_name, base_filename);
                            std::string indpndIBP = RESOLVE_INTERFACE_FUNCTION(singular_indpndIBP_gpi)(L, library_name, base_filename);
                            std::string masterAndTailIntgrals = RESOLVE_INTERFACE_FUNCTION(singular_masterAndTailIntgrals_gpi)(L, library_name, base_filename);
                            std::cout << "size of indpndIBP: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename) << std::endl;
                            std::cout  << " size of  Master and Tail Integrals: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterAndTailIntgrals, library_name, base_filename) << std::endl;
                            std::string reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(data.reducedIBPs, library_name, base_filename);
                            int size_reducedIBPs_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(reducedIBPs_IBP, library_name, base_filename);
                            if (size_reducedIBPs_ibp == 0) {
                                reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP, library_name, base_filename);
                                std::cout << "Assigned indpndIBP to reducedIBPs_IBP." << std::endl;
                            } else {
                                int indpndIBP_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename);
                                for (int i = 1; i <= indpndIBP_size; ++i) {
                                    std::string indpndIBP_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(indpndIBP, i, library_name, base_filename);
                                    reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP_i, library_name, base_filename);
                                    std::cout << "Assigned independent IBP at index " << i << std::endl;
                                }
                            }
                            std::string w = RESOLVE_INTERFACE_FUNCTION(singular_updateWeb_later)(data.web, masterAndTailIntgrals, j, k, library_name, base_filename);
                            std::string w1 = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 1, library_name, base_filename);
                            RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.web , w1, library_name, base_filename);
                            std::string masterIntgralsInSector = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 2, library_name, base_filename);
                            int masterIntgralsInSector_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterIntgralsInSector, library_name, base_filename);
                            std::cout << "masterIntgralsInSector_size: " << masterIntgralsInSector_size << std::endl;
                            int MI_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(data.MI, library_name, base_filename);
                            if (MI_size == 0) {
                                RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI ,masterIntgralsInSector, library_name, base_filename);
                                std::cout << "Assigned master integrals to MI." << std::endl;
                            } else {
                                for (int i = 1; i <= masterIntgralsInSector_size; ++i) {
                                    std::string masterIntgralsInSector_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(masterIntgralsInSector, i, library_name, base_filename);
                                    int alreadyIntheList = RESOLVE_INTERFACE_FUNCTION(singular_alreadyIntheList_gpi)(data.MI, masterIntgralsInSector_i, library_name);
                                    if (!alreadyIntheList) {
                                        RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI , masterIntgralsInSector_i, library_name, base_filename);
                                        std::cout << "Added master integral from sector index " << i << std::endl;
                                    }
                                }
                            }
                        }
                    ]]></code>
                </module>
            </defun>
            <connect-in port="control_31" place="control_31"/>
            <connect-in port="data_21" place="data_21"/>
            <connect-in port="data_23" place="data_23"/>
            <connect-read port="data" place="data"/>
            <connect-read port="base_filename" place="base_filename"/>
            <connect-read port="library_name" place="library_name"/>
            <connect-read port="input" place="input"/>
            <connect-read port="labeledgraph" place="labeledgraph"/>
            <connect-out port="data_31" place="data_31"/>
        </transition>
        <transition name="T_32">
            <defun>
                <require key="worker" mandatory="true"/>
                <in name="data_21" type="feynman"/>
                <in name="data_22" type="feynman"/>
                <out name="data_32" type="feynman"/>
                <in name="data" type="feynman"/>
                <in name="base_filename" type="string"/>
                <in name="library_name" type="string"/>
                <in name="input" type="string"/>
                <in name="labeledgraph" type="string"/>
                <in name="control_32" type="control"/>
                <module name="singular_template" require_function_unloads_without_rest="false" function="f_T_32(control_32, data, base_filename, library_name, input, labeledgraph, data_21, data_22, data_32)">
                    <cinclude href="interface/template_interface.hpp"/>
                    <cinclude href="util-generic/dynamic_linking.hpp"/>
                    <code><![CDATA[
                        std::string reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_seed_gpi)(data.reducedIBPs, library_name, base_filename);
                        std::cout << "reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        std::string targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInt_gpi)(input, library_name, base_filename);
                        std::cout << "Target Integrals: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(targetInt, library_name) << std::endl;
                        int j = 3, k = 2;
                        std::string wjk = RESOLVE_INTERFACE_FUNCTION(singular_replace_two)(data.web, j, k, library_name, base_filename);
                        std::string wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInts_gpi)(wjk, library_name, base_filename);
                        std::cout << "web[" << j << "," << k << "].TARGET = " <<std::endl;
                        int size_wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(wjk_targetInt, library_name, base_filename);
                        std::cout << "size_wjk_targetInt = " << size_wjk_targetInt << std::endl;
                        reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(targetInt, library_name, base_filename);
                        std::cout << "Updated reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        if (size_wjk_targetInt >= 1) {
                            std::string totalIBP = RESOLVE_INTERFACE_FUNCTION(singular_computeManyIBPjk_gpi)(labeledgraph, wjk_targetInt, library_name, base_filename);
                            std::string totalIBP_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(totalIBP, library_name, base_filename);
                            int size_totalIBP_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(totalIBP_IBP, library_name, base_filename);
                            std::cout << "Size of totalIBP_IBP: " << size_totalIBP_ibp << std::endl;
                            std::string L = RESOLVE_INTERFACE_FUNCTION(singular_getRedIBPs_gpi)(totalIBP, 101, library_name, base_filename);
                            std::string indpndIBP = RESOLVE_INTERFACE_FUNCTION(singular_indpndIBP_gpi)(L, library_name, base_filename);
                            std::string masterAndTailIntgrals = RESOLVE_INTERFACE_FUNCTION(singular_masterAndTailIntgrals_gpi)(L, library_name, base_filename);
                            std::cout << "size of indpndIBP: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename) << std::endl;
                            std::cout  << " size of  Master and Tail Integrals: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterAndTailIntgrals, library_name, base_filename) << std::endl;
                            std::string reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(data.reducedIBPs, library_name, base_filename);
                            int size_reducedIBPs_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(reducedIBPs_IBP, library_name, base_filename);
                            if (size_reducedIBPs_ibp == 0) {
                                reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP, library_name, base_filename);
                                std::cout << "Assigned indpndIBP to reducedIBPs_IBP." << std::endl;
                            } else {
                                int indpndIBP_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename);
                                for (int i = 1; i <= indpndIBP_size; ++i) {
                                    std::string indpndIBP_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(indpndIBP, i, library_name, base_filename);
                                    reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP_i, library_name, base_filename);
                                    std::cout << "Assigned independent IBP at index " << i << std::endl;
                                }
                            }
                            std::string w = RESOLVE_INTERFACE_FUNCTION(singular_updateWeb_later)(data.web, masterAndTailIntgrals, j, k, library_name, base_filename);
                            std::string w1 = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 1, library_name, base_filename);
                            RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.web , w1, library_name, base_filename);
                            std::string masterIntgralsInSector = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 2, library_name, base_filename);
                            int masterIntgralsInSector_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterIntgralsInSector, library_name, base_filename);
                            std::cout << "masterIntgralsInSector_size: " << masterIntgralsInSector_size << std::endl;
                            int MI_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(data.MI, library_name, base_filename);
                            if (MI_size == 0) {
                                RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI ,masterIntgralsInSector, library_name, base_filename);
                                std::cout << "Assigned master integrals to MI." << std::endl;
                            } else {
                                for (int i = 1; i <= masterIntgralsInSector_size; ++i) {
                                    std::string masterIntgralsInSector_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(masterIntgralsInSector, i, library_name, base_filename);
                                    int alreadyIntheList = RESOLVE_INTERFACE_FUNCTION(singular_alreadyIntheList_gpi)(data.MI, masterIntgralsInSector_i, library_name);
                                    if (!alreadyIntheList) {
                                        RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI , masterIntgralsInSector_i, library_name, base_filename);
                                        std::cout << "Added master integral from sector index " << i << std::endl;
                                    }
                                }
                            }
                        }
                    ]]></code>
                </module>
            </defun>
            <connect-in port="control_32" place="control_32"/>
            <connect-in port="data_21" place="data_21"/>
            <connect-in port="data_22" place="data_22"/>
            <connect-read port="data" place="data"/>
            <connect-read port="base_filename" place="base_filename"/>
            <connect-read port="library_name" place="library_name"/>
            <connect-read port="input" place="input"/>
            <connect-read port="labeledgraph" place="labeledgraph"/>
            <connect-out port="data_32" place="data_32"/>
        </transition>
        <transition name="T_33">
            <defun>
                <require key="worker" mandatory="true"/>
                <in name="data_22" type="feynman"/>
                <in name="data_23" type="feynman"/>
                <out name="data_33" type="feynman"/>
                <in name="data" type="feynman"/>
                <in name="base_filename" type="string"/>
                <in name="library_name" type="string"/>
                <in name="input" type="string"/>
                <in name="labeledgraph" type="string"/>
                <in name="control_33" type="control"/>
                <module name="singular_template" require_function_unloads_without_rest="false" function="f_T_33(control_33, data, base_filename, library_name, input, labeledgraph, data_22, data_23, data_33)">
                    <cinclude href="interface/template_interface.hpp"/>
                    <cinclude href="util-generic/dynamic_linking.hpp"/>
                    <code><![CDATA[
                        std::string reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_seed_gpi)(data.reducedIBPs, library_name, base_filename);
                        std::cout << "reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        std::string targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInt_gpi)(input, library_name, base_filename);
                        std::cout << "Target Integrals: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(targetInt, library_name) << std::endl;
                        int j = 3, k = 3;
                        std::string wjk = RESOLVE_INTERFACE_FUNCTION(singular_replace_two)(data.web, j, k, library_name, base_filename);
                        std::string wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_targetInts_gpi)(wjk, library_name, base_filename);
                        std::cout << "web[" << j << "," << k << "].TARGET = " <<std::endl;
                        int size_wjk_targetInt = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(wjk_targetInt, library_name, base_filename);
                        std::cout << "size_wjk_targetInt = " << size_wjk_targetInt << std::endl;
                        reducedIBPs_seed = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(targetInt, library_name, base_filename);
                        std::cout << "Updated reducedIBPs_seed: " << RESOLVE_INTERFACE_FUNCTION(printGpiTokenContent)(reducedIBPs_seed, library_name) << std::endl;
                        if (size_wjk_targetInt >= 1) {
                            std::string totalIBP = RESOLVE_INTERFACE_FUNCTION(singular_computeManyIBPjk_gpi)(labeledgraph, wjk_targetInt, library_name, base_filename);
                            std::string totalIBP_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(totalIBP, library_name, base_filename);
                            int size_totalIBP_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(totalIBP_IBP, library_name, base_filename);
                            std::cout << "Size of totalIBP_IBP: " << size_totalIBP_ibp << std::endl;
                            std::string L = RESOLVE_INTERFACE_FUNCTION(singular_getRedIBPs_gpi)(totalIBP, 101, library_name, base_filename);
                            std::string indpndIBP = RESOLVE_INTERFACE_FUNCTION(singular_indpndIBP_gpi)(L, library_name, base_filename);
                            std::string masterAndTailIntgrals = RESOLVE_INTERFACE_FUNCTION(singular_masterAndTailIntgrals_gpi)(L, library_name, base_filename);
                            std::cout << "size of indpndIBP: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename) << std::endl;
                            std::cout  << " size of  Master and Tail Integrals: " << RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterAndTailIntgrals, library_name, base_filename) << std::endl;
                            std::string reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_IBP_gpi)(data.reducedIBPs, library_name, base_filename);
                            int size_reducedIBPs_ibp = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(reducedIBPs_IBP, library_name, base_filename);
                            if (size_reducedIBPs_ibp == 0) {
                                reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP, library_name, base_filename);
                                std::cout << "Assigned indpndIBP to reducedIBPs_IBP." << std::endl;
                            } else {
                                int indpndIBP_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(indpndIBP, library_name, base_filename);
                                for (int i = 1; i <= indpndIBP_size; ++i) {
                                    std::string indpndIBP_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(indpndIBP, i, library_name, base_filename);
                                    reducedIBPs_IBP = RESOLVE_INTERFACE_FUNCTION(singular_assign_gpi)(indpndIBP_i, library_name, base_filename);
                                    std::cout << "Assigned independent IBP at index " << i << std::endl;
                                }
                            }
                            std::string w = RESOLVE_INTERFACE_FUNCTION(singular_updateWeb_later)(data.web, masterAndTailIntgrals, j, k, library_name, base_filename);
                            std::string w1 = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 1, library_name, base_filename);
                            RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.web , w1, library_name, base_filename);
                            std::string masterIntgralsInSector = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(w, 2, library_name, base_filename);
                            int masterIntgralsInSector_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(masterIntgralsInSector, library_name, base_filename);
                            std::cout << "masterIntgralsInSector_size: " << masterIntgralsInSector_size << std::endl;
                            int MI_size = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(data.MI, library_name, base_filename);
                            if (MI_size == 0) {
                                RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI ,masterIntgralsInSector, library_name, base_filename);
                                std::cout << "Assigned master integrals to MI." << std::endl;
                            } else {
                                for (int i = 1; i <= masterIntgralsInSector_size; ++i) {
                                    std::string masterIntgralsInSector_i = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(masterIntgralsInSector, i, library_name, base_filename);
                                    int alreadyIntheList = RESOLVE_INTERFACE_FUNCTION(singular_alreadyIntheList_gpi)(data.MI, masterIntgralsInSector_i, library_name);
                                    if (!alreadyIntheList) {
                                        RESOLVE_INTERFACE_FUNCTION(singular_equal_gpi)(data.MI , masterIntgralsInSector_i, library_name, base_filename);
                                        std::cout << "Added master integral from sector index " << i << std::endl;
                                    }
                                }
                            }
                        }
                    ]]></code>
                </module>
            </defun>
            <connect-in port="control_33" place="control_33"/>
            <connect-in port="data_22" place="data_22"/>
            <connect-in port="data_23" place="data_23"/>
            <connect-read port="data" place="data"/>
            <connect-read port="base_filename" place="base_filename"/>
            <connect-read port="library_name" place="library_name"/>
            <connect-read port="input" place="input"/>
            <connect-read port="labeledgraph" place="labeledgraph"/>
            <connect-out port="data_33" place="data_33"/>
        </transition>
        <transition name="T_0">
            <defun>
                <require key="worker" mandatory="true"/>
                <out name="labeledgraph" type="string"/>
                <out name="data" type="feynman"/>
                <in name="library_name" type="string"/>
                <in name="base_filename" type="string"/>
                <in name="input" type="string"/>
                <in name="control_T_0" type="control"/>
                <module name="singular_template" require_function_unloads_without_rest="false" function="f_T_0(control_T_0, library_name, base_filename, input, labeledgraph, data)">
                    <cinclude href="interface/template_interface.hpp"/>
                    <cinclude href="util-generic/dynamic_linking.hpp"/>
                    <code><![CDATA[
                        labeledgraph = RESOLVE_INTERFACE_FUNCTION(singular_getReducedIBPSystem_gpi)(input, library_name, base_filename);
                        data.web = RESOLVE_INTERFACE_FUNCTION(singular_updateWeb_gpi)(input, library_name, base_filename);
                        data.reducedIBPs = RESOLVE_INTERFACE_FUNCTION(singular_reducedIBPs_gpi)(input, library_name, base_filename);
                        data.MI = RESOLVE_INTERFACE_FUNCTION(singular_MI_gpi)(input, library_name, base_filename);
                        std::cout << "web: " << data.web << std::endl;
                    ]]></code>
                </module>
            </defun>
            <connect-in port="control_T_0" place="control_T_0"/>
            <connect-read port="library_name" place="library_name"/>
            <connect-read port="base_filename" place="base_filename"/>
            <connect-read port="input" place="input"/>
            <connect-out port="labeledgraph" place="labeledgraph"/>
            <connect-out port="data" place="data"/>
        </transition>
        <transition name="T_end">
            <defun>
                <require key="worker" mandatory="true"/>
                <in name="data_31" type="feynman"/>
                <in name="data_32" type="feynman"/>
                <in name="data_33" type="feynman"/>
                <out name="final_data" type="feynman"/>
                <in name="control_T_end" type="control"/>
                <module name="singular_template" require_function_unloads_without_rest="false" function="f_T_end(control_T_end, data_31, data_32, data_33, final_data)">
                    <cinclude href="interface/template_interface.hpp"/>
                    <cinclude href="util-generic/dynamic_linking.hpp"/>
                    <code><![CDATA[
                        final_data.web = "";
                        final_data.web += data_31.web;
                        final_data.web += data_32.web;
                        final_data.web += data_33.web;
                        final_data.reducedIBPs = data_31.reducedIBPs;
                        final_data.MI = data_31.MI;
                    ]]></code>
                </module>
            </defun>
            <connect-in port="control_T_end" place="control_T_end"/>
            <connect-in port="data_31" place="data_31"/>
            <connect-in port="data_32" place="data_32"/>
            <connect-in port="data_33" place="data_33"/>
            <connect-out port="final_data" place="final_data"/>
        </transition>
    </net>
</defun>