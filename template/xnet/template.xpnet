<defun name="template">
    <struct name="feynman">
        <field name="MI" type="string"/>
        <field name="reducedIBPs" type="string"/>
        <field name="web" type="string"/>
    </struct>
  <in name="base_filename" type="string" place="place_base_filename"/>
  <in name="library_name" type="string" place="place_library_name"/>
  <in name="input" type="string" place="place_input"/>
  <out name="output" type="feynman" place="mi_ibp"/>
  <net>
    <place name="place_input" type="string"/>
    <place name="data" type="feynman"/>

    <place name="place_base_filename" type="string"/>
    <place name="place_library_name" type="string"/>
    <place name="input_control" type="control">
      <token>
        <value>[]</value>
      </token>
    </place>

    <transition name="compute">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="input_control" type="control"/>
        <in name="library_name" type="string"/>
        <in name="base_filename" type="string"/>
        <in name="input" type="string"/>
        <out name="labeledgraph" type="string"/>
        <out name="web_copy" type="string"/>
        <out name="data" type="feynman"/>

        <module name="singular_template" require_function_unloads_without_rest="false" function="compute(input_control,input,library_name,base_filename,labeledgraph,data,web_copy)">
          <cinclude href="interface/template_interface.hpp" />
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <code><![CDATA[
						labeledgraph = RESOLVE_INTERFACE_FUNCTION(singular_getReducedIBPSystem_gpi)(input, library_name, base_filename);
              data.web = RESOLVE_INTERFACE_FUNCTION(singular_updateWeb_gpi)(input, library_name, base_filename);
              data.reducedIBPs = RESOLVE_INTERFACE_FUNCTION(singular_reducedIBPs_gpi)(input, library_name, base_filename);   
              data.MI = RESOLVE_INTERFACE_FUNCTION(singular_MI_gpi)(input, library_name, base_filename);

             web_copy=data.web;
             std::cout<<" web "<<data.web<<std::endl;
    

            		]]>          </code>
        </module>
      </defun>
      <connect-read port="library_name" place="place_library_name"/>
      <connect-read port="base_filename" place="place_base_filename"/>
      <connect-read port="input" place="place_input"/>
      <connect-in port="input_control" place="input_control"/>
      <connect-out port="labeledgraph" place="labeledgraph"/>
      <connect-out port="web_copy" place="web_copy"/>
      <connect-out port="data" place="data"/>

    </transition>
    <place name="web_copy" type="string"/>

    <transition name="compute_size">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="library_name" type="string"/>
        <in name="base_filename" type="string"/>
        <in name="web_copy" type="string"/>
        <out name="total" type="int"/>

        <out name="myvec" type="string"/>

        <module name="singular_template" require_function_unloads_without_rest="false" function="compute_size(total,myvec,web_copy,library_name,base_filename)">
          <cinclude href="interface/template_interface.hpp" />
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            
         using vector = std::vector<int>;
  using vector2d = std::vector<vector>;
  vector2d vec;

int nLayers = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(web_copy, library_name, base_filename);
int count=0;
for (int j = 1; j <= nLayers; j++) {

  vector v;
    std::string web_copy_j = RESOLVE_INTERFACE_FUNCTION(singular_Return_place)(
        web_copy, j, library_name, base_filename);

    int nSectors = RESOLVE_INTERFACE_FUNCTION(singular_size_gpi)(
        web_copy_j, library_name, base_filename);

    for (int k = 1; k <= nSectors; k++) {
        v.push_back(j);
        v.push_back(k);
        count+=1;
    }
      vec.push_back(v);
}
total=count;
std::cout<<"total="<<total<<std::endl;
 /* std::cout << "vec before = " << std::endl;
    for (const auto& inner_vec : vec) {
        for (int vi : inner_vec) {
            std::cout << vi << " ";
        }
        std::cout << std::endl;
    }  */

 myvec = RESOLVE_INTERFACE_FUNCTION(vector2dToString)(vec);
                       ]]>
                </code>
        </module>
      </defun>
        <connect-read port="library_name" place="place_library_name"/>
      <connect-read port="base_filename" place="place_base_filename"/>
      <connect-in port="web_copy" place="web_copy"/>
      
      <connect-out port="myvec" place="myvec"/>
      <connect-out port="total" place="total"/>
    </transition>

    <place name="labeledgraph" type="string"/>
    <place name="myvec" type="string"/>
    <place name="total" type="int"/>

   

    <place name="mi_ibp" type="feynman"/>
    <place name="data_copy" type="feynman"/>

  <place name="number" type="control"/>

<place name="counting" type="int">
      <token>
        <value>0</value>
      </token>
    </place>


  </net>
</defun>