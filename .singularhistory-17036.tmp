;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeManyIBP(G,targetInt);
S;
size(S);
  size(S.IBP);  
  setIBP SS=computeManyIBP(G,top);
  list top = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1));
  setIBP SS=computeManyIBP(G,top);
  size(SS.IBP);  
  size(SS.IBP);  
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  
  list w2=updateWeb(web,list(1,1),L1[1]); //up
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
 list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web
  list L=pickHighestSector(setInt);
  size(L);
$
LIB "feynman.lib";
  list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web
  list L=pickHighestSector(setInt);
  size(L);
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  list w2=updateWeb(web,list(1,1),L1[1]); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web
web=w2[1]; 
  setIBP S=computeIBP(G1,L1[1][1]);
  ring R=S.over;
setring R;
  list L=getRedIBPs(S,101); //L[1]=list of independent IBPs,L[2]=list of master integrals
  list independIBPs=L[1];
  list masterAndTailIntgrals=L[2];
  size(independIBPs) < size(S.IBP); //number of linearly independent set of IBPs are less than the number of orginal IBPs. So this returns true
  list w2=updateWeb(web,list(1,1),masterAndTailIntgrals);
w2[1];
w2[1][2][1];
w2[1][2][1].targetInts;
w2[1][2][1].targetInts;$
$
LIB "feynman.lib";
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list finalset=getReducedIBPSystem(G,targetInt);
$
LIB "feynman.lib";
  list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
   // L[1] is the list of target integrals belong to one integral family but it has arranged so that.. 
   //..L[1][1] is the integral belong to the superior sector.
  // we use this seed (i.e. target integral) to create the web structure 
  //When we do computation sequentially, it is better to have web structure of the sectors upfront.
  //We denote it by a list web, where web[i] contains the s