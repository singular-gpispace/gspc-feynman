///////////////////////////////////////
version = "version templategspc.lib 0.2 Mar_2024 ";
category = "Algebraic geometry";
info = "
LIBRARY: templategspc.lib  template library for  GPI - Space interface on Singular

OVERVIEW :
This library contains SINGULAR template procedures for a Singular / GPI - Space framework containing 2 places and 1 transition.

TYPES :
    configToken          general configuration token type
    gspcConfigToken      configuration token for GPI - Space
    templateConfigToken  configuration token for the transition procedure

    PROCEDURES :
configure_gspc()                               generates standard config token for GPI - Space
configure_template()                           generates standard config token for the transition procedure
generateIOTokenTypes(configToken)              register the user - defined types for input and output
gspc_template(list, configToken, configToken)    interface of the template framework in Singular
";



proc mod_init()
{
    string libpath = system("getenv", "GSPC_FEYNMAN_INSTALL_DIR");
    if (libpath == "")
    {
        ERROR("GSPC_FEYNMAN_INSTALL_DIR environment variable not set");
    }
    string module_path = libpath + "/libSINGULAR-template-module.so";
    LIB(module_path);

    newstruct("configToken", "string tokentype, def options");
    newstruct("gspcConfigToken", "string tmpdir, string nodefile, int procspernode, string rifstrategy, string rifstrategyparameters, string loghost, int logport, string loghostfile");
    newstruct("templateConfigToken", " string neededLibrary, string functionName");
    newstruct("token", "list fieldnames, list data");
    //newstruct("Toknlift", "vector a, vector b"); 

    newstruct("graph", "list vertices, list edges");
    newstruct("labeledgraph", "list vertices, list edges, ring over, list labels, ring overpoly, list elimvars, ring baikovover, matrix baikovmatrix");
    newstruct("Net", "list rows");
    newstruct("oneIBP", "list c, list i");
    newstruct("setIBP", "ring over,list seed,list IBP");
    newstruct("oneSector", "list lab, list sectorMap ,list targetInts ");
}

proc configure_gspc()
"USAGE: configure_gspc()
RETURN: a configToken containing a gspcConfigToken with the standard configuration for GPI - Space
"
{
    gspcConfigToken gc;
    gc.rifstrategy = "ssh";
    gc.tmpdir = system("getenv", "GSPC_FEYNMAN_INSTALL_DIR") + "/temp";
    gc.nodefile = system("getenv", "software_ROOT") + "/nodefile";
    configToken ct;
    ct.tokentype = "gspcConfigToken";
    ct.options = gc;
    return(ct);
}
proc configure_template()
{
    templateConfigToken tc;
    configToken ct;
    ct.tokentype = "templateConfigToken";
    ct.options = tc;

    // Set redSB option to true
    option(redSB);

    return(ct);
}

static proc gspc_template(list l, configToken gc, configToken pc)
{
    //Parse driver options
    string driver_opts;
    if ((typeof(gc.options) != "gspcConfigToken") || (typeof(pc.options) != "templateConfigToken"))
    {
        ERROR("wrong config token types");
    }

    //Parse rifstrategy and rifstrategy-parameters
    driver_opts = driver_opts + "--rif-strategy " + gc.options.rifstrategy;
    if (gc.options.rifstrategyparameters != "")
    {
        driver_opts = driver_opts + " --rif-strategy-parameters " + gc.options.rifstrategyparameters;
    }

    //Parse worker topology
    driver_opts = driver_opts + " --topology " + "worker:" + string(gc.options.procspernode);

    //Parse nodefile
    driver_opts = driver_opts + " --nodefile " + gc.options.nodefile;

    //Parser loghost and logport
    if (gc.options.logport != 0) // logging requested
    {
        if (gc.options.loghost == "") // no hostname given, so read from file
        {
            if (gc.options.loghostfile == "")
            {
                ERROR("logging requested, no loghost and no loghostfile given");
            }
            string loghost = read(gc.options.loghostfile);
            if ((loghost == "") || (loghost == newline))
            {
                ERROR("no hostname in loghostfile");
            }
            if (loghost[size(loghost)] == newline) // delete trailing LF
            {
                loghost = loghost[1..(size(loghost) - 1)];
            }
            gc.options.loghost = loghost;
        }
        driver_opts = driver_opts + " --log-host " + gc.options.loghost + " --log-port " + string(gc.options.logport);
    }

    if (system("getenv", "LD_LIBRARY_PATH") != "")
    {
        driver_opts = driver_opts + " --worker-env-copy-variable " + "LD_LIBRARY_PATH";
    }

    //Starting to parse workflow options
    string workflow_opts;

    //Parse basefilename
    string tmpdir = gc.options.tmpdir;
    if (tmpdir == "")
    {
        ERROR("tmpdir is not set in configuration");
    }
    if (tmpdir[1] != "/")
    {
        tmpdir = system("getenv", "PWD") + "/" + tmpdir;
    }
    // Ensure tmpdir ends with a single slash
    if (tmpdir[size(tmpdir)] != "/")
    {
        tmpdir = tmpdir + "/";
    }
    workflow_opts = workflow_opts + " --basefilename " + tmpdir;

    //Parse input
    link lin;
    int N = 1;
    for (int i = 1; i <= N; i++)
    {
        string input_file = tmpdir + "input";
        lin = "ssi:w " + input_file;
        write(lin, l[i]);
        close(lin);
    }
    workflow_opts = workflow_opts + " --input " + "input";

    //Parse libraryname
    string loadlib = pc.options.neededLibrary;
    if (loadlib == "")
    {
        ERROR("neededLibrary is not set in configuration");
    }
    if (loadlib[1] != "/")
    {
        loadlib = system("getenv", "PWD") + "/" + loadlib;
    }
    workflow_opts = workflow_opts + " --libraryname " + loadlib;

    string all_opts = driver_opts + " " + workflow_opts;
    def sm_result = sggspc_template(all_opts);

    return(sm_result);
}

proc gspc_feynman(list L, configToken gc)
{
    if (size(L) < 3)
    {
        ERROR("Input list must contain at least 3 elements: vertices, edges, and targetInt");
    }
    
    configToken ct = configure_template();
    ct.options.neededLibrary = "templategp.lib";
    ct.options.functionName = "stdBasis";

    list inputlists;
    token t;

    t.fieldnames = list("generators", "Input101");
    //  L is a list containing the input data
    for (int i = 1; i <= size(L); i++) {
        t.data[i] = L[i];
    }
    inputlists[1] = t;

    // Verify configuration
    if (typeof(gc.options) != "gspcConfigToken")
    {
        ERROR("Invalid configuration token type for GPI-Space");
    }
    if (gc.options.tmpdir == "")
    {
        ERROR("tmpdir not set in GPI-Space configuration");
    }
    if (gc.options.nodefile == "")
    {
        ERROR("nodefile not set in GPI-Space configuration");
    }

    def re = gspc_template(inputlists, gc, ct);
    def inputRing = basering;
    def resultToken = re[1];
    return(resultToken);
}