;
LIB "feynman.lib";
$
$
LIB "feynman.lib";
LIB "feynman.lib";
$
LIB "feynman.lib";
 list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  for(int j=1; j <= 1; j++)
    {
      int nSectors=size(web[j]);
      for(int k=1; k <= 1; k++)
      {
        
        if(size(web[j][k].targetInts)>=1)
        {
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            reducedIBPs.over=totalIBP.over;
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
          list L=getRedIBPs(totalIBP,101);   
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
// update reducedIBPs. 
          setring R;
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
          }
    kill R;
//Update the sectors below to the current sector using masterAndTailIntgrals. In this step, we can also.. 
//..distingush the master integrals which will be assigned to MI.
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
         print("w[2]=",w2);
;
;
;
;
;
;
;
;l
;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  for(int j=1; j <= 1; j++)
    {
      int nSectors=size(web[j]);
      for(int k=1; k <= 1; k++)
      {
        
        if(size(web[j][k].targetInts)>=1)
        {
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            reducedIBPs.over=totalIBP.over;
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
          list L=getRedIBPs(totalIBP,101);   
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
// update reducedIBPs. 
          setring R;
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
          }
    kill R;
//Update the sectors below to the current sector using masterAndTailIntgrals. In this step, we can also.. 
//..distingush the master integrals which will be assigned to MI.
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
         print("w[2]=",w2);
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
x
:
:
:
LIB "feynman.lib";
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
int j=1;
      int nSectors=size(web[j]);
   int k=1;
        
        if(size(web[j][k].targetInts)>=1)
        {
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            reducedIBPs.over=totalIBP.over;
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
          list L=getRedIBPs(totalIBP,101);   
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
// update reducedIBPs. 
          setring R;
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
          }
    kill R;
//Update the sectors below to the current sector using masterAndTailIntgrals. In this step, we can also.. 
//..distingush the master integrals which will be assigned to MI.
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
         print("w[2]=",w2);
$
$
$
q
LIB "feynman.lib";
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }


  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);

  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];

  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  

  int j=1;

      int nSectors=size(web[j]);
   int k=1;
        
        if(size(web[j][k].targetInts)>=1)
        {
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            reducedIBPs.over=totalIBP.over;
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
          list L=getRedIBPs(totalIBP,101);   
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
  
          setring R;
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];

            }
          }
           kill R;


          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
         print("w[2]=",w2);
;
;
;
;
;
;
;
;
;
;
;:
;m
