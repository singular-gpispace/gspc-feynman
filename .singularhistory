;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeManyIBP(G,targetInt);
S;
size(S);
  size(S.IBP);  
  setIBP SS=computeManyIBP(G,top);
  list top = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1));
  setIBP SS=computeManyIBP(G,top);
  size(SS.IBP);  
  size(SS.IBP);  
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  
  list w2=updateWeb(web,list(1,1),L1[1]); //up
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
 list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web
  list L=pickHighestSector(setInt);
  size(L);
$
LIB "feynman.lib";
  list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web
  list L=pickHighestSector(setInt);
  size(L);
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  list w2=updateWeb(web,list(1,1),L1[1]); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web
web=w2[1]; 
  setIBP S=computeIBP(G1,L1[1][1]);
  ring R=S.over;
setring R;
  list L=getRedIBPs(S,101); //L[1]=list of independent IBPs,L[2]=list of master integrals
  list independIBPs=L[1];
  list masterAndTailIntgrals=L[2];
  size(independIBPs) < size(S.IBP); //number of linearly independent set of IBPs are less than the number of orginal IBPs. So this returns true
  list w2=updateWeb(web,list(1,1),masterAndTailIntgrals);
w2[1];
w2[1][2][1];
w2[1][2][1].targetInts;
w2[1][2][1].targetInts;$
$
LIB "feynman.lib";
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list finalset=getReducedIBPSystem(G,targetInt);
$
LIB "feynman.lib";
  list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
   // L[1] is the list of target integrals belong to one integral family but it has arranged so that.. 
   //..L[1][1] is the integral belong to the superior sector.
  // we use this seed (i.e. target integral) to create the web structure 
  //When we do computation sequentially, it is better to have web structure of the sectors upfront.
  //We denote it by a list web, where web[i] contains the sectors belong to that layer.
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  //After creating the web, we have to update it by including the target integrals to the corresponding sectors
  //Because, when we do the intended computation in sectors, we read seeds from this updated 
  //This update step need to perform with tail integrals of each sector, once the computations correspond to sectors in each layer are done. 
  //If the computation done correctly, tail integrals will only be assigned to the sectors in the below layers.
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  // *this return a list w4, where w4[1] is the updated web and
  // w4[2] is the list of integrals that does not belong to the current web (if any have. usually dont!) 
  // We set two places to store reduced IBP relations (a setIBP), and master integrals (a list) that are comes from..
  //..the intended computations relevent to each sector   
  
  //before we go further,we first create the labelled graph G1 of G computing Baikov matrix
  
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  int nLayers=1;
  for(int j=1; j <= nLayers; j++)
    {
//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.
    //  int nSectors=size(web[j]);
      int nSectors=1;
      for(int k=1; k <= nSectors; k++)
      {
        
        if(size(web[j][k].targetInts)>=1)
        {
          print("size(web[j][k].targetInts)");
          print(size(web[j][k].targetInts));
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
;
;
;
 link l="ssi:r temp/waas_1599879_1739453089801077133";
 def m=read(l);
 m.r_data;
 def nr=m.r_data;
 setring nr;
 m.data[1];
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
;
;
;
;
;
;
;
;
;
;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
L;
L[1];
size(L[1]);
size(L[2]);
size(L[3]);
size(L);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  print("Z");
  print(Z);  
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
  setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  print("Z[4]="+string(Z[4]));
  print("ncols(Z[1])="+string(ncols(Z[1])));
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
  setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  print("Z[4]="+string(Z[4]));
  print("ncols(Z[1])="+string(ncols(Z[1])));
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  print("ncols(Z[3])="+string(ncols(Z[3])));
  print("nrows(Z[3])="+string(nrows(Z[3])));
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
  setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  print("Z[4]="+string(Z[4]));
  print("ncols(Z[1])="+string(ncols(Z[1])));
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  print("ncols(Z[3])="+string(ncols(Z[3])));
  print("nrows(Z[3])="+string(nrows(Z[3])));
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
print("l="+string(l));
  }
  return(list(indIBP,seed));
}
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
  setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  print("Z[4]="+string(Z[4]));
  print("ncols(Z[1])="+string(ncols(Z[1])));
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  print("ncols(Z[3])="+string(ncols(Z[3])));
  print("nrows(Z[3])="+string(nrows(Z[3])));
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
print("size(seed)="+string(size(seed)));
  return(list(indIBP,seed));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
  setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
L;
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
print("web=w4[1]"); 
print(web);
print(" ");
 
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  int nLayers=1;
int j=1;
//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.
    //  int nSectors=size(web[j]);
      int nSectors=1;
int k=1;
        
  
          print("size(web[j][k].targetInts)");
          print(size(web[j][k].targetInts));
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            print("totalIBP.over");
            print(totalIBP.over);
            reducedIBPs.over=totalIBP.over;
            print("reducedIBPs.over After");
            print(reducedIBPs.over);
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
//using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
          list L=getRedIBPs(totalIBP,101);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
L[2];
 print("masterAndTailIntgrals");
          print(masterAndTailIntgrals);
// update reducedIBPs. 
          setring R;
          print("size(reducedIBPs.IBP)");
          print(size(reducedIBPs.IBP));
          
  if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
            print("reducedIBPs.IBP_Before");
            print(size(reducedIBPs.IBP));
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
            print("reducedIBPs.IBP_After");
            print(size(reducedIBPs.IBP));
          }
    kill R;
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
w;
web;
masterAndTailIntgrals
;
w;
LIB "feynman.lib";
//Better to check that the provided integrals belong to the same integral family
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  print("web=w4[1]"); 
  print(web);
  print(" ");
 
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  int nLayers=1;
int j=1;
//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.
    //  int nSectors=size(web[j]);
      int nSectors=1;
int k=1;
        
  
          print("size(web[j][k].targetInts)");
          print(size(web[j][k].targetInts));
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            print("totalIBP.over");
            print(totalIBP.over);
            reducedIBPs.over=totalIBP.over;
            print("reducedIBPs.over After");
            print(reducedIBPs.over);
            te=te+1;
          }
         ring R=reducedIBPs.over;
  //Better to check that the provided integrals belong to the same integral family
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  print("web=w4[1]"); 
  print(web);
  print(" ");
 
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  int nLayers=1;
int j=1;
//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.
    //  int nSectors=size(web[j]);
      int nSectors=1;
int k=1;
        
  
          print("size(web[j][k].targetInts)");
          print(size(web[j][k].targetInts));
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            print("totalIBP.over");
            print(totalIBP.over);
            reducedIBPs.over=totalIBP.over;
            print("reducedIBPs.over After");
            print(reducedIBPs.over);
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
//using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
          list L=getRedIBPs(totalIBP,101);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
          print("masterAndTailIntgrals");
          print(masterAndTailIntgrals);
// update reducedIBPs. 
          setring R;
          print("size(reducedIBPs.IBP)");
          print(size(reducedIBPs.IBP));
          
          print(size(masterAndTailIntgrals));
 if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
            print("reducedIBPs.IBP_Before");
            print(size(reducedIBPs.IBP));
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
            print("reducedIBPs.IBP_After");
            print(size(reducedIBPs.IBP));
          }
    kill R;
list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
          print("size(web[j][k].targetInts) after updateweb");
          print(size(web[j][k].targetInts));
          print("w[2]=");
          print(w[2]);
          list masterIntgralsInSector=w[2];
          if(size(MI)==0)
          { 
            MI=masterIntgralsInSector;
          }
          else
          {
            for(int i=1;i <= size(masterIntgralsInSector);i++)
            {
              if(alreadyIntheList(MI,masterIntgralsInSector[i])==0)
              {
                MI[size(MI)+1]=masterIntgralsInSector[i];
              }
                //MI[size(MI)+1]=masterIntgralsInSector[i];
            }
          }
list targetInt = list(list(1,2,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  print("web=w4[1]"); 
  print(web);
  print(" ");
 
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  int nLayers=1;
int j=1;
//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.
    //  int nSectors=size(web[j]);
      int nSectors=1;
int k=1;
        
  
          print("size(web[j][k].targetInts)");
          print(size(web[j][k].targetInts));
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            print("totalIBP.over");
            print(totalIBP.over);
            reducedIBPs.over=totalIBP.over;
            print("reducedIBPs.over After");
            print(reducedIBPs.over);
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
//using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
          list L=getRedIBPs(totalIBP,101);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
          print("size of masterAndTailIntgrals");
          print(size(masterAndTailIntgrals));
// update reducedIBPs. 
          setring R;
          print("size(reducedIBPs.IBP)");
          print(size(reducedIBPs.IBP));
          
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
            print("reducedIBPs.IBP_Before");
            print(size(reducedIBPs.IBP));
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
            print("reducedIBPs.IBP_After");
            print(size(reducedIBPs.IBP));
          }
    kill R;
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  
list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  print("web=w4[1]"); 
  print(web);
  print(" ");
 
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  int nLayers=1;
int j=1;
//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.
    //  int nSectors=size(web[j]);
      int nSectors=1;
int k=1;
        
  
          print("size(web[j][k].targetInts)");
          print(size(web[j][k].targetInts));
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            print("totalIBP.over");
            print(totalIBP.over);
            reducedIBPs.over=totalIBP.over;
            print("reducedIBPs.over After");
            print(reducedIBPs.over);
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
//using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
          list L=getRedIBPs(totalIBP,101);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
          print("size of masterAndTailIntgrals");
          print(size(masterAndTailIntgrals));
// update reducedIBPs. 
          setring R;
          print("size(reducedIBPs.IBP)");
          print(size(reducedIBPs.IBP));
          
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
            print("reducedIBPs.IBP_Before");
            print(size(reducedIBPs.IBP));
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
            print("reducedIBPs.IBP_After");
            print(size(reducedIBPs.IBP));
          }
    kill R;
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  print("web=w4[1]"); 
  print(web);
  print(" ");
 
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  int nLayers=1;
int j=1;
//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.
    //  int nSectors=size(web[j]);
      int nSectors=1;
int k=1;
        
  
          print("size(web[j][k].targetInts)");
          print(size(web[j][k].targetInts));
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            print("totalIBP.over");
            print(totalIBP.over);
            reducedIBPs.over=totalIBP.over;
            print("reducedIBPs.over After");
            print(reducedIBPs.over);
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
//using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
          list L=getRedIBPs(totalIBP,101);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
          print("size of masterAndTailIntgrals");
          print(size(masterAndTailIntgrals));
// update reducedIBPs. 
          setring R;
          print("size(reducedIBPs.IBP)");
          print(size(reducedIBPs.IBP));
          
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
            print("reducedIBPs.IBP_Before");
            print(size(reducedIBPs.IBP));
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
            print("reducedIBPs.IBP_After");
            print(size(reducedIBPs.IBP));
          }
    kill R;
$
LIB "feynman.lib";
  //Better to check that the provided integrals belong to the same integral family
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  print("web=w4[1]"); 
  print(web);
  print(" ");
 
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  int nLayers=1;
int j=1;
//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.
    //  int nSectors=size(web[j]);
      int nSectors=1;
int k=1;
        
  
          print("size(web[j][k].targetInts)");
          print(size(web[j][k].targetInts));
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            print("totalIBP.over");
            print(totalIBP.over);
            reducedIBPs.over=totalIBP.over;
            print("reducedIBPs.over After");
            print(reducedIBPs.over);
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
//using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
          list L=getRedIBPs(totalIBP,101);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
          list indpndIBP=L[1];
          print(" size of indpndIBP"+string(size(indpndIBP)));
          print(" size of indpndIBP"+" "+string(size(indpndIBP)));
  list masterAndTailIntgrals=L[2];
          print("size of masterAndTailIntgrals");
          print(size(masterAndTailIntgrals));
 setring R;
          print("size(reducedIBPs.IBP)");
          print(size(reducedIBPs.IBP));
          
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
            print("reducedIBPs.IBP_Before");
            print(size(reducedIBPs.IBP));
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
            print("reducedIBPs.IBP_After");
            print(size(reducedIBPs.IBP));
          }
    kill R;
//Update the sectors below to the current sector using masterAndTailIntgrals. In this step, we can also.. 
//..distingush the master integrals which will be assigned to MI.
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
          print("size(web[j][k].targetInts) after updateweb");
          print(size(web[j][k].targetInts));
          print(" size of w[2]=");
          print(size(w[2]));
          list masterIntgralsInSector=w[2];
          print("size of masterIntgralsInSector " + string(size(masterIntgralsInSector)));
 if(size(MI)==0)
          { 
            MI=masterIntgralsInSector;
          }
          else
          {
            for(int i=1;i <= size(masterIntgralsInSector);i++)
            {
              if(alreadyIntheList(MI,masterIntgralsInSector[i])==0)
              {
                MI[size(MI)+1]=masterIntgralsInSector[i];
              }
                //MI[size(MI)+1]=masterIntgralsInSector[i];
            }
          }
size(MI);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  //list targetInt=list(list(1,2,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5),list(0,1,1,1,1,1,1,-5,0),list(1,0,1,1,1,1,1,0,-5),list(1,1,0,1,1,1,1,-5,0),list(1,1,1,0,1,1,1,0,-5),list(1,1,1,1,0,1,1,-5,0),list(1,1,1,1,1,0,1,0,-5),list(1,1,1,1,1,1,0,-5,0),list(0,1,1,1,1,1,1,0,-5),list(1,0,1,1,1,1,1,-5,0),list(1,1,0,1,1,1,1,0,-5),list(1,1,1,0,1,1,1,-5,0),list(1,1,1,1,0,1,1,0,-5),list(1,1,1,1,1,0,1,-5,0),list(1,1,1,1,1,1,0,0,-5));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0));
  list finalset=getReducedIBPSystem(G,targetInt);
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  //list targetInt=list(list(1,2,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5),list(0,1,1,1,1,1,1,-5,0),list(1,0,1,1,1,1,1,0,-5),list(1,1,0,1,1,1,1,-5,0),list(1,1,1,0,1,1,1,0,-5),list(1,1,1,1,0,1,1,-5,0),list(1,1,1,1,1,0,1,0,-5),list(1,1,1,1,1,1,0,-5,0),list(0,1,1,1,1,1,1,0,-5),list(1,0,1,1,1,1,1,-5,0),list(1,1,0,1,1,1,1,0,-5),list(1,1,1,0,1,1,1,-5,0),list(1,1,1,1,0,1,1,0,-5),list(1,1,1,1,1,0,1,-5,0),list(1,1,1,1,1,1,0,0,-5));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0));
  list finalset=getReducedIBPSystem(G,targetInt);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  //list targetInt=list(list(1,2,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5),list(0,1,1,1,1,1,1,-5,0),list(1,0,1,1,1,1,1,0,-5),list(1,1,0,1,1,1,1,-5,0),list(1,1,1,0,1,1,1,0,-5),list(1,1,1,1,0,1,1,-5,0),list(1,1,1,1,1,0,1,0,-5),list(1,1,1,1,1,1,0,-5,0),list(0,1,1,1,1,1,1,0,-5),list(1,0,1,1,1,1,1,-5,0),list(1,1,0,1,1,1,1,0,-5),list(1,1,1,0,1,1,1,-5,0),list(1,1,1,1,0,1,1,0,-5),list(1,1,1,1,1,0,1,-5,0),list(1,1,1,1,1,1,0,0,-5));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0));
  list finalset=getReducedIBPSystem(G,targetInt);
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  //list targetInt=list(list(1,2,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5),list(0,1,1,1,1,1,1,-5,0),list(1,0,1,1,1,1,1,0,-5),list(1,1,0,1,1,1,1,-5,0),list(1,1,1,0,1,1,1,0,-5),list(1,1,1,1,0,1,1,-5,0),list(1,1,1,1,1,0,1,0,-5),list(1,1,1,1,1,1,0,-5,0),list(0,1,1,1,1,1,1,0,-5),list(1,0,1,1,1,1,1,-5,0),list(1,1,0,1,1,1,1,0,-5),list(1,1,1,0,1,1,1,-5,0),list(1,1,1,1,0,1,1,0,-5),list(1,1,1,1,1,0,1,-5,0),list(1,1,1,1,1,1,0,0,-5));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0));
  list finalset=getReducedIBPSystem(G,targetInt);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  //list targetInt=list(list(1,2,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5),list(0,1,1,1,1,1,1,-5,0),list(1,0,1,1,1,1,1,0,-5),list(1,1,0,1,1,1,1,-5,0),list(1,1,1,0,1,1,1,0,-5),list(1,1,1,1,0,1,1,-5,0),list(1,1,1,1,1,0,1,0,-5),list(1,1,1,1,1,1,0,-5,0),list(0,1,1,1,1,1,1,0,-5),list(1,0,1,1,1,1,1,-5,0),list(1,1,0,1,1,1,1,0,-5),list(1,1,1,0,1,1,1,-5,0),list(1,1,1,1,0,1,1,0,-5),list(1,1,1,1,1,0,1,-5,0),list(1,1,1,1,1,1,0,0,-5));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0));
  list finalset=getReducedIBPSystem(G,targetInt);
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  //list targetInt=list(list(1,2,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5),list(0,1,1,1,1,1,1,-5,0),list(1,0,1,1,1,1,1,0,-5),list(1,1,0,1,1,1,1,-5,0),list(1,1,1,0,1,1,1,0,-5),list(1,1,1,1,0,1,1,-5,0),list(1,1,1,1,1,0,1,0,-5),list(1,1,1,1,1,1,0,-5,0),list(0,1,1,1,1,1,1,0,-5),list(1,0,1,1,1,1,1,-5,0),list(1,1,0,1,1,1,1,0,-5),list(1,1,1,0,1,1,1,-5,0),list(1,1,1,1,0,1,1,0,-5),list(1,1,1,1,1,0,1,-5,0),list(1,1,1,1,1,1,0,0,-5));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0));
  list finalset=getReducedIBPSystem(G,targetInt);
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  //list targetInt=list(list(1,2,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5),list(0,1,1,1,1,1,1,-5,0),list(1,0,1,1,1,1,1,0,-5),list(1,1,0,1,1,1,1,-5,0),list(1,1,1,0,1,1,1,0,-5),list(1,1,1,1,0,1,1,-5,0),list(1,1,1,1,1,0,1,0,-5),list(1,1,1,1,1,1,0,-5,0),list(0,1,1,1,1,1,1,0,-5),list(1,0,1,1,1,1,1,-5,0),list(1,1,0,1,1,1,1,0,-5),list(1,1,1,0,1,1,1,-5,0),list(1,1,1,1,0,1,1,0,-5),list(1,1,1,1,1,0,1,-5,0),list(1,1,1,1,1,1,0,0,-5));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0));
  list finalset=getReducedIBPSystem(G,targetInt);
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  //list targetInt=list(list(1,2,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5),list(0,1,1,1,1,1,1,-5,0),list(1,0,1,1,1,1,1,0,-5),list(1,1,0,1,1,1,1,-5,0),list(1,1,1,0,1,1,1,0,-5),list(1,1,1,1,0,1,1,-5,0),list(1,1,1,1,1,0,1,0,-5),list(1,1,1,1,1,1,0,-5,0),list(0,1,1,1,1,1,1,0,-5),list(1,0,1,1,1,1,1,-5,0),list(1,1,0,1,1,1,1,0,-5),list(1,1,1,0,1,1,1,-5,0),list(1,1,1,1,0,1,1,0,-5),list(1,1,1,1,1,0,1,-5,0),list(1,1,1,1,1,1,0,0,-5));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0));
  list finalset=getReducedIBPSystem(G,targetInt);
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
 
  list finalset=getReducedIBPSystem(G,targetInt);
Singular
;
LIB "feynman.lib";
$
LIB "feynman.lib";
$
LIB "feynman.lib";
$
LIB "feynman.lib";
graph G = makeGraph(
  list(1,2,3,4,5,6), 
  list(
      list(6,1), list(4,6), list(1,2), list(3,5), 
      list(4,3), list(2,5), list(5,6), list(1), 
      list(2), list(3), list(4)
  )
);
// Define a list of target integrals
list targetInt = list(
  list(1, 1, 1, -1, -3, 1, -1, -1, -1), 
  list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
    if (size(targetInt) == 0) {
        ERROR("Empty target integral list provided.");
    }
    // Debug: Ensure the input graph G and target integrals are correctly passed
    print("Graph G: " + string(G));
    print("Target Integrals: " + string(targetInt));
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
    web = setSectorMap(web);
    print("Generated web: " + string(web));
    list w4 = updateWeb(web, list(1,1), targetInt);
    web = w4[1];
    print("Size of updated web: " + string(size(web)));
    labeledgraph G1 = computeBaikovMatrix(G);
    setIBP reducedIBPs;
    list MI;
    print("Size of targetInt: " + string(size(targetInt)));
    int te = 0;
    reducedIBPs.seed = targetInt;
    int j = 1;
    if (size(web) < j) {
        ERROR("Web list does not contain layer j=" + string(j));
    }
    int nSectors = size(web[j]);
    if (nSectors == 0) {
        ERROR("No sectors available in web[" + string(j) + "]");
    }
    int k = 1;
    if (size(web[j]) < k) {
        ERROR("Web[" + string(j) + "] does not contain sector k=" + string(k));
    }
    print("Computing IBP for sector: " + string(web[j][k].targetInts));
    setIBP totalIBP = computeManyIBP(G1, web[j][k].targetInts);
    print("Size of totalIBP.IBP: " + string(size(totalIBP.IBP)));
    if (te == 0) {
        reducedIBPs.over = totalIBP.over;
        te = 1;
    }
    if (reducedIBPs.over == 0) {
        ERROR("totalIBP.over is not initialized correctly.");
    }
    ring R = reducedIBPs.over;
    setring R;
    list L = getRedIBPs(totalIBP, 101);
    if (size(L) < 2) {
        ERROR("getRedIBPs did not return expected two lists.");
    }
    list indpndIBP = L[1];
    print("Size of indpndIBP: " + string(size(indpndIBP)));
    list masterAndTailIntgrals = L[2];
    print("Size of masterAndTailIntgrals: " + string(size(masterAndTailIntgrals)));
    if (size(reducedIBPs.IBP) == 0) {
        reducedIBPs.IBP = indpndIBP;
    } else {
        for (int i = 1; i <= size(indpndIBP); i++) {
            reducedIBPs.IBP[size(reducedIBPs.IBP) + 1] = indpndIBP[i];
        }
    }
    kill R;
    print("Size of masterAndTailIntgrals = " + string(size(masterAndTailIntgrals)));
    list w = updateWeb(web, list(j, k), masterAndTailIntgrals);
    web = w[1];
    print("w[2] = " + string(w[2])); // Fixed debug message
    list masterIntgralsInSector = w[2];
    print("Size of masterIntgralsInSector = " + string(size(masterIntgralsInSector)));
    if (size(MI) == 0) {
        MI = masterIntgralsInSector;
    } else {
        for (int i = 1; i <= size(masterIntgralsInSector); i++) {
            if (alreadyIntheList(MI, masterIntgralsInSector[i]) == 0) {
                MI[size(MI) + 1] = masterIntgralsInSector[i];
            }
        }
    }
    print("Completed computation in sector: " + string(k) + " at layer " + string(j) + ".");
reducedIBPs.IBP;
reducedIBPs.IBP[1];
reducedIBPs.IBP[1].c;
reducedIBPs.IBP[1].i;
reducedIBPs.IBP[1].i;$
// Helper procedure to compare two integer lists for equality
proc eq_int_list(list a, list b) {
    if (size(a) != size(b)) {
        return(0);
    }
    for (int i = 1; i <= size(a); i++) {
        if (a[i] != b[i]) {
            return(0);
        }
    }
    return(1);
}
// Helper procedure to merge two lists of integer vectors, removing duplicates
proc merge_int_vectors(list A, list B) {
    if (size(A) == 0 && size(B) == 0) {
        return(list());
    }
    list C = A;
    for (int i = 1; i <= size(B); i++) {
        int found = 0;
        for (int j = 1; j <= size(A); j++) {
            if (eq_int_list(A[j], B[i])) {
                found = 1;
                break;
            }
        }
        if (found == 0) {
            C[size(C) + 1] = B[i];
        }
    }
    return(C);
}
// Simplified merge_sector_lists with minimal debugging
proc merge_sector_lists(list A, list B) {
    if (size(A) < 0 || size(B) < 0) {
        print("merge_sector_lists: Error: Negative size detected (A: " + string(size(A)) + ", B: " + string(size(B)) + ")");
        return(list());
    }
    list C = list();
    for (int i = 1; i <= size(A); i++) {
        if (defined(A[i].lab) == 0 || defined(A[i].targetInts) == 0) {
            print("merge_sector_lists: Error: A[" + string(i) + "] missing lab or targetInts");
            return(list());
        }
        C[i] = A[i];
    }
    for (int i = 1; i <= size(B); i++) {
        if (defined(B[i].lab) == 0 || defined(B[i].targetInts) == 0) {
            print("merge_sector_lists: Error: B[" + string(i) + "] missing lab or targetInts");
            return(list());
        }
        int found = 0;
        int idx = 0;
        for (int j = 1; j <= size(A); j++) {
            if (eq_int_list(A[j].lab, B[i].lab)) {
                found = 1;
                idx = j;
                break;
            }
        }
        if (found) {
            C[idx].targetInts = merge_int_vectors(C[idx].targetInts, B[i].targetInts);
        } else {
            C[size(C) + 1] = B[i];
        }
    }
    return(C);
}
// Simplified mergeFeynman
proc mergeFeynman(feynman d1, feynman d2)
"USAGE: mergeFeynman(d1, d2); d1 feynman, d2 feynman
ASSUME: d1 and d2 are feynman structures with compatible rings and web structures.
RETURN: A single feynman structure combining d1 and d2, with IBPs appended without detailed duplicate removal.
KEYWORDS: Feynman graph, merge, IBPs"
{
    feynman out;
    // Basic input validation
    if (size(d1.web) == 0 || size(d2.web) == 0) {
        print("mergeFeynman: Error: One or both webs are empty (d1.web: " + string(size(d1.web)) + ", d2.web: " + string(size(d2.web)) + ")");
        return(out);
    }
    // Merge MI
    out.MI = merge_int_vectors(d1.MI, d2.MI);
    // Set ring
    out.reducedIBPs.over = d1.reducedIBPs.over;
    // Merge seeds
    out.reducedIBPs.seed = merge_int_vectors(d1.reducedIBPs.seed, d2.reducedIBPs.seed);
    // Append IBPs
    out.reducedIBPs.IBP = list();
    int idx = 0;
    for (int i = 1; i <= size(d1.reducedIBPs.IBP); i++) {
        idx = idx + 1;
        out.reducedIBPs.IBP[idx] = d1.reducedIBPs.IBP[i];
    }
    for (int i = 1; i <= size(d2.reducedIBPs.IBP); i++) {
        idx = idx + 1;
        out.reducedIBPs.IBP[idx] = d2.reducedIBPs.IBP[i];
    }
    // Merge web
    out.web = list();
    int layers = min(size(d1.web), size(d2.web));
    for (int i = 1; i <= layers; i++) {
        out.web[i] = merge_sector_lists(d1.web[i], d2.web[i]);
        if (size(out.web[i]) == 0 && (size(d1.web[i]) > 0 || size(d2.web[i]) > 0)) {
            print("mergeFeynman: Warning: Web layer " + string(i) + " merge resulted in empty list");
        }
    }
    return(out);
}
$
LIB "feynman_example.lib";
$
LIB "feynman_example.lib";
$
LIB "feynman_example.lib";
$
LIB "feynman_example.lib";
ring R = (0,t1,t2,D), (z(1..9)), dp;
    ring R = (0,t1,t2,D), (z(1..9)), dp;
// Create first feynman data (data_a)
feynman data_a;
data_a.MI = list(
    list(1, 1, 1, -1, -3, 0, -1, -1, -1),
    list(1, 1, 1, -1, -3, 0, -1, -1, -2)
);
data_a.reducedIBPs.over = R;
data_a.reducedIBPs.seed = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1)
);
data_a.reducedIBPs.IBP = list(
    createIBP(
        list(t1*t2, -t2^2),
        list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
    ),
    createIBP(
        list(2*t1, t2),
        list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
    )
);
data_a.web = list(
    list(
        createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
        createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
    ),
    list(
        createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
        createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
    )
);
// Create second feynman data (data_b)
feynman data_b;
data_b.MI = list(
    list(1, 1, 1, -1, -3, 0, -1, -1, -2),
    list(1, 1, 1, -1, -3, 0, -1, -1, -3)
);
data_b.reducedIBPs.over = R;
data_b.reducedIBPs.seed = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1)
);
data_b.reducedIBPs.IBP = list(
    createIBP(
        list(t1^2, -t1*t2),
        list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
    ),
    createIBP(
        list(t2^2, -t1),
        list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
    )
);
data_b.web = list(
    list(
        createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
        createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
    ),
    list(
        createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
        createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
    )
);
}
// Merge procedures
proc eq_int_list(list a, list b) {
    if (size(a) != size(b)) {
        return(0);
    }
    for (int i = 1; i <= size(a); i++) {
        if (a[i] != b[i]) {
            return(0);
        }
    }
    return(1);
}
proc merge_int_vectors(list A, list B) {
    if (size(A) == 0 && size(B) == 0) {
        return(list());
    }
    list C = A;
    for (int i = 1; i <= size(B); i++) {
        int found = 0;
        for (int j = 1; j <= size(A); j++) {
            if (eq_int_list(A[j], B[i])) {
                found = 1;
                break;
            }
        }
        if (found == 0) {
            C[size(C) + 1] = B[i];
        }
    }
    return(C);
}
$
LIB "feynman_example.lib";
    ring R = (0,t1,t2,D), (z(1..9)), dp;
// Create first feynman data (data_a)
feynman data_a;
data_a.MI = list(
    list(1, 1, 1, -1, -3, 0, -1, -1, -1),
    list(1, 1, 1, -1, -3, 0, -1, -1, -2)
);
data_a.reducedIBPs.over = R;
data_a.reducedIBPs.seed = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1)
);
data_a.reducedIBPs.IBP = list(
    createIBP(
        list(t1*t2, -t2^2),
        list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
    ),
    createIBP(
        list(2*t1, t2),
        list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
    )
);
data_a.web = list(
    list(
        createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
        createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
    ),
    list(
        createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
        createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
    )
);
// Create second feynman data (data_b)
feynman data_b;
data_b.MI = list(
    list(1, 1, 1, -1, -3, 0, -1, -1, -2),
    list(1, 1, 1, -1, -3, 0, -1, -1, -3)
);
data_b.reducedIBPs.over = R;
data_b.reducedIBPs.seed = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1)
);
data_b.reducedIBPs.IBP = list(
    createIBP(
        list(t1^2, -t1*t2),
        list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
    ),
    createIBP(
        list(t2^2, -t1),
        list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
    )
);
data_b.web = list(
    list(
        createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
        createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
    ),
    list(
        createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
        createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
    )
);
}
// Merge procedures
proc eq_int_list(list a, list b) {
    if (size(a) != size(b)) {
        return(0);
    }
    for (int i = 1; i <= size(a); i++) {
        if (a[i] != b[i]) {
            return(0);
        }
    }
    return(1);
}
proc merge_int_vectors(list A, list B) {
    if (size(A) == 0 && size(B) == 0) {
        return(list());
    }
    list C = A;
    for (int i = 1; i <= size(B); i++) {
        int found = 0;
        for (int j = 1; j <= size(A); j++) {
            if (eq_int_list(A[j], B[i])) {
                found = 1;
                break;
            }
        }
        if (found == 0) {
            C[size(C) + 1] = B[i];
        }
    }
    return(C);
}
proc createSector(list lab, list sectorMap, list targetInts) {
    oneSector s;
    s.lab = lab;
    s.sectorMap = sectorMap;
    s.targetInts = targetInts;
    return(s);
}
;
proc createSector(list lab, list sectorMap, list targetInts) {
    oneSector s;
    s.lab = lab;
    s.sectorMap = sectorMap;
    s.targetInts = targetInts;
    return(s);
}
proc createIBP(list coeff, list integrals) {
    oneIBP ibp;
    ibp.c = coeff;
    ibp.i = integrals;
    return(ibp);
}
 ring R = (0,t1,t2,D), (z(1..9)), dp;
// Create first feynman data (data_a)
feynman data_a;
data_a.MI = list(
    list(1, 1, 1, -1, -3, 0, -1, -1, -1),
    list(1, 1, 1, -1, -3, 0, -1, -1, -2)
);
data_a.reducedIBPs.over = R;
data_a.reducedIBPs.seed = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1)
);
data_a.reducedIBPs.IBP = list(
    createIBP(
        list(t1*t2, -t2^2),
        list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
    ),
    createIBP(
        list(2*t1, t2),
        list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
    )
);
data_a.web = list(
    list(
        createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
        createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
    ),
    list(
        createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
        createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
    )
);
// Create second feynman data (data_b)
feynman data_b;
data_b.MI = list(
    list(1, 1, 1, -1, -3, 0, -1, -1, -2),
    list(1, 1, 1, -1, -3, 0, -1, -1, -3)
);
data_b.reducedIBPs.over = R;
data_b.reducedIBPs.seed = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1)
);
data_b.reducedIBPs.IBP = list(
    createIBP(
        list(t1^2, -t1*t2),
        list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
    ),
    createIBP(
        list(t2^2, -t1),
        list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
    )
);
data_b.web = list(
    list(
        createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
        createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
    ),
    list(
        createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
        createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
    )
);
proc eq_int_list(list a, list b) {
    if (size(a) != size(b)) {
        return(0);
    }
    for (int i = 1; i <= size(a); i++) {
        if (a[i] != b[i]) {
            return(0);
        }
    }
    return(1);
}
proc merge_int_vectors(list A, list B) {
    if (size(A) == 0 && size(B) == 0) {
        return(list());
    }
    list C = A;
    for (int i = 1; i <= size(B); i++) {
        int found = 0;
        for (int j = 1; j <= size(A); j++) {
            if (eq_int_list(A[j], B[i])) {
                found = 1;
                break;
            }
        }
        if (found == 0) {
            C[size(C) + 1] = B[i];
        }
    }
    return(C);
}
proc merge_sector_lists(list A, list B) {
    if (size(A) < 0 || size(B) < 0) {
        print("merge_sector_lists: Error: Negative size detected (A: " + string(size(A)) + ", B: " + string(size(B)) + ")");
        return(list());
    }
    list C = list();
    for (int i = 1; i <= size(A); i++) {
        if (defined(A[i].lab) == 0 || defined(A[i].targetInts) == 0) {
            print("merge_sector_lists: Error: A[" + string(i) + "] missing lab or targetInts");
            return(list());
        }
        C[i] = A[i];
    }
    for (int i = 1; i <= size(B); i++) {
        if (defined(B[i].lab) == 0 || defined(B[i].targetInts) == 0) {
            print("merge_sector_lists: Error: B[" + string(i) + "] missing lab or targetInts");
            return(list());
        }
        int found = 0;
        int idx = 0;
        for (int j = 1; j <= size(A); j++) {
            if (eq_int_list(A[j].lab, B[i].lab)) {
                found = 1;
                idx = j;
                break;
            }
        }
        if (found) {
            C[idx].targetInts = merge_int_vectors(C[idx].targetInts, B[i].targetInts);
        } else {
            C[size(C) + 1] = B[i];
        }
    }
    return(C);
}
proc mergeFeynman(feynman d1, feynman d2) {
    feynman out;
    if (size(d1.web) == 0 || size(d2.web) == 0) {
        print("mergeFeynman: Error: One or both webs are empty (d1.web: " + string(size(d1.web)) + ", d2.web: " + string(size(d2.web)) + ")");
        return(out);
    }
    out.MI = merge_int_vectors(d1.MI, d2.MI);
    out.reducedIBPs.over = d1.reducedIBPs.over;
    out.reducedIBPs.seed = merge_int_vectors(d1.reducedIBPs.seed, d2.reducedIBPs.seed);
    out.reducedIBPs.IBP = list();
    int idx = 0;
    for (int i = 1; i <= size(d1.reducedIBPs.IBP); i++) {
        idx = idx + 1;
        out.reducedIBPs.IBP[idx] = d1.reducedIBPs.IBP[i];
    }
    for (int i = 1; i <= size(d2.reducedIBPs.IBP); i++) {
        idx = idx + 1;
        out.reducedIBPs.IBP[idx] = d2.reducedIBPs.IBP[i];
    }
    out.web = list();
    int layers = min(size(d1.web), size(d2.web));
    for (int i = 1; i <= layers; i++) {
        out.web[i] = merge_sector_lists(d1.web[i], d2.web[i]);
        if (size(out.web[i]) == 0 && (size(d1.web[i]) > 0 || size(d2.web[i]) > 0)) {
            print("mergeFeynman: Warning: Web layer " + string(i) + " merge resulted in empty list");
        }
    }
    return(out);
}
feynman merged_ab = mergeFeynman(data_a, data_b);
print("Merged data_a and data_b MI size: " + string(size(merged_ab.MI)));
print("Merged data_a and data_b IBP size: " + string(size(merged_ab.reducedIBPs.IBP)));
print("Merged data_a and data_b web size: " + string(size(merged_ab.web)));
for (int i = 1; i <= size(merged_ab.web); i++) {
    print("Merged web layer " + string(i) + " size: " + string(size(merged_ab.web[i])));
    for (int j = 1; j <= size(merged_ab.web[i]); j++) {
        print("  Sector " + string(j) + " lab: " + string(merged_ab.web[i][j].lab));
        print("  Sector " + string(j) + " targetInts size: " + string(size(merged_ab.web[i][j].targetInts)));
    }
}
proc mergeFeynman(feynman d1, feynman d2) {
    feynman out;
    if (size(d1.web) == 0 || size(d2.web) == 0) {
        print("mergeFeynman: Error: One or both webs are empty (d1.web: " + string(size(d1.web)) + ", d2.web: " + string(size(d2.web)) + ")");
        return(out);
    }
    // print("mergeFeynman: Merging MI");
    out.MI = merge_int_vectors(d1.MI, d2.MI);
    out.reducedIBPs.over = d1.reducedIBPs.over;
    // print("mergeFeynman: Merging seeds");
    out.reducedIBPs.seed = merge_int_vectors(d1.reducedIBPs.seed, d2.reducedIBPs.seed);
    out.reducedIBPs.IBP = list();
    int idx = 0;
    for (int i = 1; i <= size(d1.reducedIBPs.IBP); i++) {
        idx = idx + 1;
        out.reducedIBPs.IBP[idx] = d1.reducedIBPs.IBP[i];
    }
    for (int i = 1; i <= size(d2.reducedIBPs.IBP); i++) {
        idx = idx + 1;
        out.reducedIBPs.IBP[idx] = d2.reducedIBPs.IBP[i];
    }
    out.web = list();
    int layers = min(size(d1.web), size(d2.web));
    for (int i = 1; i <= layers; i++) {
        // print("mergeFeynman: Merging web layer " + string(i));
        out.web[i] = merge_sector_lists(d1.web[i], d2.web[i]);
        if (size(out.web[i]) == 0 && (size(d1.web[i]) > 0 || size(d2.web[i]) > 0)) {
            print("mergeFeynman: Warning: Web layer " + string(i) + " merge resulted in empty list");
        }
    }
    // print("mergeFeynman: Merge complete");
    return(out);
}
feynman merged_ab = mergeFeynman(data_a, data_b);
print("Merged data_a and data_b MI size: " + string(size(merged_ab.MI)));
print("Merged data_a and data_b IBP size: " + string(size(merged_ab.reducedIBPs.IBP)));
print("Merged data_a and data_b web size: " + string(size(merged_ab.web)));
proc mergeFeynman(feynman d1, feynman d2) {
    feynman out;
    if (size(d1.web) == 0 || size(d2.web) == 0) {
        print("mergeFeynman: Error: One or both webs are empty (d1.web: " + string(size(d1.web)) + ", d2.web: " + string(size(d2.web)) + ")");
        return(out);
    }
    print("mergeFeynman: Merging MI");
    out.MI = merge_int_vectors(d1.MI, d2.MI);
    out.reducedIBPs.over = d1.reducedIBPs.over;
     print("mergeFeynman: Merging seeds");
    out.reducedIBPs.seed = merge_int_vectors(d1.reducedIBPs.seed, d2.reducedIBPs.seed);
    out.reducedIBPs.IBP = list();
    int idx = 0;
    for (int i = 1; i <= size(d1.reducedIBPs.IBP); i++) {
        idx = idx + 1;
        out.reducedIBPs.IBP[idx] = d1.reducedIBPs.IBP[i];
    }
    for (int i = 1; i <= size(d2.reducedIBPs.IBP); i++) {
        idx = idx + 1;
        out.reducedIBPs.IBP[idx] = d2.reducedIBPs.IBP[i];
    }
    out.web = list();
    int layers = min(size(d1.web), size(d2.web));
    for (int i = 1; i <= layers; i++) {
         print("mergeFeynman: Merging web layer " + string(i));
        out.web[i] = merge_sector_lists(d1.web[i], d2.web[i]);
        if (size(out.web[i]) == 0 && (size(d1.web[i]) > 0 || size(d2.web[i]) > 0)) {
            print("mergeFeynman: Warning: Web layer " + string(i) + " merge resulted in empty list");
        }
    }
    // print("mergeFeynman: Merge complete");
    return(out);
}
print("Merged data_a and data_b MI size: " + string(size(merged_ab.MI)));
print("Merged data_a and data_b IBP size: " + string(size(merged_ab.reducedIBPs.IBP)));
print("Merged data_a and data_b web size: " + string(size(merged_ab.web)));
print("Merged data_a and data_b MI size: " + string(size(merged_ab.MI)));
print("Merged data_a and data_b IBP size: " + string(size(merged_ab.reducedIBPs.IBP)));
print("Merged data_a and data_b web size: " + string(size(merged_ab.web)));
feynman merged_ab = mergeFeynman(data_a, data_b);
print("Merged data_a and data_b MI size: " + string(size(merged_ab.MI)));
print("Merged data_a and data_b IBP size: " + string(size(merged_ab.reducedIBPs.IBP)));
print("Merged data_a and data_b web size: " + string(size(merged_ab.web)));
$
Singular
;
LIB "feynman_example.lib";
    ring R = (0,t1,t2,D), (z(1..9)), dp;
 ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Helper to create a oneSector struct
    proc createSector(list lab, list sectorMap, list targetInts) {
        oneSector s;
        s.lab = lab;
        s.sectorMap = sectorMap;
        s.targetInts = targetInts;
        return(s);
    }
    // Helper to create a oneIBP struct
    proc createIBP(list coeff, list integrals) {
        oneIBP ibp;
        ibp.c = coeff;
        ibp.i = integrals;
        return(ibp);
    }
    // Create data_a
    feynman data_a;
    data_a.MI = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    data_a.reducedIBPs.over = R;
    data_a.reducedIBPs.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    data_a.reducedIBPs.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        )
    );
    data_a.web = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1)))
        )
    );
data_a;
    // Create data_b
    feynman data_b;
    data_b.MI = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    data_b.reducedIBPs.over = R;
    data_b.reducedIBPs.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    data_b.reducedIBPs.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        )
    );
    data_b.web = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2)))
        )
    );
    // Create data_c (third dataset)
    feynman data_c;
    data_c.MI = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -3),
        list(1, 1, 1, -1, -3, 0, -1, -1, -4)
    );
    data_c.reducedIBPs.over = R;
    data_c.reducedIBPs.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    data_c.reducedIBPs.IBP = list(
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    data_c.web = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -3))),
            createSector(list(1, 5), list(1, 5), list(list(1, 1, 1, -1, -5, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -3)))
        )
    );
    // Merge all three datasets
    list data_to_merge = list(data_a, data_b, data_c);
    feynman merged_abc = mergeFeynman(data_to_merge);
    list data_to_merge = list(data_a, data_b, data_c);
    feynman merged_abc = mergeFeynman(data_to_merge);
$
LIB "feynman_example.lib";
 ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Helper to create a oneSector struct
    proc createSector(list lab, list sectorMap, list targetInts) {
        oneSector s;
        s.lab = lab;
        s.sectorMap = sectorMap;
        s.targetInts = targetInts;
        return(s);
    }
    // Helper to create a oneIBP struct
    proc createIBP(list coeff, list integrals) {
        oneIBP ibp;
        ibp.c = coeff;
        ibp.i = integrals;
        return(ibp);
    }
    // Create data_a
    feynman data_a;
    data_a.MI = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    data_a.reducedIBPs.over = R;
    data_a.reducedIBPs.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    data_a.reducedIBPs.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        )
    );
    data_a.web = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1)))
        )
    );
    // Create data_b
    feynman data_b;
    data_b.MI = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    data_b.reducedIBPs.over = R;
    data_b.reducedIBPs.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    data_b.reducedIBPs.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        )
    );
    data_b.web = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2)))
        )
    );
    // Create data_c (third dataset)
    feynman data_c;
    data_c.MI = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -3),
        list(1, 1, 1, -1, -3, 0, -1, -1, -4)
    );
    data_c.reducedIBPs.over = R;
    data_c.reducedIBPs.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    data_c.reducedIBPs.IBP = list(
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    data_c.web = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -3))),
            createSector(list(1, 5), list(1, 5), list(list(1, 1, 1, -1, -5, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -3)))
        )
    );
  list data_to_merge = list(data_a, data_b, data_c);
    feynman merged_abc = mergeFeynman(data_to_merge);
 print("Merged data_a, data_b, and data_c MI size: " + string(size(merged_abc.MI)));
    print("Merged data_a, data_b, and data_c IBP size: " + string(size(merged_abc.reducedIBPs.IBP)));
    print("Merged data_a, data_b, and data_c web size: " + string(size(merged_abc.web)));
 for (int i = 1; i <= size(merged_abc.web); i++) {
        print("Merged web layer " + string(i) + " size: " + string(size(merged_abc.web[i])));
        for (int j = 1; j <= size(merged_abc.web[i]); j++) {
            print("  Sector " + string(j) + " lab: " + string(merged_abc.web[i][j].lab));
            print("  Sector " + string(j) + " targetInts size: " + string(size(merged_abc.web[i][j].targetInts)));
        }
    }
}
$
LIB "feynman_example.lib";
$
LIB "feynman_example.lib";
$
LIB "feynman_example.lib";
ring R = (0,t1,t2,D), (z(1..9)), dp;
// Define first set of data (formerly data_a)
list MI_a = list(
    list(1, 1, 1, -1, -3, 0, -1, -1, -1),
    list(1, 1, 1, -1, -3, 0, -1, -1, -2)
);
setIBP reducedIBPs_a;
reducedIBPs_a.over = R;
reducedIBPs_a.seed = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1)
);
reducedIBPs_a.IBP = list(
    createIBP(
        list(t1*t2, -t2^2),
        list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
    ),
    createIBP(
        list(2*t1, t2),
        list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
    )
);
list web_a = list(
    list(
        createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
        createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
    ),
    list(
        createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
        createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
    )
);
// Define second set of data (formerly data_b)
list MI_b = list(
    list(1, 1, 1, -1, -3, 0, -1, -1, -2),
    list(1, 1, 1, -1, -3, 0, -1, -1, -3)
);
setIBP reducedIBPs_b;
reducedIBPs_b.over = R;
reducedIBPs_b.seed = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1)
);
reducedIBPs_b.IBP = list(
    createIBP(
        list(t1^2, -t1*t2),
        list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
    ),
    createIBP(
        list(t2^2, -t1),
        list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
    )
);
list web_b = list(
    list(
        createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
        createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
    ),
    list(
        createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
        createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
    )
);
print("Merged MI: " + string(merged_MI.data[1]));
// Helper procedure to compare two integer lists for equality
proc eq_int_list(list a, list b) 
"USAGE: eq_int_list(a, b); a, b lists of integers
RETURN: 1 if lists are equal, 0 otherwise"
{
  if (typeof(a) != "list" || typeof(b) != "list") {
      print("eq_int_list: Error: Inputs must be lists (a: " + typeof(a) + ", b: " + typeof(b) + ")");
      return(0);
  }
  if (size(a) != size(b)) {
      return(0);
  }
  for (int i = 1; i <= size(a); i++) {
      if (typeof(a[i]) != "int" || typeof(b[i]) != "int") {
          print("eq_int_list: Error: Non-integer element at index " + string(i));
          return(0);
      }
      if (a[i] != b[i]) {
          return(0);
      }
  }
  return(1);
}
// Helper procedure to merge two lists of integer vectors, removing duplicates
proc merge_int_vectors(list A, list B) 
"USAGE: merge_int_vectors(A, B); A, B lists of integer vectors
RETURN: A new list containing all unique integer vectors from A and B"
{
  if (typeof(A) != "list" || typeof(B) != "list") {
      print("merge_int_vectors: Error: Inputs must be lists (A: " + typeof(A) + ", B: " + typeof(B) + ")");
      return(list());
  }
  if (size(A) == 0 && size(B) == 0) {
      return(list());
  }
  list C = A;
  for (int i = 1; i <= size(B); i++) {
      if (typeof(B[i]) != "list") {
          print("merge_int_vectors: Warning: Skipping non-list element B[" + string(i) + "]");
          continue;
      }
      int found = 0;
      for (int j = 1; j <= size(A); j++) {
          if (typeof(A[j]) != "list") {
              print("merge_int_vectors: Warning: Skipping non-list element A[" + string(j) + "]");
              continue;
          }
          if (eq_int_list(A[j], B[i])) {
              found = 1;
              break;
          }
      }
      if (!found) {
          C[size(C) + 1] = B[i];
      }
  }
  return(C);
}
// Helper procedure to merge two lists of sectors, combining targetInts where labs match
proc merge_sector_lists(list A, list B) 
"USAGE: merge_sector_lists(A, B); A, B lists of sector structs with 'lab' and 'targetInts' fields
RETURN: A merged list of sectors, combining targetInts for matching labs"
{
  if (typeof(A) != "list" || typeof(B) != "list") {
      print("merge_sector_lists: Error: Inputs must be lists (A: " + typeof(A) + ", B: " + typeof(B) + ")");
      return(list());
  }
  if (size(A) < 0 || size(B) < 0) {
      print("merge_sector_lists: Error: Negative size detected (A: " + string(size(A)) + ", B: " + string(size(B)) + ")");
      return(list());
  }
  list C = list();
  for (int i = 1; i <= size(A); i++) {
      if (typeof(A[i]) != "list" || defined(A[i].lab) == 0 || defined(A[i].targetInts) == 0) {
          print("merge_sector_lists: Error: A[" + string(i) + "] missing lab or targetInts or not a list");
          return(list());
      }
      C[i] = A[i];
  }
  for (int i = 1; i <= size(B); i++) {
      if (typeof(B[i]) != "list" || defined(B[i].lab) == 0 || defined(B[i].targetInts) == 0) {
          print("merge_sector_lists: Error: B[" + string(i) + "] missing lab or targetInts or not a list");
          return(list());
      }
      int found = 0;
      int idx = 0;
      for (int j = 1; j <= size(A); j++) {
          if (eq_int_list(A[j].lab, B[i].lab)) {
              found = 1;
              idx = j;
              break;
          }
      }
      if (found) {
          C[idx].targetInts = merge_int_vectors(C[idx].targetInts, B[i].targetInts);
      } else {
          C[size(C) + 1] = B[i];
      }
  }
  return(C);
}
// Procedure to merge two web lists
proc merge_web(list web1, list web2) 
"USAGE: merge_web(web1, web2); web1, web2 lists of sector lists
RETURN: A merged web structure combining all layers from web1 and web2"
{
  if (typeof(web1) != "list" || typeof(web2) != "list") {
      print("merge_web: Error: Inputs must be lists (web1: " + typeof(web1) + ", web2: " + typeof(web2) + ")");
      return(list());
  }
  if (size(web1) == 0 && size(web2) == 0) {
      return(list());
  }
  if (size(web1) == 0) {
      return(web2);
  }
  if (size(web2) == 0) {
      return(web1);
  }
  list merged = list();
  int max_layers = size(web1) > size(web2) ? size(web1) : size(web2);
  
  for (int i = 1; i <= max_layers; i++) {
      list layer_sectors = list();
      if (i <= size(web1) && typeof(web1[i]) == "list") {
          layer_sectors = web1[i];
      }
      if (i <= size(web2) && typeof(web2[i]) == "list") {
          if (size(layer_sectors) == 0) {
              layer_sectors = web2[i];
          } else {
              layer_sectors = merge_sector_lists(layer_sectors, web2[i]);
          }
      }
      if (size(layer_sectors) == 0) {
          print("merge_web: Warning: Layer " + string(i) + " resulted in empty sector list");
      }
      merged[i] = layer_sectors;
  }
  return(merged);
}
// Procedure to merge two MI lists
proc mergeMI(list MI1, list MI2) 
"USAGE: mergeMI(MI1, MI2); MI1, MI2 lists of integer vectors
RETURN: A merged MI list with unique integer vectors"
{
  if (typeof(MI1) != "list" || typeof(MI2) != "list") {
      print("mergeMI: Error: Inputs must be lists (MI1: " + typeof(MI1) + ", MI2: " + typeof(MI2) + ")");
      return(list());
  }
  return(merge_int_vectors(MI1, MI2));
}
// Procedure to merge two reducedIBPs structures of type setIBP
proc mergeRedIBPs(setIBP redIBPs1, setIBP redIBPs2) 
"USAGE: mergeRedIBPs(redIBPs1, redIBPs2); redIBPs1, redIBPs2 setIBP structs with over, seed, and IBP fields
RETURN: A merged setIBP struct with combined seeds and IBPs
DESCRIPTION: Merges two reducedIBPs fields, ensuring ring compatibility, merging seeds, and appending IBPs."
{
  if (typeof(redIBPs1) != "setIBP" || typeof(redIBPs2) != "setIBP") {
      print("mergeRedIBPs: Error: Inputs must be setIBP type (redIBPs1: " + typeof(redIBPs1) + ", redIBPs2: " + typeof(redIBPs2) + ")");
      setIBP empty;
      return(empty);
  }
  if (redIBPs1.over != redIBPs2.over) {
      print("mergeRedIBPs: Error: Incompatible rings");
      setIBP empty;
      return(empty);
  }
  setIBP merged;
  merged.over = redIBPs1.over; // Use the ring from the first input
  merged.seed = merge_int_vectors(redIBPs1.seed, redIBPs2.seed); // Merge seeds
  merged.IBP = list(); // Initialize IBP list
  int idx = 0;
  
  // Append all IBPs from redIBPs1
  for (int i = 1; i <= size(redIBPs1.IBP); i++) {
      idx = idx + 1;
      merged.IBP[idx] = redIBPs1.IBP[i];
  }
  // Append all IBPs from redIBPs2
  for (int i = 1; i <= size(redIBPs2.IBP); i++) {
      idx = idx + 1;
      merged.IBP[idx] = redIBPs2.IBP[i];
  }
  return(merged);
}
$
LIB "feynman_example.lib";
// Define the ring
ring R = (0,t1,t2,D), (z(1..9)), dp;
// Define first set of variables (formerly data_a)
list MI_a = list(
    list(1, 1, 1, -1, -3, 0, -1, -1, -1),
    list(1, 1, 1, -1, -3, 0, -1, -1, -2)
);
setIBP reducedIBPs_a;
reducedIBPs_a.over = R;
reducedIBPs_a.seed = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1)
);
reducedIBPs_a.IBP = list(
    createIBP(
        list(t1*t2, -t2^2),
        list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
    ),
    createIBP(
        list(2*t1, t2),
        list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
    )
);
list web_a = list(
    list(
        createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
        createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
    ),
    list(
        createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
        createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
    )
);
// Define second set of variables (formerly data_b)
list MI_b = list(
    list(1, 1, 1, -1, -3, 0, -1, -1, -2),
    list(1, 1, 1, -1, -3, 0, -1, -1, -3)
);
setIBP reducedIBPs_b;
reducedIBPs_b.over = R;
reducedIBPs_b.seed = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1)
);
reducedIBPs_b.IBP = list(
    createIBP(
        list(t1^2, -t1*t2),
        list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
    ),
    createIBP(
        list(t2^2, -t1),
        list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
    )
);
list web_b = list(
    list(
        createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
        createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
    ),
    list(
        createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
        createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
    )
);
// Helper procedure to compare two integer lists for equality
proc eq_int_list(list a, list b) 
"USAGE: eq_int_list(a, b); a, b lists of integers
RETURN: 1 if lists are equal, 0 otherwise"
{
  if (typeof(a) != "list" || typeof(b) != "list") {
      print("eq_int_list: Error: Inputs must be lists (a: " + typeof(a) + ", b: " + typeof(b) + ")");
      return(0);
  }
  if (size(a) != size(b)) {
      return(0);
  }
  for (int i = 1; i <= size(a); i++) {
      if (typeof(a[i]) != "int" || typeof(b[i]) != "int") {
          print("eq_int_list: Error: Non-integer element at index " + string(i));
          return(0);
      }
      if (a[i] != b[i]) {
          return(0);
      }
  }
  return(1);
}
// Helper procedure to merge two lists of integer vectors, removing duplicates
proc merge_int_vectors(list A, list B) 
"USAGE: merge_int_vectors(A, B); A, B lists of integer vectors
RETURN: A new list containing all unique integer vectors from A and B"
{
  if (typeof(A) != "list" || typeof(B) != "list") {
      print("merge_int_vectors: Error: Inputs must be lists (A: " + typeof(A) + ", B: " + typeof(B) + ")");
      return(list());
  }
  if (size(A) == 0 && size(B) == 0) {
      return(list());
  }
  list C = A;
  for (int i = 1; i <= size(B); i++) {
      if (typeof(B[i]) != "list") {
          print("merge_int_vectors: Warning: Skipping non-list element B[" + string(i) + "]");
          continue;
      }
      int found = 0;
      for (int j = 1; j <= size(A); j++) {
          if (typeof(A[j]) != "list") {
              print("merge_int_vectors: Warning: Skipping non-list element A[" + string(j) + "]");
              continue;
          }
          if (eq_int_list(A[j], B[i])) {
              found = 1;
              break;
          }
      }
      if (!found) {
          C[size(C) + 1] = B[i];
      }
  }
  return(C);
}
// Helper procedure to merge two lists of sectors, combining targetInts where labs match
proc merge_sector_lists(list A, list B) 
"USAGE: merge_sector_lists(A, B); A, B lists of sector structs with 'lab' and 'targetInts' fields
RETURN: A merged list of sectors, combining targetInts for matching labs"
{
  if (typeof(A) != "list" || typeof(B) != "list") {
      print("merge_sector_lists: Error: Inputs must be lists (A: " + typeof(A) + ", B: " + typeof(B) + ")");
      return(list());
  }
  if (size(A) < 0 || size(B) < 0) {
      print("merge_sector_lists: Error: Negative size detected (A: " + string(size(A)) + ", B: " + string(size(B)) + ")");
      return(list());
  }
  list C = list();
  for (int i = 1; i <= size(A); i++) {
      if (typeof(A[i]) != "list" || defined(A[i].lab) == 0 || defined(A[i].targetInts) == 0) {
          print("merge_sector_lists: Error: A[" + string(i) + "] missing lab or targetInts or not a list");
          return(list());
      }
      C[i] = A[i];
  }
  for (int i = 1; i <= size(B); i++) {
      if (typeof(B[i]) != "list" || defined(B[i].lab) == 0 || defined(B[i].targetInts) == 0) {
          print("merge_sector_lists: Error: B[" + string(i) + "] missing lab or targetInts or not a list");
          return(list());
      }
      int found = 0;
      int idx = 0;
      for (int j = 1; j <= size(A); j++) {
          if (eq_int_list(A[j].lab, B[i].lab)) {
              found = 1;
              idx = j;
              break;
          }
      }
      if (found) {
          C[idx].targetInts = merge_int_vectors(C[idx].targetInts, B[i].targetInts);
      } else {
          C[size(C) + 1] = B[i];
      }
  }
  return(C);
}
// Procedure to merge two web lists
proc merge_web(list web1, list web2) 
"USAGE: merge_web(web1, web2); web1, web2 lists of sector lists
RETURN: A merged web structure combining all layers from web1 and web2"
{
  if (typeof(web1) != "list" || typeof(web2) != "list") {
      print("merge_web: Error: Inputs must be lists (web1: " + typeof(web1) + ", web2: " + typeof(web2) + ")");
      return(list());
  }
  if (size(web1) == 0 && size(web2) == 0) {
      return(list());
  }
  if (size(web1) == 0) {
      return(web2);
  }
  if (size(web2) == 0) {
      return(web1);
  }
  list merged = list();
  int max_layers = size(web1) > size(web2) ? size(web1) : size(web2);
  
  for (int i = 1; i <= max_layers; i++) {
      list layer_sectors = list();
      if (i <= size(web1) && typeof(web1[i]) == "list") {
          layer_sectors = web1[i];
      }
      if (i <= size(web2) && typeof(web2[i]) == "list") {
          if (size(layer_sectors) == 0) {
              layer_sectors = web2[i];
          } else {
              layer_sectors = merge_sector_lists(layer_sectors, web2[i]);
          }
      }
      if (size(layer_sectors) == 0) {
          print("merge_web: Warning: Layer " + string(i) + " resulted in empty sector list");
      }
      merged[i] = layer_sectors;
  }
  return(merged);
}
// Procedure to merge two MI lists
proc mergeMI(list MI1, list MI2) 
"USAGE: mergeMI(MI1, MI2); MI1, MI2 lists of integer vectors
RETURN: A merged MI list with unique integer vectors"
{
  if (typeof(MI1) != "list" || typeof(MI2) != "list") {
      print("mergeMI: Error: Inputs must be lists (MI1: " + typeof(MI1) + ", MI2: " + typeof(MI2) + ")");
      return(list());
  }
  return(merge_int_vectors(MI1, MI2));
}
// Procedure to merge two reducedIBPs structures of type setIBP
proc mergeRedIBPs(setIBP redIBPs1, setIBP redIBPs2) 
"USAGE: mergeRedIBPs(redIBPs1, redIBPs2); redIBPs1, redIBPs2 setIBP structs with over, seed, and IBP fields
RETURN: A merged setIBP struct with combined seeds and IBPs"
{
  if (typeof(redIBPs1) != "setIBP" || typeof(redIBPs2) != "setIBP") {
      print("mergeRedIBPs: Error: Inputs must be setIBP type (redIBPs1: " + typeof(redIBPs1) + ", redIBPs2: " + typeof(redIBPs2) + ")");
      setIBP empty;
      return(empty);
  }
  if (redIBPs1.over != redIBPs2.over) {
      print("mergeRedIBPs: Error: Incompatible rings");
      setIBP empty;
      return(empty);
  }
  setIBP merged;
  merged.over = redIBPs1.over; // Use the ring from the first input
  merged.seed = merge_int_vectors(redIBPs1.seed, redIBPs2.seed); // Merge seeds
  merged.IBP = list(); // Initialize IBP list
  int idx = 0;
  
  // Append all IBPs from redIBPs1
  for (int i = 1; i <= size(redIBPs1.IBP); i++) {
      idx = idx + 1;
      merged.IBP[idx] = redIBPs1.IBP[i];
  }
  // Append all IBPs from redIBPs2
  for (int i = 1; i <= size(redIBPs2.IBP); i++) {
      idx = idx + 1;
      merged.IBP[idx] = redIBPs2.IBP[i];
  }
  return(merged);
}
// Example usage
list merged_MI = mergeMI(MI_a, MI_b);
list merged_web = merge_web(web_a, web_b);
setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
list web_a = list(
    list(
        createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
        createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
    ),
    list(
        createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
        createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
    )
);
// Example usage
list merged_MI = mergeMI(MI_a, MI_b);
list merged_web = merge_web(web_a, web_b);
setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
$
LIB "feynman_example.lib";
 ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
web_a;
R;
MI_a;
reducedIBPs_a;
web_a;
 list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
web_a;
$
LIB "feynman_example.lib";
ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables (formerly data_b)
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        ),
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
            createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
        )
    );
web_a;
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
// Procedure to merge two web lists
proc merge_web(list web1, list web2) 
"USAGE: merge_web(web1, web2); web1, web2 lists of sector lists
RETURN: A merged web structure combining all layers from web1 and web2"
{
  if (typeof(web1) != "list" || typeof(web2) != "list") {
      print("merge_web: Error: Inputs must be lists (web1: " + typeof(web1) + ", web2: " + typeof(web2) + ")");
      return(list());
  }
  if (size(web1) == 0 && size(web2) == 0) {
      return(list());
  }
  if (size(web1) == 0) {
      return(web2);
  }
  if (size(web2) == 0) {
      return(web1);
  }
  list merged = list();
  int max_layers;
  if (size(web1) > size(web2)) {
      max_layers = size(web1);
  } else {
      max_layers = size(web2);
  }  
  for (int i = 1; i <= max_layers; i++) {
      list layer_sectors = list();
      if (i <= size(web1) && typeof(web1[i]) == "list") {
          layer_sectors = web1[i];
      }
      if (i <= size(web2) && typeof(web2[i]) == "list") {
          if (size(layer_sectors) == 0) {
              layer_sectors = web2[i];
          } else {
              layer_sectors = merge_sector_lists(layer_sectors, web2[i]);
          }
      }
      if (size(layer_sectors) == 0) {
          print("merge_web: Warning: Layer " + string(i) + " resulted in empty sector list");
      }
      merged[i] = layer_sectors;
  }
  return(merged);
}
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
// Helper procedure to merge two lists of sectors, combining targetInts where labs match
proc merge_sector_lists(list A, list B) 
"USAGE: merge_sector_lists(A, B); A, B lists of sector structs with 'lab' and 'targetInts' fields
RETURN: A merged list of sectors, combining targetInts for matching labs"
{
  if (typeof(A) != "list" || typeof(B) != "list") {
      print("merge_sector_lists: Error: Inputs must be lists (A: " + typeof(A) + ", B: " + typeof(B) + ")");
      return(list());
  }
  if (size(A) < 0 || size(B) < 0) {
      print("merge_sector_lists: Error: Negative size detected (A: " + string(size(A)) + ", B: " + string(size(B)) + ")");
      return(list());
  }
  list C = list();
  // Copy sectors from A
  for (int i = 1; i <= size(A); i++) {
      if (defined(A[i].lab) == 0 || defined(A[i].targetInts) == 0) {
          print("merge_sector_lists: Error: A[" + string(i) + "] missing lab or targetInts");
          return(list());
      }
      C[i] = A[i]; // Directly copy the oneSector struct
  }
  // Merge sectors from B
  for (int i = 1; i <= size(B); i++) {
      if (defined(B[i].lab) == 0 || defined(B[i].targetInts) == 0) {
          print("merge_sector_lists: Error: B[" + string(i) + "] missing lab or targetInts");
          return(list());
      }
      int found = 0;
      int idx = 0;
      for (int j = 1; j <= size(A); j++) {
          if (eq_int_list(A[j].lab, B[i].lab)) {
              found = 1;
              idx = j;
              break;
          }
      if (found) {
          C[idx].targetInts = merge_int_vectors(C[idx].targetInts, B[i].targetInts);
      } else {
          C[size(C) + 1] = B[i]; // Append the oneSector struct directly
      }
  }
  return(C);
}
// Procedure to merge two web lists
proc merge_web(list web1, list web2) 
"USAGE: merge_web(web1, web2); web1, web2 lists of sector lists
RETURN: A merged web structure combining all layers from web1 and web2"
{
  if (typeof(web1) != "list" || typeof(web2) != "list") {
      print("merge_web: Error: Inputs must be lists (web1: " + typeof(web1) + ", web2: " + typeof(web2) + ")");
      return(list());
  }
  if (size(web1) == 0 && size(web2) == 0) {
      return(list());
  }
  if (size(web1) == 0) {
      return(web2);
  }
  if (size(web2) == 0) {
      return(web1);
  }
  list merged = list();
  int max_layers;
  if (size(web1) > size(web2)) {
      max_layers = size(web1);
  } else {
      max_layers = size(web2);
  }  
  for (int i = 1; i <= max_layers; i++) {
      list layer_sectors = list();
      if (i <= size(web1) && typeof(web1[i]) == "list") {
          layer_sectors = web1[i];
      }
      if (i <= size(web2) && typeof(web2[i]) == "list") {
          if (size(layer_sectors) == 0) {
              layer_sectors = web2[i];
          } else {
              layer_sectors = merge_sector_lists(layer_sectors, web2[i]);
          }
      }
      if (size(layer_sectors) == 0) {
          print("merge_web: Warning: Layer " + string(i) + " resulted in empty sector list");
      }
      merged[i] = layer_sectors;
  }
  return(merged);
}
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
 // Print results for verification
    print("Merged MI: " + string(merged_MI));
    print("Merged web: " + string(merged_web));
    print("Merged reducedIBPs.seed: " + string(merged_reducedIBPs.seed));
    print("Merged reducedIBPs.IBP: " + string(merged_reducedIBPs.IBP));
// New procedure to print detailed contents of lists and setIBP structs
proc print_detailed(string name, def obj)
"USAGE: print_detailed(name, obj); name string label, obj any object (list or setIBP)
PURPOSE: Prints detailed contents of nested structures"
{
  print(name + ":");
  if (typeof(obj) == "list") {
      if (size(obj) == 0) {
          print("  (empty list)");
          return;
      }
      for (int i = 1; i <= size(obj); i++) {
          if (typeof(obj[i]) == "list") {
              string s = "  [" + string(i) + "] = ";
              for (int j = 1; j <= size(obj[i]); j++) {
                  s = s + string(obj[i][j]);
                  if (j < size(obj[i])) { s = s + ","; }
              }
              print(s);
          } else if (typeof(obj[i]) == "oneSector") {
              print("  [" + string(i) + "].lab = " + string(obj[i].lab));
              print("  [" + string(i) + "].sectorMap = " + string(obj[i].sectorMap));
              print("  [" + string(i) + "].targetInts = " + string(obj[i].targetInts));
          } else {
              print("  [" + string(i) + "] = " + string(obj[i]));
          }
      }
  } else if (typeof(obj) == "setIBP") {
      print("  over = " + string(obj.over));
      print("  seed:");
      for (int i = 1; i <= size(obj.seed); i++) {
          string s = "    [" + string(i) + "] = ";
          for (int j = 1; j <= size(obj.seed[i]); j++) {
              s = s + string(obj.seed[i][j]);
              if (j < size(obj.seed[i])) { s = s + ","; }
          }
          print(s);
      }
      print("  IBP:");
      for (int i = 1; i <= size(obj.IBP); i++) {
          print("    [" + string(i) + "].c = " + string(obj.IBP[i].c));
          print("    [" + string(i) + "].i:");
          for (int j = 1; j <= size(obj.IBP[i].i); j++) {
              string s = "      [" + string(j) + "] = ";
              for (int k = 1; k <= size(obj.IBP[i].i[j]); k++) {
                  s = s + string(obj.IBP[i].i[j][k]);
                  if (k < size(obj.IBP[i].i[j])) { s = s + ","; }
              }
              print(s);
          }
      }
  } else {
      print("  " + string(obj));
  }
}
// Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print detailed results for verification
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
}
merged_reducedIBPs.seed;
merged_reducedIBPs;
merged_reducedIBPs[1];
merged_reducedIBPs.seed;
merged_reducedIBPs.IBP;
merged_reducedIBPs.IBP.c;
merged_reducedIBPs.IBP[1].c;
merged_reducedIBPs.IBP[1].c[1];
merged_reducedIBPs.IBP[1].i[1];
merged_web;
merged_web[2];
merged_web[2][2];
merged_web[2][2].targetInts;
merged_web[2][2].lab;
merged_MI;
// New procedure to print detailed contents of lists and setIBP structs
proc print_detailed(string name, def obj)
"USAGE: print_detailed(name, obj); name string label, obj any object (list or setIBP)
PURPOSE: Prints detailed contents of nested structures"
{
  print(name + ":");
  if (typeof(obj) == "list") {
    if (size(obj) == 0) {
      print("  (empty list)");
    } else {
      for (int i = 1; i <= size(obj); i++) {
        if (typeof(obj[i]) == "list") {
          string s = "  [" + string(i) + "] = ";
          for (int j = 1; j <= size(obj[i]); j++) {
            if (typeof(obj[i][j]) == "list") {
              s = s + "[";
              for (int k = 1; k <= size(obj[i][j]); k++) {
                s = s + string(obj[i][j][k]);
                if (k < size(obj[i][j])) { s = s + ","; }
              }
              s = s + "]";
            } else {
              s = s + string(obj[i][j]);
            }
            if (j < size(obj[i])) { s = s + ","; }
          }
          print(s);
        } else if (typeof(obj[i]) == "oneSector") {
          print("  [" + string(i) + "].lab = " + string(obj[i].lab));
          print("  [" + string(i) + "].sectorMap = " + string(obj[i].sectorMap));
          print("  [" + string(i) + "].targetInts = " + string(obj[i].targetInts));
        } else {
          print("  [" + string(i) + "] = " + string(obj[i]));
        }
      }
    }
  } else if (typeof(obj) == "setIBP") {
    print("  over = " + string(obj.over));
    print("  seed:");
    if (size(obj.seed) == 0) {
      print("    (empty list)");
    } else {
      for (int i = 1; i <= size(obj.seed); i++) {
        string s = "    [" + string(i) + "] = ";
        for (int j = 1; j <= size(obj.seed[i]); j++) {
          s = s + string(obj.seed[i][j]);
          if (j < size(obj.seed[i])) { s = s + ","; }
        }
        print(s);
      }
    }
    print("  IBP:");
    if (size(obj.IBP) == 0) {
      print("    (empty list)");
    } else {
      for (int i = 1; i <= size(obj.IBP); i++) {
        print("    [" + string(i) + "].c = " + string(obj.IBP[i].c));
        print("    [" + string(i) + "].i:");
        for (int j = 1; j <= size(obj.IBP[i].i); j++) {
          string s = "      [" + string(j) + "] = ";
          for (int k = 1; k <= size(obj.IBP[i].i[j]); k++) {
            s = s + string(obj.IBP[i].i[j][k]);
            if (k < size(obj.IBP[i].i[j])) { s = s + ","; }
          }
          print(s);
        }
      }
    }
  } else {
    print("  " + string(obj));
  }
}
// Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print detailed results for verification
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
}
// Example block demonstrating the merge procedures with detailed printing
example {
    // Define the ring
    ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables (formerly data_b)
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        ),
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
            createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
        )
    );
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print detailed results for verification
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
}
// Example block demonstrating the merge procedures with detailed printing
example {
    // Define the ring
    ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables (formerly data_b)
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        ),
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
            createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
        )
    );
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print detailed results for verification
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
}
// Example block demonstrating the merge procedures with detailed printing
example {
    // Define the ring
    ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables (formerly data_b)
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        ),
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
            createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
        )
    );
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print detailed results for verification
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
}
$
LIB "feynman_example.lib";
graph G = makeGraph(
  list(1,2,3,4,5,6), 
  list(
      list(6,1), list(4,6), list(1,2), list(3,5), 
      list(4,3), list(2,5), list(5,6), list(1), 
      list(2), list(3), list(4)
  )
);
// Define a list of target integrals
list targetInt = list(
  list(1, 1, 1, -1, -3, 1, -1, -1, -1), 
  list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
    if (size(targetInt) == 0) {
        ERROR("Empty target integral list provided.");
    }
    // Debug: Ensure the input graph G and target integrals are correctly passed
    print("Graph G: " + string(G));
    print("Target Integrals: " + string(targetInt));
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
    web = setSectorMap(web);
    print("Generated web: " + string(web));
    list w4 = updateWeb(web, list(1,1), targetInt);
    web = w4[1];
    print("Size of updated web: " + string(size(web)));
    labeledgraph G1 = computeBaikovMatrix(G);
    setIBP reducedIBPs;
    list MI;
    print("Size of targetInt: " + string(size(targetInt)));
    int te = 0;
    reducedIBPs.seed = targetInt;
    int j = 1;
    if (size(web) < j) {
        ERROR("Web list does not contain layer j=" + string(j));
    }
    int nSectors = size(web[j]);
    if (nSectors == 0) {
        ERROR("No sectors available in web[" + string(j) + "]");
    }
    int k = 1;
    if (size(web[j]) < k) {
        ERROR("Web[" + string(j) + "] does not contain sector k=" + string(k));
    }
    print("Computing IBP for sector: " + string(web[j][k].targetInts));
    setIBP totalIBP = computeManyIBP(G1, web[j][k].targetInts);
    print("Size of totalIBP.IBP: " + string(size(totalIBP.IBP)));
    if (te == 0) {
        reducedIBPs.over = totalIBP.over;
        te = 1;
    }
    if (reducedIBPs.over == 0) {
        ERROR("totalIBP.over is not initialized correctly.");
    }
    ring R = reducedIBPs.over;
    setring R;
    list L = getRedIBPs(totalIBP, 101);
    if (size(L) < 2) {
        ERROR("getRedIBPs did not return expected two lists.");
    }
    list indpndIBP = L[1];
    print("Size of indpndIBP: " + string(size(indpndIBP)));
    list masterAndTailIntgrals = L[2];
    print("Size of masterAndTailIntgrals: " + string(size(masterAndTailIntgrals)));
    if (size(reducedIBPs.IBP) == 0) {
        reducedIBPs.IBP = indpndIBP;
    } else {
        for (int i = 1; i <= size(indpndIBP); i++) {
            reducedIBPs.IBP[size(reducedIBPs.IBP) + 1] = indpndIBP[i];
        }
    }
    kill R;
    print("Size of masterAndTailIntgrals = " + string(size(masterAndTailIntgrals)));
    list w = updateWeb(web, list(j, k), masterAndTailIntgrals);
    web = w[1];
    print("w[2] = " + string(w[2])); // Fixed debug message
    list masterIntgralsInSector = w[2];
    print("Size of masterIntgralsInSector = " + string(size(masterIntgralsInSector)));
    if (size(MI) == 0) {
        print("MI is empty, assigning masterIntgralsInSector to MI");
        MI = masterIntgralsInSector;
        print("MI is now: " + string(MI));
    } else {
        for (int i = 1; i <= size(masterIntgralsInSector); i++) {
            if (alreadyIntheList(MI, masterIntgralsInSector[i]) == 0) {
                print("Adding master integral to MI: " + string(masterIntgralsInSector[i]));
                MI[size(MI) + 1] = masterIntgralsInSector[i];
            }
        }
    }
    print("Completed computation in sector: " + string(k) + " at layer " + string(j) + ".");
    return list(reducedIBPs, MI);
graph G = makeGraph(
  list(1,2,3,4,5,6), 
  list(
      list(6,1), list(4,6), list(1,2), list(3,5), 
      list(4,3), list(2,5), list(5,6), list(1), 
      list(2), list(3), list(4)
  )
);
// Define a list of target integrals
list targetInt = list(
  list(1, 1, 1, -1, -3, 1, -1, -1, -1), 
  list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
    if (size(targetInt) == 0) {
        ERROR("Empty target integral list provided.");
    }
    // Debug: Ensure the input graph G and target integrals are correctly passed
    print("Graph G: " + string(G));
    print("Target Integrals: " + string(targetInt));
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
    web = setSectorMap(web);
    print("Generated web: " + string(web));
    list w4 = updateWeb(web, list(1,1), targetInt);
    web = w4[1];
    print("Size of updated web: " + string(size(web)));
    labeledgraph G1 = computeBaikovMatrix(G);
    setIBP reducedIBPs;
    list MI;
    print("Size of targetInt: " + string(size(targetInt)));
    int te = 0;
    reducedIBPs.seed = targetInt;
    int j = 1;
    if (size(web) < j) {
        ERROR("Web list does not contain layer j=" + string(j));
    }
    int nSectors = size(web[j]);
    if (nSectors == 0) {
        ERROR("No sectors available in web[" + string(j) + "]");
    }
    int k = 1;
    if (size(web[j]) < k) {
        ERROR("Web[" + string(j) + "] does not contain sector k=" + string(k));
    }
    print("Computing IBP for sector: " + string(web[j][k].targetInts));
    setIBP totalIBP = computeManyIBP(G1, web[j][k].targetInts);
    print("Size of totalIBP.IBP: " + string(size(totalIBP.IBP)));
    if (te == 0) {
        reducedIBPs.over = totalIBP.over;
        te = 1;
    }
    if (reducedIBPs.over == 0) {
        ERROR("totalIBP.over is not initialized correctly.");
    }
    ring R = reducedIBPs.over;
    setring R;
    list L = getRedIBPs(totalIBP, 101);
    if (size(L) < 2) {
        ERROR("getRedIBPs did not return expected two lists.");
    }
    list indpndIBP = L[1];
    print("Size of indpndIBP: " + string(size(indpndIBP)));
    list masterAndTailIntgrals = L[2];
    print("Size of masterAndTailIntgrals: " + string(size(masterAndTailIntgrals)));
    if (size(reducedIBPs.IBP) == 0) {
        reducedIBPs.IBP = indpndIBP;
    } else {
        for (int i = 1; i <= size(indpndIBP); i++) {
            reducedIBPs.IBP[size(reducedIBPs.IBP) + 1] = indpndIBP[i];
        }
    }
    kill R;
    print("Size of masterAndTailIntgrals = " + string(size(masterAndTailIntgrals)));
    list w = updateWeb(web, list(j, k), masterAndTailIntgrals);
    web = w[1];
    print("w[2] = " + string(w[2])); // Fixed debug message
    list masterIntgralsInSector = w[2];
    print("Size of masterIntgralsInSector = " + string(size(masterIntgralsInSector)));
    if (size(MI) == 0) {
        print("MI is empty, assigning masterIntgralsInSector to MI");
        MI = masterIntgralsInSector;
        print("MI is now: " + string(MI));
    } else {
        for (int i = 1; i <= size(masterIntgralsInSector); i++) {
            if (alreadyIntheList(MI, masterIntgralsInSector[i]) == 0) {
                print("Adding master integral to MI: " + string(masterIntgralsInSector[i]));
                MI[size(MI) + 1] = masterIntgralsInSector[i];
            }
        }
    }
    print("Completed computation in sector: " + string(k) + " at layer " + string(j) + ".");
    return list(reducedIBPs, MI);
LIB "feynman_example.lib";
  ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables (formerly data_b)
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        ),
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
            createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
        )
    );
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print detailed results for verification
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
$
LIB "feynman_example.lib";
ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables (formerly data_b)
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        ),
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
            createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
        )
    );
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print detailed results for verification
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
$
LIB "feynman_example.lib";
ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables (formerly data_b)
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        ),
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
            createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
        )
    );
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print detailed results for verification
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
    print_detailed("Merged MI", merged_MI);
MI_a;
    print_detailed("Merged MI", merged_MI);
$
LIB "feynman_example.lib";
 ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables (formerly data_b)
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        ),
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
            createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
        )
    );
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print detailed results for verification
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged MI", merged_MI);
$
LIB "feynman_example.lib";
 ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables (formerly data_b)
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        ),
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
            createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
        )
    );
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged MI", merged_MI);
 print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
$
LIB "feynman_example.lib";
 ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables (formerly data_b)
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        ),
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
            createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
        )
    );
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print detailed results for verification
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
    print_detailed("Merged MI", merged_MI);
$
LIB "feynman_example.lib";
 ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables (formerly data_a)
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        ),
        createIBP(
            list(2*t1, t2),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -1), list(1, 0, 1, -2, -3, 0, -1, -1, -1))
        )
    );
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1))),
            createSector(list(2, 4), list(2, 4), list(list(1, 1, 0, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables (formerly data_b)
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        ),
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2))),
            createSector(list(2, 5), list(2, 5), list(list(1, 1, 0, -1, -4, 0, -1, -1, -1)))
        )
    );
    // Example usage of merge procedures
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print detailed results for verification
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
$
LIB "feynman_example.lib";
 ring R = (0,t1,t2,D), (z(1..9)), dp;
    // Define first set of variables
    list MI_a = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    
    setIBP reducedIBPs_a;
    reducedIBPs_a.over = R;
    reducedIBPs_a.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_a.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        )
    );
    
    list web_a = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        )
    );
    // Define second set of variables
    list MI_b = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    
    setIBP reducedIBPs_b;
    reducedIBPs_b.over = R;
    reducedIBPs_b.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    reducedIBPs_b.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        )
    );
    
    list web_b = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        )
    );
    // Perform merges
    list merged_MI = mergeMI(MI_a, MI_b);
    list merged_web = merge_web(web_a, web_b);
    setIBP merged_reducedIBPs = mergeRedIBPs(reducedIBPs_a, reducedIBPs_b);
    // Print results
    print_detailed("Merged MI", merged_MI);
    print_detailed("Merged web", merged_web);
    print_detailed("Merged reducedIBPs", merged_reducedIBPs);
    print_detailed("Merged MI", merged_MI);
$
$
LIB "feynman_example.lib";
LIB "feynman.lib";
exit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
Ml;
RB;
    module ML=computeM1(G1);
ML;
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
G1.baikovmatrix;
R=G1.over;
ring R=G1.over;
setring R;
G1.baikovmatrix;
def m=fetch(G1.baikovmatrix,R);
 labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
    ML;
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
    module ML=computeM1(G1);
   ring RB=G1.baikovover;
    module ML=computeM1(G1);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    module ML=computeM1(G1);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    module ML=computeM1(G1);
ML;
ML;$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    module ML=computeM1(G1);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    module ML=computeM1(G1);
ML;
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    module ML=computeM1(G1);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    module ML=computeM1(G1);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    module ML=computeM1(G1);
$
LIB "feynman.lib";
    labeledgraph G1 = computeBaikovMatrix(G);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1 = computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    module ML=computeM1(G1);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1 = computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    module ML=computeM1(G1);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1 = computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    module ML=computeM1(G1);
ML;
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
G1.labels;
RB;
setring;
G1.over;
G1.labels;
G1.overpoly;
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
list web=generateWebSectors(setInt[1]);
web;
  list w1=setSectorMap(web); 
w1;
w1[1];
w1[1][1];
w1[1][1].lab;
w1[2][1].lab;
string(w1[2][1].lab);
string(w1[1][1].lab);
w1[2][1].targetInts;
w1[1][1].targetInts;
w1[2][1].targetInts;
$
LIB "feynman.lib";
graph G = makeGraph(
  list(1,2,3,4,5,6), 
  list(
      list(6,1), list(4,6), list(1,2), list(3,5), 
      list(4,3), list(2,5), list(5,6), list(1), 
      list(2), list(3), list(4)
  )
);
// Define a list of target integrals
list targetInt = list(
  list(1, 1, 1, -1, -3, 1, -1, -1, -1), 
  list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
    web = setSectorMap(web);
web;
string(w1[2][1].lab);
string(web[2][1].lab);
string(web[2][1].lab);
string(web[1][1].lab);
string(web[2][2].lab);
string(web[2][3].lab);
string(web[2][4].lab);
string(web[2][5].lab);
string(web[3][1].lab);
string(web[3][2].lab);
string(web[3][3].lab);
$
LIB "feynman.lib";
graph G = makeGraph(
  list(1,2,3,4,5,6), 
  list(
      list(6,1), list(4,6), list(1,2), list(3,5), 
      list(4,3), list(2,5), list(5,6), list(1), 
      list(2), list(3), list(4)
  )
);
// Define a list of target integrals
list targetInt = list(
  list(1, 1, 1, -1, -3, 1, -1, -1, -1), 
  list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
    if (size(targetInt) == 0) {
        ERROR("Empty target integral list provided.");
    }
    // Debug: Ensure the input graph G and target integrals are correctly passed
    print("Graph G: " + string(G));
    print("Target Integrals: " + string(targetInt));
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
web;
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
// Helper function to determine subset
proc subset(list small, list big)
{
for (int i = 1; i <= size(small); i++)
{
if (! contains(big, small[i])) return (0);
}
return(1);
}
// Helper function to check if list contains element
proc contains(list L, int x)
{
for (int i = 1; i <= size(L); i++)
{
if (L[i] == x) return (1);
}
return (0);
}
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
// Helper function to determine subset
proc subset(list small, list big)
{
for (int i = 1; i <= size(small); i++)
{
if (! contains(big, small[i])) return (0);
}
return(1);
}
// Helper function to check if list contains element
proc contains(list L, int x)
{
for (int i = 1; i <= size(L); i++)
{
if (L[i] == x) return (1);
}
return (0);
}
getGraph(web);
getGraph(web);;
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("vertices"+string(vertices));
print("labels"+string(labels));
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("vertices");
print(vertices);
print("labels");    
print(labels);  
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("vertices");
print(vertices);
print("labels");    
print(labels);  
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")");
}
print("labels");    
for (int i = 1; i <= size(labels); i++)
{
print(labels[i]);
}
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
getGraph(web);
web;
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
for (int j = 1; j <= size(T[i]); j++)
{
//  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")");
}
print("labels");    
for (int i = 1; i <= size(labels); i++)
{
print(labels[i]);
}
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
getGraph(web);
$
LIB "feynman.lib";
graph G = makeGraph(
  list(1,2,3,4,5,6), 
  list(
      list(6,1), list(4,6), list(1,2), list(3,5), 
      list(4,3), list(2,5), list(5,6), list(1), 
      list(2), list(3), list(4)
  )
);
// Define a list of target integrals
list targetInt = list(
  list(1, 1, 1, -1, -3, -1, -1, -1, -1), 
  list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
    if (size(targetInt) == 0) {
        ERROR("Empty target integral list provided.");
    }
    // Debug: Ensure the input graph G and target integrals are correctly passed
    print("Graph G: " + string(G));
    print("Target Integrals: " + string(targetInt));
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
for (int j = 1; j <= size(T[i]); j++)
{
//  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")");
}
print("labels");    
for (int i = 1; i <= size(labels); i++)
{
  print("("+string(label[i]) + ")");
}
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
for (int j = 1; j <= size(T[i]); j++)
{
//  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")");
}
print("labels");    
for (int i = 1; i <= size(labels); i++)
{
  print("("+string(labels[i]) + ")");
}
print("Edges:");
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
for (int j = 1; j <= size(T[i]); j++)
{
//  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")"+  "    ("+string(labels[i])+")");
}
print("Edges:");
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
for (int j = 1; j <= size(T[i]); j++)
{
//  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")"+  "    ("+string(labels[i])+")");
}
print("Edges:");
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
// Helper function to determine subset
proc subset(list small, list big)
{
for (int i = 1; i <= size(small); i++)
{
if (! contains(big, small[i])) return (0);
}
return(1);
}
// Helper function to check if list contains element
proc contains(list L, int x)
{
  print("size of L: "+string(size(L)));
  print("x: "+string(x));
for (int i = 1; i <= size(L); i++)
{
if (L[i] == x) return(1);
}
return(0);
}
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
for (int j = 1; j <= size(T[i]); j++)
{
//  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")"+  "    ("+string(labels[i])+")");
}
print("Edges:");
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
// Helper function to determine subset
proc subset(list small, list big)
{
for (int i = 1; i <= size(small); i++)
{
if (! contains(big, small[i])) return (0);
}
return(1);
}
// Helper function to check if list contains element
proc contains(list L, int x)
{
  print("size of L: "+string(size(L)));
  print("x: "+string(x));
for (int i = 1; i <= size(L); i++)
{
  if (L[i] == x){
    return(1);
  }
}
return(0);
}
getGraph(web);
list l=1,2,3,4,5;
int x=3;
contains(l,x);
int y=7;
contains(l,y);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
for (int j = 1; j <= size(T[i]); j++)
{
//  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")"+  "    ("+string(labels[i])+")");
}
print("Edges:");
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
// Helper function to determine subset
proc subset(list small, list big)
{
for (int i = 1; i <= size(small); i++)
{
if (! contains(big, small[i])) return (0);
}
return(1);
}
// Helper function to check if list contains element
proc contains(list L, int x)
{
print("L: "+string(L));  
  print("x: "+string(x));
for (int i = 1; i <= size(L); i++)
{
  if (L[i] == x){
    return (1);
  }
}
return(0);
}
getGraph(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
for (int j = 1; j <= size(T[i]); j++)
{
//  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")"+  "    ("+string(labels[i])+")");
}
print("Edges:");
// Generate edges
for (int i = 1; i < size(T); i++)
{
for (int j = 1; j <= size(T[i]); j++)
{
for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
return(list(vertices, edges, labels));
}
// Helper function to determine subset
proc subset(list small, list big)
{
for (int i = 1; i <= size(small); i++)
{
  if (!contains(big, small[i])) 
      {return(0);}
  }
return(1);
}
// Helper function to check if list contains element
proc contains(list L, int x)
{
print("L: "+string(L));  
  print("x: "+string(x));
for (int i = 1; i <= size(L); i++)
{
  if (L[i] == x){
    return (1);
  }
}
return(0);
}
;
getGraph(web);
clear;
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
for (int j = 1; j <= size(T[i]); j++)
{
//  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")"+  "    ("+string(labels[i])+")");
}
// Generate edges
for (int i = 1; i < size(T); i++)
{
  for (int j = 1; j <= size(T[i]); j++)
{
    for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
print("Edges:");
for (int i = 1; i <= size(edges); i++)
{
print("("+string(edges[i][1][1]) + ", " + string(edges[i][1][2])+")"+  "    ("+string(edges[i][2][1]) + ", " + string(edges[i][2][2])+")");
}
return(list(vertices, edges, labels));
}
// Helper function to determine subset
proc subset(list small, list big)
{
for (int i = 1; i <= size(small); i++)
{
  if (!contains(big, small[i])) 
      {return(0);}
  }
return(1);
}
// Helper function to check if list contains element
proc contains(list L, int x)
{
for (int i = 1; i <= size(L); i++)
{
  if (L[i] == x){
    return (1);
  }
}
return(0);
}
getGraph(web);
web;
getGraph(web);
web[1][1];
string(web[1][1].targetInts);
string(web[1][1].lab);
string(web[1][1].sectorMap);
graph G = makeGraph(
  list(1,2,3,4,5,6), 
  list(
      list(6,1), list(4,6), list(1,2), list(3,5), 
      list(4,3), list(2,5), list(5,6), list(1), 
      list(2), list(3), list(4)
  )
);
// Define a list of target integrals
list targetInt = list(
  list(1, 1, 1, -1, -3, -1, -1, -1, -1), 
  list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
    if (size(targetInt) == 0) {
        ERROR("Empty target integral list provided.");
    }
    // Debug: Ensure the input graph G and target integrals are correctly passed
    print("Graph G: " + string(G));
    print("Target Integrals: " + string(targetInt));
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
    web = setSectorMap(web);
    print("Generated web: " + string(web));
    list w4 = updateWeb(web, list(1,1), targetInt);
    web = w4[1];
    print("Size of updated web: " + string(size(web)));
    labeledgraph G1 = computeBaikovMatrix(G);
    setIBP reducedIBPs;
    list MI;
    print("Size of targetInt: " + string(size(targetInt)));
    int te = 0;
    reducedIBPs.seed = targetInt;
     list layers=list(1,2,3);
    int j = 1;
    if (size(web) < j) {
        ERROR("Web list does not contain layer j=" + string(j));
    }
    int nSectors = size(web[j]);
    list sector=list(1,2);
    if (nSectors == 0) {
        ERROR("No sectors available in web[" + string(j) + "]");
    }
    int k = 1;
    if (size(web[j]) < k) {
        ERROR("Web[" + string(j) + "] does not contain sector k=" + string(k));
    }
    print("Computing IBP for sector: " + string(web[j][k].targetInts));
    setIBP totalIBP = computeManyIBP(G1, web[j][k].targetInts);
    print("Size of totalIBP.IBP: " + string(size(totalIBP.IBP)));
    if (te == 0) {
        reducedIBPs.over = totalIBP.over;
        te = 1;
    }
    if (reducedIBPs.over == 0) {
        ERROR("totalIBP.over is not initialized correctly.");
    }
    ring R = reducedIBPs.over;
    setring R;
    list L = getRedIBPs(totalIBP, 101);
    if (size(L) < 2) {
        ERROR("getRedIBPs did not return expected two lists.");
    }
    list indpndIBP = L[1];
    print("Size of indpndIBP: " + string(size(indpndIBP)));
    list masterAndTailIntgrals = L[2];
    print("Size of masterAndTailIntgrals: " + string(size(masterAndTailIntgrals)));
    if (size(reducedIBPs.IBP) == 0) {
        reducedIBPs.IBP = indpndIBP;
    } else {
        for (int i = 1; i <= size(indpndIBP); i++) {
            reducedIBPs.IBP[size(reducedIBPs.IBP) + 1] = indpndIBP[i];
        }
    }
    kill R;
    print("Size of masterAndTailIntgrals = " + string(size(masterAndTailIntgrals)));
    list w = updateWeb(web, list(j, k), masterAndTailIntgrals);
    web = w[1];
    print("w[2] = " + string(w[2])); // Fixed debug message
    list masterIntgralsInSector = w[2];
    print("Size of masterIntgralsInSector = " + string(size(masterIntgralsInSector)));
    if (size(MI) == 0) {
        print("MI is empty, assigning masterIntgralsInSector to MI");
        MI = masterIntgralsInSector;
        print("MI is now: " + string(MI));
    } else {
        for (int i = 1; i <= size(masterIntgralsInSector); i++) {
            if (alreadyIntheList(MI, masterIntgralsInSector[i]) == 0) {
                print("Adding master integral to MI: " + string(masterIntgralsInSector[i]));
                MI[size(MI) + 1] = masterIntgralsInSector[i];
            }
        }
    }
    print("Completed computation in sector: " + string(k) + " at layer " + string(j) + ".");
    return list(reducedIBPs, MI);
$
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
list targetInt=list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
 list L = pickHighestSector(targetInt);
  if (size(L) > 1)                           //if size(L)>1, we have to do the same for each list in L.
  {
    ERROR("provided integrals belong to more than one integral class");
  }
  // L[1] is the list of target integrals belong to one integral family but it has arranged so that.. 
  //..L[1][1] is the integral belong to the superior sector.
 // we use this seed (i.e. target integral) to create the web structure 
 //When we do computation sequentially, it is better to have web structure of the sectors upfront.
 //We denote it by a list web, where web[i] contains the sectors belong to that layer.
  list web = generateWebSectors(L[1][1]);
web;
proc getlabels(list web, int i, int j)
{
  return(web[i][j].lab);  
}
getlabels (web,1,1);
web;
web[1][1].lab;
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
 
string(userInput);
  list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
proc OneSectorComputation(labeledgraph G1,list tailInts,list sector_lab )
"USAGE:  
ASSUME:  
RETURN:  
KEYWORDS: Feynman graph,IBPs
"
{ 
  list targetInt;
  setIBP reducedIBPs; //a place to store the independent IBPs coming out from current sector
  list MIs;  //a place to store the Master integrals coming out from current sector
  list OutputtailInts;  //a place to store the tail integrals coming out from current sector
  
//1.Extract target integrals for current sector (which are tail integrals coming from parent 
//sectors)
  for(int i=1;i<=size(tailInts);i++)
  {
    for(int j=1;j<=size(tailInts[i]);j++)
    {
            if(string(getSector(tailInts[i][j])[2])==string(sector_lab)){
        targetInt[size(targetInt)+1]=tailInts[i][j];
      }
    }
  }
  if(size(targetInt)==0){
    print("No input integrals came from the parents")
    return(reducedIBPs,MIs,OutputtailInts);
  }
  
//2. Computations related to sector
  setIBP totalIBP=computeManyIBP(G1,targetInt);
  list L=getRedIBPs(totalIBP,7853);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
  reducedIBPs.seed=sector_lab;
  reducedIBPs.over=G1.baikovover;
  reducedIBPs.IBP=L[1];
  for(int i=1;i<=size(L[2]);i++){
    if(string(getSector(L[2][i])[2])==string(sector_lab)){
      MIs[size(MIs)+1]=L[2][i];
    }
    else{
      OutputtailInts[size(OutputtailInts)+1]=L[2][i];
    }
  }
  
  return(list(reducedIBPs,MIs,OutputtailInts));
}
proc OneSectorComputation(labeledgraph G1,list tailInts,list sector_lab )
"USAGE:  
ASSUME:  
RETURN:  
KEYWORDS: Feynman graph,IBPs
"
{ 
  list targetInt;
  setIBP reducedIBPs; //a place to store the independent IBPs coming out from current sector
  list MIs;  //a place to store the Master integrals coming out from current sector
  list OutputtailInts;  //a place to store the tail integrals coming out from current sector
  
//1.Extract target integrals for current sector (which are tail integrals coming from parent 
//sectors)
  for(int i=1;i<=size(tailInts);i++)
  {
    for(int j=1;j<=size(tailInts[i]);j++)
    {
            if(string(getSector(tailInts[i][j])[2])==string(sector_lab)){
        targetInt[size(targetInt)+1]=tailInts[i][j];
      }
    }
  }
  if(size(targetInt)==0){
    print("No input integrals came from the parents")
    return(reducedIBPs,MIs,OutputtailInts);
  }
  
//2. Computations related to sector
  setIBP totalIBP=computeManyIBP(G1,targetInt);
  list L=getRedIBPs(totalIBP,7853);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
  reducedIBPs.seed=sector_lab;
  reducedIBPs.over=G1.baikovover;
  reducedIBPs.IBP=L[1];
  for(int i=1;i<=size(L[2]);i++){
    if(string(getSector(L[2][i])[2])==string(sector_lab)){
      MIs[size(MIs)+1]=L[2][i];
    }
    else{
      OutputtailInts[size(OutputtailInts)+1]=L[2][i];
    }
  }
  
  return(list(reducedIBPs,MIs,OutputtailInts));
}
  list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
$
LIB "feynman_copy.lib";
$
LIB "feynman_copy.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
list targetInt=list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
RB;
 list web=web_g(userInput);
 list userInput;
  userInput[1]=list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
 list web=web_g(userInput);
list userInput;
  userInput=list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
 list web=web_g(userInput);
web;
  list label_11=getlabels(web,1,1);
label_11;
 list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
 size(L[1]);
 size(L[2]);
R;
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
  print("L[1]: " + string(L[1]));
  print("L[2]: " + string(L[2]));
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
  print("size of L[1]: " + string(size(L[1])));
  print("size of L[2]: " + string(size(L[2])));
  size(L[1])<size(S.IBP);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
size(L[1]);
size(L[2]);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  print("current ring: " + string(currRing));
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
  list L=getRedIBPs(S,101);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  print("current ring: " + string(basering));
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
  list L=getRedIBPs(S,101);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  print("current ring: " + string(basering));
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
  print(" size of Z[1]:"+string(nrows(Z[1]))+" * "+string(ncols(Z[1])));
  print(" size of Z[2]:"+string(nrows(Z[2]))+" * "+string(ncols(Z[2])));
  print(" size of Z[3]:"+string(nrows(Z[3]))+" * "+string(ncols(Z[3])));
  print(" size of Z[4]:"+string(Z[4]));
   setring R;
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1, 1, 1, -1, -3, -1, -1, -1, -1));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1, 1, 1, -1, -3, -1, -1, -1, -1));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1, 1, 1, -1, -3, -1, -1, -1, -1));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1, 1, 1, -1, -3, -1, -1, -1, -1));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1, 1, 1, -1, -3, -1, -1, -1, -1));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1, 1, 1, -1, -3, -1, -1, -1, -1));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //here we compute set of IBPs correspond to two seeds seperately
  setIBP IBP1=computeIBP(G1,list(1,1,0,1,0,1,0,-1,0));
IBP1.IBP;
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  S;
s;
S;
S.IBP;
S.IBP[1];
S.IBP[1].c;
S.IBP[1].i;
S.IBP[1].c;
S.IBP[1].c[1];
list L;
size(S.IBP[1]);
size(S.IBP);
S.IBP[56].c[1];
for (int i=1;i<=size(S.IBP);i++){L[i]=S.IBP[i];}
L;
typeof(L);
L[1];
L[57];
L[57][1];
L[57].c;
list L;
L;
for (int i=1;i<=size(S.IBP);i++){L[i][1]=S.IBP[i][1]; L[i][2]=S.IBP[i][2];}
proc computeIBP(def G0,list Nu)
"USAGE:  computeIBP(G0,Nu); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The set of IBPS correspond to G0 and given Nu.
KEYWORDS: Feynman graph
"
{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  //return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0 = G1; 
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);
if(size(Nu) != n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}
module M1=computeM1(G,Nu);
module M2=computeM2(G,Nu);
timer=0;
option(redSB);
module M=std(intersect(M1,M2));
int elapsed_time=timer;
print("time elapsed for compute module intersection: " + string(elapsed_time));
// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
    }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}
//
ring Z=RB;
setIBP S;
S.over=Z;
S.seed=Nu;
//setring Z;
//module M=imap(RB,M);
int p=1;
for(int i=1;i<=size(M);i++){
  list y;
  list l;
  //computation of polynomial
  poly f=0;
  for(int j=1;j<=n;j++){
    f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));  
  }
  poly h=(D-L-E-1)/2;
  f=f-M[i][n+1]*h; 
  if(f != 0){
    int t=1;
      while(f != 0){
        y[t]=leadcoef(f);
        list nu;
        for(int k=1;k<=size(Nu);k++){
          nu[k]=Nu[k]-leadexp(f)[k];
        }
      l[t]=nu;
      t=t+1;
      f=f-lead(f);
      }
    oneIBP I;
    I.c=y;
    I.i=l;
    S.IBP[p]=I;
    p=p+1;  
  }
}
//ring Z= 0,(t(1..(m-1)),D),dp;
//S.over=Z;
list L;
for (int i=1;i<=size(S.IBP);i++){
  L[i][1]=S.IBP[i][1]; 
  L[i][2]=S.IBP[i][2];
}
S.IBP=L;
return(list(S,L));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  S;
proc computeIBP(def G0,list Nu)
"USAGE:  computeIBP(G0,Nu); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The set of IBPS correspond to G0 and given Nu.
KEYWORDS: Feynman graph
"
{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  //return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0 = G1; 
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);
if(size(Nu) != n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}
module M1=computeM1(G,Nu);
module M2=computeM2(G,Nu);
timer=0;
option(redSB);
module M=std(intersect(M1,M2));
int elapsed_time=timer;
print("time elapsed for compute module intersection: " + string(elapsed_time));
// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
    }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}
//
ring Z=RB;
setIBP S;
S.over=Z;
S.seed=Nu;
//setring Z;
//module M=imap(RB,M);
int p=1;
for(int i=1;i<=size(M);i++){
  list y;
  list l;
  //computation of polynomial
  poly f=0;
  for(int j=1;j<=n;j++){
    f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));  
  }
  poly h=(D-L-E-1)/2;
  f=f-M[i][n+1]*h; 
  if(f != 0){
    int t=1;
      while(f != 0){
        y[t]=leadcoef(f);
        list nu;
        for(int k=1;k<=size(Nu);k++){
          nu[k]=Nu[k]-leadexp(f)[k];
        }
      l[t]=nu;
      t=t+1;
      f=f-lead(f);
      }
    oneIBP I;
    I.c=y;
    I.i=l;
    S.IBP[p]=I;
    p=p+1;  
  }
}
//ring Z= 0,(t(1..(m-1)),D),dp;
//S.over=Z;
list LL;
for (int i=1;i<=size(S.IBP);i++){
  LL[i][1]=S.IBP[i][1]; 
  LL[i][2]=S.IBP[i][2];
}
S.IBP=L;
return(list(S,L));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  S;
proc computeIBP(def G0,list Nu)
"USAGE:  computeIBP(G0,Nu); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The set of IBPS correspond to G0 and given Nu.
KEYWORDS: Feynman graph
"
{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  //return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0 = G1; 
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);
if(size(Nu) != n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}
module M1=computeM1(G,Nu);
module M2=computeM2(G,Nu);
timer=0;
option(redSB);
module M=std(intersect(M1,M2));
int elapsed_time=timer;
print("time elapsed for compute module intersection: " + string(elapsed_time));
// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
    }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}
//
ring Z=RB;
setIBP S;
S.over=Z;
S.seed=Nu;
//setring Z;
//module M=imap(RB,M);
int p=1;
for(int i=1;i<=size(M);i++){
  list y;
  list l;
  //computation of polynomial
  poly f=0;
  for(int j=1;j<=n;j++){
    f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));  
  }
  poly h=(D-L-E-1)/2;
  f=f-M[i][n+1]*h; 
  if(f != 0){
    int t=1;
      while(f != 0){
        y[t]=leadcoef(f);
        list nu;
        for(int k=1;k<=size(Nu);k++){
          nu[k]=Nu[k]-leadexp(f)[k];
        }
      l[t]=nu;
      t=t+1;
      f=f-lead(f);
      }
    oneIBP I;
    I.c=y;
    I.i=l;
    S.IBP[p]=I;
    p=p+1;  
  }
}
//ring Z= 0,(t(1..(m-1)),D),dp;
//S.over=Z;
list LL;
for (int i=1;i<=size(S.IBP);i++){
  LL[i][1]=S.IBP[i][1]; 
  LL[i][2]=S.IBP[i][2];
}
return(list(S,LL));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  S;
S;
def R=S.over;
  setring R;
S.over;
def R=S.over;
ring R=S.over;
ring S.over;
def R=S.over;
S.over;
R;
def RR=S.over;
typof(S.over);
typeof(S.over);
def RR=S.over
;
list D=S.over;
typeof(D);
system("D");
list D=S.over;
S;
proc computeIBP(def G0,list Nu)
"USAGE:  computeIBP(G0,Nu); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The set of IBPS correspond to G0 and given Nu.
KEYWORDS: Feynman graph
"
{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  //return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0 = G1; 
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);
if(size(Nu) != n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}
module M1=computeM1(G,Nu);
module M2=computeM2(G,Nu);
timer=0;
option(redSB);
module M=std(intersect(M1,M2));
int elapsed_time=timer;
print("time elapsed for compute module intersection: " + string(elapsed_time));
// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
    }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}
//
ring Z=RB;
setIBP S;
S.over=Z;
S.seed=Nu;
//setring Z;
//module M=imap(RB,M);
int p=1;
for(int i=1;i<=size(M);i++){
  list y;
  list l;
  //computation of polynomial
  poly f=0;
  for(int j=1;j<=n;j++){
    f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));  
  }
  poly h=(D-L-E-1)/2;
  f=f-M[i][n+1]*h; 
  if(f != 0){
    int t=1;
      while(f != 0){
        y[t]=leadcoef(f);
        list nu;
        for(int k=1;k<=size(Nu);k++){
          nu[k]=Nu[k]-leadexp(f)[k];
        }
      l[t]=nu;
      t=t+1;
      f=f-lead(f);
      }
    oneIBP I;
    I.c=y;
    I.i=l;
    S.IBP[p]=I;
    p=p+1;  
  }
}
//ring Z= 0,(t(1..(m-1)),D),dp;
//S.over=Z;
return(S);
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  S;
 list LL;
  
  for (int i = 1; i <= size(S.IBP); i++)
  {
    //write(l, "S.IBP[i]", string(S.IBP[i]));
    LL[i][1] = S.IBP[i].c; 
    LL[i][2] = S.IBP[i].i;
  }
LL;
S.IBP[1].c;
LL[1][1]=S.IBP[1].c;
typeof(S.IBP[1].c);
typeof(S.IBP[1].c[1]);
LL[1][1]=S.IBP[1].i;
typeof(S.IBP[1].i);
typeof(S.IBP[1].i[1]);
LL[1][1]=list(S.IBP[1].i);
// Assume S is the setIBP object from computeIBP
ring R = S.over;
setring R;
list LL;
for (int i = 1; i <= size(S.IBP); i++)
{
    LL[i] = list(); // Initialize LL[i] as a list
    LL[i][1] = S.IBP[i].c; // Assign the 'c' field (list)
    LL[i][2] = S.IBP[i].i; // Assign the 'i' field (list)
}
// Optional: Inspect the results
print(LL[1][1]); // Should print S.IBP[1].c
print(LL[1][2]); // Should print S.IBP[1].i
S.seed;
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S);
L;
string(L);
L[1];
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S);
L[1];
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeIBP(G1,targetInt);
  ring R=S.over;
  setring R;
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeManyIBP(G1,targetInt);
  ring R=S.over;
  setring R;
;
;
;
;
ed,
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeManyIBP(G1,targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  oneIBP I=S.IBP[1];
  I;
I.i;
string(I.i);
string(I.c);
  list rowCorrespondToI=extractCoef(I,ind,list(1,2,3)); 
string(rowCorrespondToI);
  rowCorrespondToI[90]; //output will be 7
proc extractCoef(oneIBP I,list ind,list l)
"USAGE:   extractCoef(I,ind,l); I oneIBP,ind list,l list,
ASSUME:   ind is the output of getSortedIntegrals, and l is the list of values over the base field I.baikovover. 
          size(l)=npars(I.baikovover)
RETURN:   list of values where, the i-th element is the evaluation of coefficient function  at values in the list l of the IBP relation oneIBP, whose index is i=ind[i][1].
KEYWORDS: feynman graph,IBPs
EXAMPLE:  extractCoef; shows an example
"
{ list v;
  print("size(ind)="+string(size(ind)));
  print("l is "+string(l));
  for(int j=1;j <= size(ind);j++){
    int tem=0;
    for(int k=1;k <= size(I.c);k++){
      print("ind[j][1]="+string(ind[j][1]));
      print("I.i[k]="+string(I.i[k]));
      print("comp_lex(ind[j][1],I.i[k])="+string(comp_lex(ind[j][1],I.i[k])));
      if(comp_lex(ind[j][1],I.i[k])==0){
        print("substituteList(I.c[k],l)="+string(substituteList(I.c[k],l)));
        v[j]=substituteList(I.c[k],l);
        print("v[j]="+string(v[j]));
        tem++;
      }
      if(tem==0){
        print("tem is 0");
        v[j]=0;
      }
    }
  } 
  return(v); 
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeManyIBP(G1,targetInt);
  ring R=S.over;
  setring R;
 list ind = getSortedIntegrals(S);
  oneIBP I=S.IBP[1];
  I;
  list rowCorrespondToI=extractCoef(I,ind,list(1,2,3)); 
$
LIB "feynman.lib";
proc extractCoef(oneIBP I,list ind,list l)
"USAGE:   extractCoef(I,ind,l); I oneIBP,ind list,l list,
ASSUME:   ind is the output of getSortedIntegrals, and l is the list of values over the base field I.baikovover. 
          size(l)=npars(I.baikovover)
RETURN:   list of values where, the i-th element is the evaluation of coefficient function  at values in the list l of the IBP relation oneIBP, whose index is i=ind[i][1].
KEYWORDS: feynman graph,IBPs
EXAMPLE:  extractCoef; shows an example
"
{ list v;
  print("size(ind)="+string(size(ind)));
  print("l is "+string(l));
  for(int j=1;j <= size(ind);j++){
    int tem=0;
    for(int k=1;k <= size(I.c);k++){
      print("ind[j][1]="+string(ind[j][1]));
      print("I.i[k]="+string(I.i[k]));
      print("comp_lex(ind[j][1],I.i[k])="+string(comp_lex(ind[j][1],I.i[k])));
      if(comp_lex(ind[j][1],I.i[k])==0){
        print("I.c[k]="+string(I.c[k]));
        print("substituteList(I.c[k],l)="+string(substituteList(I.c[k],l)));
        v[j]=substituteList(I.c[k],l);
        print("v[j]="+string(v[j]));
        tem++;
      }
      if(tem==0){
        print("tem is 0");
        v[j]=0;
      }
    }
  } 
  return(v); 
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeManyIBP(G1,targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  oneIBP I=S.IBP[1];
  I;
string(I.c);
string(I.i);
  list rowCorrespondToI=extractCoef(I,ind,list(1,2,3)); 
proc extractCoef(oneIBP I,list ind,list l)
"USAGE:   extractCoef(I,ind,l); I oneIBP,ind list,l list,
ASSUME:   ind is the output of getSortedIntegrals, and l is the list of values over the base field I.baikovover. 
          size(l)=npars(I.baikovover)
RETURN:   list of values where, the i-th element is the evaluation of coefficient function  at values in the list l of the IBP relation oneIBP, whose index is i=ind[i][1].
KEYWORDS: feynman graph,IBPs
EXAMPLE:  extractCoef; shows an example
"
{ list v;
  print("size(ind)="+string(size(ind)));
  print("l is "+string(l));
  for(int j=1;j <= size(ind);j++){
    int tem=0;
    for(int k=1;k <= size(I.c);k++){
      print("ind["+string(j)+"][1]="+string(ind[j][1]));
      print("I.i["+string(k)+"]="+string(I.i[k]));
      print("comp_lex(ind["+string(j)+"][1],I.i["+string(k)+"])="+string(comp_lex(ind[j][1],I.i[k])));
      if(comp_lex(ind[j][1],I.i[k])==0){
        print("I.c["+string(k)+"]="+string(I.c[k]));
        print("substituteList(I.c["+string(k)+"],l)="+string(substituteList(I.c[k],l)));
        v[j]=substituteList(I.c[k],l);
        print("v[j]="+string(v[j]));
        tem++;
      }
      if(tem==0){
        print("tem is 0");
        v[j]=0;
      }
    }
  } 
  return(v); 
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeManyIBP(G1,targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  oneIBP I=S.IBP[1];
  I;
  string(I.i);
  string(I.c);
  list rowCorrespondToI=extractCoef(I,ind,list(1,2,3)); 
$
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
  list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); //L list of pair of sorted integrals and the corresponding sorting measures
L[1];
;
string(L[1]);
  list L=getSortedIntegrals(S); //L list of pair of sorted integrals and the corresponding sorting measures
string(L[1]);
L[1];
size(L[1]);
size(L[2]);
string(L[1]);
string(L[2]);
string(L);
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); //L l
size(L)
;
size(L);
size(L[1]);
string(L[1]);
string(L[1][1]);
string(L[1][2]);
string(L[1][2]);$
LIB "feynman_copy.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt[1]);
  list web = generateWebSectors(L[1][1]);
  return(web);
}
  list web=web_g(userInput);
we$
LIB "feynman_copy.lib";
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt[1]);
  list web = generateWebSectors(L[1][1]);
  return(web);
}
proc getlabels(list web, int i, int j)
{
  list labs = web[i][j].lab;
  return(labs);  
}
;
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  list web=web_g(userInput);
web;
string(web);
size(web);
string(web[1]);
string(web[1].lab);
string(web[1][1].lab);
string(web[1][1].targetInts);
proc web_g(list targetInt)
{
  print("targetInt: " + string(targetInt[1]));
  list L = pickHighestSector(targetInt[1]);
  // print L
  print("L: " + string(L));
  print("L[1][1]: " + string(L[1][1]));
  list web = generateWebSectors(L[1][1]);
  return(web);
}
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  print("targetInt: " + string(targetInt[1]));
  list L = pickHighestSector(targetInt[1]);
  // print L
  print("L=pickHighestSector(targetInt[1]): " + string(L));
  print("L[1][1]: " + string(L[1][1]));
  list web = generateWebSectors(L[1][1]);
  return(web);
}
;
  list web=web_g(userInput);
web;
 list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
w;
 list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
w;
string(w);
$
LIB "feynman_copy.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  list web=web_g(userInput);
$
LIB "feynman_copy.lib";
 list l = list(1,-1,0,1,2,-2);
  list w = generateWebSectors(l);
  print_web(w);
proc print_web(list web)
"USAGE: print_web(web); web = list of lists of oneSector structs"
{
  print(" web is :");
  if (size(web) == 0) {
    print("  (empty list)");
    return;
  }
  for (int i = 1; i <= size(web); i++) {
    print("  Layer " + string(i) + ":");
    list layer = web[i];
    for (int j = 1; j <= size(layer); j++) {
      if (typeof(layer[j]) == "oneSector" && defined(layer[j].lab)) {
        print("    Sector " + string(j) + ":");
        print("      lab = " + string(layer[j].lab));
        print("      sectorMap = " + string(layer[j].sectorMap));
        print("      targetInts:");
        for (int k = 1; k <= size(layer[j].targetInts); k++) {
          string s = "        [" + string(k) + "] = ";
          for (int l = 1; l <= size(layer[j].targetInts[k]); l++) {
            s = s + string(layer[j].targetInts[k][l]);
            if (l < size(layer[j].targetInts[k])) { s = s + ","; }
          }
          print(s);
        }
      } else {
        print("    Sector " + string(j) + " = (invalid or undefined)");
      }
    }
  }
}
  print_web(w);
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  
  // Properly structure userInput as a list containing a single list of integrals
  list userInput = list();
  userInput[1] = list(
    list(1,1,1,-1,-3,-1,-1,-1,-1),
    list(1,-1,1,-1,-3,-1,-1,-4,-1)
  );
  labeledgraph G1 = computeBaikovMatrix(G);
  ring RB = G1.baikovover;
 
  //sector at(1,1), label:{1,2,3} computations
  list web = web_g(userInput[1]); // Pass the list of integrals, not the container
  list label_11 = getlabels(web,1,1);
 print("label_11 = " + string(label_11)); // Debug print
  list SectOutput_11 = OneSectorComputation(G1, userInput, label_11);
  list tail_11 = SectOutput_11[3];
web
;
    print_web(web);
$
LIB "feynman_copy.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
  list web=web_g(userInput);
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  list web=web_g(userInput);
proc getSector(list l)
"USAGE:   getSector(l); l list@*
ASSUME:   l is a list of integer indices of a Feynman integral
RETURN : list L, L[1] = s The sector(a list of 1s and 0s) that the corresponding integral belongs
L[2] = n the sector(a list of indices of s where has non - zero entries) that the corresponding integral belongs
KEYWORDS : Feynman graph
"
{
  
  print("l is " + string(l));
  list s;
  list n;
  for (int i = 1;i <= size(l);i++) {
    if (l[i] > 0) {
      s[i] = 1;
      n[size(n) + 1] = i;
      print("n is "+string(n));
    }
    else
    {
      s[i] = 0;
    }
  }
  print("s is ");
  print(s);
  return(list(s, n));
}
  list web=web_g(userInput);
proc getSector(list l)
"USAGE:   getSector(l); l list@*
ASSUME:   l is a list of integer indices of a Feynman integral
RETURN : list L, L[1] = s The sector(a list of 1s and 0s) that the corresponding integral belongs
L[2] = n the sector(a list of indices of s where has non - zero entries) that the corresponding integral belongs
KEYWORDS : Feynman graph
"
{
  
  print("l is " + string(l));
  list s;
  list n;
  for (int i = 1;i <= size(l);i++) {
    if (l[i] > 0) {
      s[i] = 1;
      n[size(n) + 1] = i;
    }
    else
    {
      s[i] = 0;
    }
  }
  return(list(s, n));
}
  list web=web_g(userInput);
proc getSector(list l)
"USAGE:   getSector(l); l list@*
ASSUME:   l is a list of integer indices of a Feynman integral
RETURN : list L, L[1] = s The sector(a list of 1s and 0s) that the corresponding integral belongs
L[2] = n the sector(a list of indices of s where has non - zero entries) that the corresponding integral belongs
KEYWORDS : Feynman graph
"
{
  print("l is "+string(l));
  list s;
  list n;
  for (int i = 1;i <= size(l);i++) {
    if (l[i] > 0) {
      s[i] = 1;
      n[size(n) + 1] = i;
    }
    else
    {
      s[i] = 0;
    }
  }
  print("s is "+string(s));
  print("n is "+string(n));
  return(list(s, n));
}
  list web=web_g(userInput);
proc getSector(list l)
"USAGE:   getSector(l); l list@*
ASSUME:   l is a list of integer indices of a Feynman integral
RETURN : list L, L[1] = s The sector(a list of 1s and 0s) that the corresponding integral belongs
L[2] = n the sector(a list of indices of s where has non - zero entries) that the corresponding integral belongs
KEYWORDS : Feynman graph
"
{
  list s;
  list n;
  for (int i = 1;i <= size(l);i++) {
    if (l[i] > 0) {
      s[i] = 1;
      n[size(n) + 1] = i;
    }
    else
    {
      s[i] = 0;
    }
  }
  return(list(s, n));
}
  list l = list(1,2,-3,-4,0,1);
  list s = getSector(l);
list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  list L = pickHighestSector(targetInt);
list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
;
list L = pickHighestSector(userInput);
list L = pickHighestSector(userInput);
userInput;
list setInt = list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web
  list L = pickHighestSector(setInt);
  size(L);
$
LIB "feynman_copy.lib";
list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  list web=web_g(userInput);
  print_web(web);
proc print_web(list web)
"USAGE: print_web(web); web = list of lists of oneSector structs"
{
  print(" web is :");
  if (size(web) == 0) {
    print("  (empty list)");
    return;
  }
  for (int i = 1; i <= size(web); i++) {
    print("  Layer " + string(i) + ":");
    list layer = web[i];
    for (int j = 1; j <= size(layer); j++) {
      if (typeof(layer[j]) == "oneSector" && defined(layer[j].lab)) {
        print("    Sector " + string(j) + ":");
        print("      lab = " + string(layer[j].lab));
        print("      sectorMap = " + string(layer[j].sectorMap));
        print("      targetInts:");
        for (int k = 1; k <= size(layer[j].targetInts); k++) {
          string s = "        [" + string(k) + "] = ";
          for (int l = 1; l <= size(layer[j].targetInts[k]); l++) {
            s = s + string(layer[j].targetInts[k][l]);
            if (l < size(layer[j].targetInts[k])) { s = s + ","; }
          }
          print(s);
        }
      } else {
        print("    Sector " + string(j) + " = (invalid or undefined)");
      }
    }
  }
}
  print_web(web);
proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));
// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));
for (int j = 1; j <= size(T[i]); j++)
{
//  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")"+  "    ("+string(labels[i])+")");
}
// Generate edges
for (int i = 1; i < size(T); i++)
{
  for (int j = 1; j <= size(T[i]); j++)
{
    for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
print("Edges:");
for (int i = 1; i <= size(edges); i++)
{
print("("+string(edges[i][1][1]) + ", " + string(edges[i][1][2])+")"+  "    ("+string(edges[i][2][1]) + ", " + string(edges[i][2][2])+")");
}
return(list(vertices, edges, labels));
}
// Helper function to determine subset
proc subset(list small, list big)
{
for (int i = 1; i <= size(small); i++)
{
  if (!contains(big, small[i])) 
      {return(0);}
  }
return(1);
}
// Helper function to check if list contains element
proc contains(list L, int x)
{
for (int i = 1; i <= size(L); i++)
{
  if (L[i] == x){
    return (1);
  }
}
return(0);
}
//************************************************************************************************************************** */
getGraph(web);
getGraph(web);
getGraph(web);
getGraph(web);
$
   list tail_00 = list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
LIB "feynman.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
   //list tail_01 = list(list(1,1,1,1,1,1,1,0,-5), list(1,1,1,1,1,1,1,-1,-4));
list tail= list(
list(1,1,1,1,1,1,1,-5,0),
list(1,1,1,1,1,1,1,0,-5),
list(0,1,1,1,1,1,1,-5,0),
list(1,0,1,1,1,1,1,0,-5),
list(1,1,0,1,1,1,1,-5,0),
list(1,1,1,0,1,1,1,0,-5),
list(1,1,1,1,0,1,1,-5,0),
list(1,1,1,1,1,0,1,0,-5),
list(1,1,1,1,1,1,0,-5,0),
list(0,1,1,1,1,1,1,0,-5),
list(1,0,1,1,1,1,1,-5,0),
list(1,1,0,1,1,1,1,0,-5),
list(1,1,1,0,1,1,1,-5,0),
list(1,1,1,1,0,1,1,0,-5),
list(1,1,1,1,1,0,1,-5,0),
list(1,1,1,1,1,1,0,0,-5)
);
   //userInput[1]=tail_00;
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  print("targetInt: " + string(targetInt[1]));
  list LL = pickHighestSector(targetInt[1]);
  // print L
  print("L=pickHighestSector(targetInt[1]): " + string(LL));
  print("LL[1].size(): " + string(size(LL[1])));
  print("LL[1][1]: " + string(LL[1][1]));
  list web = generateWebSectors(LL[1][1]);
  return(web);
}
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
   //list tail_01 = list(list(1,1,1,1,1,1,1,0,-5), list(1,1,1,1,1,1,1,-1,-4));
list tail= list(
list(1,1,1,1,1,1,1,-5,0),
list(1,1,1,1,1,1,1,0,-5),
list(0,1,1,1,1,1,1,-5,0),
list(1,0,1,1,1,1,1,0,-5),
list(1,1,0,1,1,1,1,-5,0),
list(1,1,1,0,1,1,1,0,-5),
list(1,1,1,1,0,1,1,-5,0),
list(1,1,1,1,1,0,1,0,-5),
list(1,1,1,1,1,1,0,-5,0),
list(0,1,1,1,1,1,1,0,-5),
list(1,0,1,1,1,1,1,-5,0),
list(1,1,0,1,1,1,1,0,-5),
list(1,1,1,0,1,1,1,-5,0),
list(1,1,1,1,0,1,1,0,-5),
list(1,1,1,1,1,0,1,-5,0),
list(1,1,1,1,1,1,0,0,-5)
);
   //userInput[1]=tail_00;
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
getGraph(web);
// Create graph
graph G = makeGraph(
  list(1,2,3,4,5,6),
  list(
    list(6,1), list(4,6), list(1,2), list(3,5),
    list(4,3), list(2,5), list(5,6), list(1),
    list(2), list(3), list(4)
  )
);
// Initial input
list tail_00 = list(
  list(1, 1, 1, -1, -3, -1, -1, -1, -1),
  list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
list userInput; userInput[1] = tail_00;
labeledgraph G1 = computeBaikovMatrix(G);
ring RB = G1.baikovover;
print("starting sector at(1,1)");
list web = web_g(userInput);
list label_11 = getlabels(web, 1, 1);
$
$
 link l="ssi:r temp/waas_71327_1745427457742431296";
 def m=read(l);
 m.r_data;
 def nr=m.r_data;
 setring nr;
 m.data[1];
 def m=read(l);
$
$
