;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeManyIBP(G,targetInt);
S;
size(S);
  size(S.IBP);  
  setIBP SS=computeManyIBP(G,top);
  list top = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1));
  setIBP SS=computeManyIBP(G,top);
  size(SS.IBP);  
  size(SS.IBP);  
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  
  list w2=updateWeb(web,list(1,1),L1[1]); //up
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
 list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web
  list L=pickHighestSector(setInt);
  size(L);
$
LIB "feynman.lib";
  list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web
  list L=pickHighestSector(setInt);
  size(L);
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  list w2=updateWeb(web,list(1,1),L1[1]); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web
web=w2[1]; 
  setIBP S=computeIBP(G1,L1[1][1]);
  ring R=S.over;
setring R;
  list L=getRedIBPs(S,101); //L[1]=list of independent IBPs,L[2]=list of master integrals
  list independIBPs=L[1];
  list masterAndTailIntgrals=L[2];
  size(independIBPs) < size(S.IBP); //number of linearly independent set of IBPs are less than the number of orginal IBPs. So this returns true
  list w2=updateWeb(web,list(1,1),masterAndTailIntgrals);
w2[1];
w2[1][2][1];
w2[1][2][1].targetInts;
w2[1][2][1].targetInts;$
$
LIB "feynman.lib";
$
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list finalset=getReducedIBPSystem(G,targetInt);
$
LIB "feynman.lib";
  list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
   // L[1] is the list of target integrals belong to one integral family but it has arranged so that.. 
   //..L[1][1] is the integral belong to the superior sector.
  // we use this seed (i.e. target integral) to create the web structure 
  //When we do computation sequentially, it is better to have web structure of the sectors upfront.
  //We denote it by a list web, where web[i] contains the sectors belong to that layer.
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  //After creating the web, we have to update it by including the target integrals to the corresponding sectors
  //Because, when we do the intended computation in sectors, we read seeds from this updated 
  //This update step need to perform with tail integrals of each sector, once the computations correspond to sectors in each layer are done. 
  //If the computation done correctly, tail integrals will only be assigned to the sectors in the below layers.
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  // *this return a list w4, where w4[1] is the updated web and
  // w4[2] is the list of integrals that does not belong to the current web (if any have. usually dont!) 
  // We set two places to store reduced IBP relations (a setIBP), and master integrals (a list) that are comes from..
  //..the intended computations relevent to each sector   
  
  //before we go further,we first create the labelled graph G1 of G computing Baikov matrix
  
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  int nLayers=1;
  for(int j=1; j <= nLayers; j++)
    {
//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.
    //  int nSectors=size(web[j]);
      int nSectors=1;
      for(int k=1; k <= nSectors; k++)
      {
        
        if(size(web[j][k].targetInts)>=1)
        {
          print("size(web[j][k].targetInts)");
          print(size(web[j][k].targetInts));
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
;
;
;
 link l="ssi:r temp/waas_1599879_1739453089801077133";
 def m=read(l);
 m.r_data;
 def nr=m.r_data;
 setring nr;
 m.data[1];
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
;
;
;
;
;
;
;
;
;
;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
L;
L[1];
size(L[1]);
size(L[2]);
size(L[3]);
size(L);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  print("Z");
  print(Z);  
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
  setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  print("Z[4]="+string(Z[4]));
  print("ncols(Z[1])="+string(ncols(Z[1])));
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
  setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  print("Z[4]="+string(Z[4]));
  print("ncols(Z[1])="+string(ncols(Z[1])));
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  print("ncols(Z[3])="+string(ncols(Z[3])));
  print("nrows(Z[3])="+string(nrows(Z[3])));
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
  setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  print("Z[4]="+string(Z[4]));
  print("ncols(Z[1])="+string(ncols(Z[1])));
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  print("ncols(Z[3])="+string(ncols(Z[3])));
  print("nrows(Z[3])="+string(nrows(Z[3])));
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
print("l="+string(l));
  }
  return(list(indIBP,seed));
}
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
  setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  print("Z[4]="+string(Z[4]));
  print("ncols(Z[1])="+string(ncols(Z[1])));
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  print("ncols(Z[3])="+string(ncols(Z[3])));
  print("nrows(Z[3])="+string(nrows(Z[3])));
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
print("size(seed)="+string(size(seed)));
  return(list(indIBP,seed));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);
  setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
L;
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }

  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);

  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
print("web=w4[1]"); 
print(web);
print(" ");
 
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  

  int nLayers=size(web);
  int nLayers=1;
int j=1;

//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.

    //  int nSectors=size(web[j]);
      int nSectors=1;
int k=1;
        
  
          print("size(web[j][k].targetInts)");
          print(size(web[j][k].targetInts));
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            print("totalIBP.over");
            print(totalIBP.over);
            reducedIBPs.over=totalIBP.over;

            print("reducedIBPs.over After");
            print(reducedIBPs.over);
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
//using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
          list L=getRedIBPs(totalIBP,101);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
L[2];
 print("masterAndTailIntgrals");
          print(masterAndTailIntgrals);
// update reducedIBPs. 
          setring R;
          print("size(reducedIBPs.IBP)");
          print(size(reducedIBPs.IBP));
          
  if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
            print("reducedIBPs.IBP_Before");
            print(size(reducedIBPs.IBP));
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];

            }
            print("reducedIBPs.IBP_After");
            print(size(reducedIBPs.IBP));
          }
    kill R;
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);

w;
web;
masterAndTailIntgrals
;
w;
