;
LIB "feynman.lib";
$
$
LIB "feynman.lib";
LIB "feynman.lib";
$
LIB "feynman.lib";
 list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  for(int j=1; j <= 1; j++)
    {
      int nSectors=size(web[j]);
      for(int k=1; k <= 1; k++)
      {
        
        if(size(web[j][k].targetInts)>=1)
        {
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            reducedIBPs.over=totalIBP.over;
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
          list L=getRedIBPs(totalIBP,101);   
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
// update reducedIBPs. 
          setring R;
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
          }
    kill R;
//Update the sectors below to the current sector using masterAndTailIntgrals. In this step, we can also.. 
//..distingush the master integrals which will be assigned to MI.
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
         print("w[2]=",w2);
;
;
;
;
;
;
;
;l
;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
  for(int j=1; j <= 1; j++)
    {
      int nSectors=size(web[j]);
      for(int k=1; k <= 1; k++)
      {
        
        if(size(web[j][k].targetInts)>=1)
        {
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            reducedIBPs.over=totalIBP.over;
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
          list L=getRedIBPs(totalIBP,101);   
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
// update reducedIBPs. 
          setring R;
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
          }
    kill R;
//Update the sectors below to the current sector using masterAndTailIntgrals. In this step, we can also.. 
//..distingush the master integrals which will be assigned to MI.
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
         print("w[2]=",w2);
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
x
:
:
:
LIB "feynman.lib";
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
int j=1;
      int nSectors=size(web[j]);
   int k=1;
        
        if(size(web[j][k].targetInts)>=1)
        {
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            reducedIBPs.over=totalIBP.over;
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
          list L=getRedIBPs(totalIBP,101);   
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
// update reducedIBPs. 
          setring R;
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
          }
    kill R;
//Update the sectors below to the current sector using masterAndTailIntgrals. In this step, we can also.. 
//..distingush the master integrals which will be assigned to MI.
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
         print("w[2]=",w2);
$
$
$
q
LIB "feynman.lib";
$
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int j=1;
      int nSectors=size(web[j]);
   int k=1;
        
        if(size(web[j][k].targetInts)>=1)
        {
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            reducedIBPs.over=totalIBP.over;
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
          list L=getRedIBPs(totalIBP,101);   
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
  
          setring R;
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
          }
           kill R;
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
         print("w[2]=",w2);
;
;
;
;
;
;
;
;
;
;
;:
;m
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int j=1;
      int nSectors=size(web[j]);
   int k=1;
te;
size(web[j][k].targetInts;
size(web[j][k].targetInts);
setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
            reducedIBPs.over=totalIBP.over;
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
          list L=getRedIBPs(totalIBP,101);   
          list indpndIBP=L[1];
          list masterAndTailIntgrals=L[2];
  
          setring R;
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
          }
           kill R;
list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated
         print("w[2]=",w2);
         print("w[2]=",w[2]);
         print("w[2]=" + string(w[2]));
size(w[2]);
$
LIB "feynman.lib";
proc getReducedIBPSystem(graph G, list targetInt)
"USAGE:  getReducedIBPSystem(G,targetInt); targetInt list, G graph@*,
ASSUME:  G is a graph and targetInt is a list of seeds of target integrals. 
RETURN:  list (reducedIBPs,MI) where  reducedIBPs::setIBP, MI::list.
          reducedIBPs contain the reduced IBP system for the target integrals
          MI contain the master integrals
KEYWORDS: Feynman graph, IBPs
"
{
    if (size(targetInt) == 0) {
        ERROR("Empty target integral list provided.");
    }
    // Ensure the input graph G is used
    print("Graph G: " + string(G));
    print("Target Integrals: " + string(targetInt));
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
    web = setSectorMap(web);
    print("Generated web: " + string(web));
    list w4 = updateWeb(web, list(1,1), targetInt);
    web = w4[1];
    labeledgraph G1 = computeBaikovMatrix(G);
    setIBP reducedIBPs;
    list MI;
    int te = 0;
    reducedIBPs.seed = targetInt;
    int j = 1;
    if (size(web) < j) {
        ERROR("web list does not contain layer j=" + string(j));
    }
    int nSectors = size(web[j]);
    if (nSectors == 0) {
        ERROR("No sectors available in web[" + string(j) + "]");
    }
    int k = 1;
    if (size(web[j]) < k) {
        ERROR("web[" + string(j) + "] does not contain sector k=" + string(k));
    }
    print("Computing IBP for sector: " + string(web[j][k]));
    
    setIBP totalIBP = computeManyIBP(G1, web[j][k].targetInts);
    if (te == 0) {
        reducedIBPs.over = totalIBP.over;
        te = 1;
    }
    ring R = reducedIBPs.over;
    setring R;
    list L = getRedIBPs(totalIBP, 101);
    if (size(L) < 2) {
        ERROR("getRedIBPs did not return expected two lists.");
    }
    list indpndIBP = L[1];
    list masterAndTailIntgrals = L[2];
    if (size(reducedIBPs.IBP) == 0) {
        reducedIBPs.IBP = indpndIBP;
    } else {
        for (int i = 1; i <= size(indpndIBP); i++) {
            reducedIBPs.IBP[size(reducedIBPs.IBP) + 1] = indpndIBP[i];
        }
    }
    kill R;
    print("size of masterAndTailIntgrals = " + string(size(masterAndTailIntgrals)));
    list w = updateWeb(web, list(j, k), masterAndTailIntgrals);
    web = w[1];
    print("w[2] = " + string(w[2]));
    list masterIntgralsInSector = w[2];
    print("size of masterIntgralsInSector = " + string(size(masterIntgralsInSector)));
    if (size(MI) == 0) {
        MI = masterIntgralsInSector;
    } else {
        for (int i = 1; i <= size(masterIntgralsInSector); i++) {
            if (alreadyIntheList(MI, masterIntgralsInSector[i]) == 0) {
                MI[size(MI) + 1] = masterIntgralsInSector[i];
            }
        }
    }
    print("Completed computation in sector: " + string(k) + " at layer " + string(j) + ".");
    return list(reducedIBPs, MI);
}
// Define a sample Feynman graph G
graph G = makeGraph(
    list(1,2,3,4,5,6), 
    list(
        list(6,1), list(4,6), list(1,2), list(3,5), 
        list(4,3), list(2,5), list(5,6), list(1), 
        list(2), list(3), list(4)
    )
);
// Define a list of target integrals
list targetInt = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1), 
    list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
// Call the function
list result = getReducedIBPSystem(G, targetInt);
// Extract results
setIBP reducedIBPs = result[1];
list MI = result[2];
// Print results
print("Reduced IBPs: " + string(reducedIBPs));
print("Master Integrals: " + string(MI));
print("size_Updated web: " + string(size(web)));
$
LIB "feynman.lib";
$
LIB "feynman.lib";
  graph G = makeGraph(
    list(1,2,3,4,5,6), 
    list(
        list(6,1), list(4,6), list(1,2), list(3,5), 
        list(4,3), list(2,5), list(5,6), list(1), 
        list(2), list(3), list(4)
    )
  );
  
  // Define a list of target integrals
  list targetInt = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1), 
    list(1, -1, 1, -1, -3, -1, -1, -4, -1)
  );
    if (size(targetInt) == 0) {
        ERROR("Empty target integral list provided.");
    }
    // Ensure the input graph G is used
    print("Graph G: " + string(G));
    print("Target Integrals: " + string(targetInt));
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
    web = setSectorMap(web);
    print("Generated web: " + string(web));
   list w4 = updateWeb(web, list(1,1), targetInt);
    web = w4[1];
print("size_Updated web: " + string(size(web)));
    labeledgraph G1 = computeBaikovMatrix(G);
    setIBP reducedIBPs;
    list MI;
print("size of targetInt: " + string(size(targetInt)));
print("size of targetInt: " + string((targetInt)));
 int te = 0;
    reducedIBPs.seed = targetInt;
    int j = 1;
    if (size(web) < j) {
        ERROR("web list does not contain layer j=" + string(j));
    }
    int nSectors = size(web[j]);
    if (nSectors == 0) {
        ERROR("No sectors available in web[" + string(j) + "]");
    }
    int k = 1;
    if (size(web[j]) < k) {
        ERROR("web[" + string(j) + "] does not contain sector k=" + string(k));
    }
    print("Computing IBP for sector: " + string(web[j][k]));
    
 setIBP totalIBP = computeManyIBP(G1, web[j][k].targetInts);
print("size of totalIBP.IBP: " + string(size(totalIBP.IBP)));
   print("Computing IBP for sector: " + string(web[j][k]));
    
    setIBP totalIBP = computeManyIBP(G1, web[j][k].targetInts);
print("size of totalIBP.IBP: " + string(size(totalIBP.IBP)));
    if (te == 0) {
        reducedIBPs.over = totalIBP.over;
        te = 1;
    }
    ring R = reducedIBPs.over;
    setring R;
    list L = getRedIBPs(totalIBP, 101);
    if (size(L) < 2) {
        ERROR("getRedIBPs did not return expected two lists.");
    }
 list indpndIBP = L[1];
    list masterAndTailIntgrals = L[2];
    print("size of indpndIBP: " + string(size(indpndIBP)));
    print("size of masterAndTailIntgrals: " + string(size(masterAndTailIntgrals)));
$
LIB "feynman.lib";
graph G = makeGraph(
  list(1,2,3,4,5,6), 
  list(
      list(6,1), list(4,6), list(1,2), list(3,5), 
      list(4,3), list(2,5), list(5,6), list(1), 
      list(2), list(3), list(4)
  )
);
// Define a list of target integrals
list targetInt = list(
  list(1, 1, 1, -1, -3, 1, -1, -1, -1), 
  list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
    if (size(targetInt) == 0) {
        ERROR("Empty target integral list provided.");
    }
    // Debug: Ensure the input graph G and target integrals are correctly passed
    print("Graph G: " + string(G));
    print("Target Integrals: " + string(targetInt));
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
    web = setSectorMap(web);
    print("Generated web: " + string(web));
    list w4 = updateWeb(web, list(1,1), targetInt);
    web = w4[1];
    print("Size of updated web: " + string(size(web)));
    labeledgraph G1 = computeBaikovMatrix(G);
    setIBP reducedIBPs;
    list MI;
    print("Size of targetInt: " + string(size(targetInt)));
    int te = 0;
    reducedIBPs.seed = targetInt;
    int j = 1;
    if (size(web) < j) {
        ERROR("Web list does not contain layer j=" + string(j));
    }
    int nSectors = size(web[j]);
    if (nSectors == 0) {
        ERROR("No sectors available in web[" + string(j) + "]");
    }
    int k = 1;
    if (size(web[j]) < k) {
        ERROR("Web[" + string(j) + "] does not contain sector k=" + string(k));
    }
    print("Computing IBP for sector: " + string(web[j][k]));
    setIBP totalIBP = computeManyIBP(G1, web[j][k].targetInts);
    print("Size of totalIBP.IBP: " + string(size(totalIBP.IBP)));
    if (te == 0) {
        reducedIBPs.over = totalIBP.over;
        te = 1;
    }
    if (reducedIBPs.over == 0) {
        ERROR("totalIBP.over is not initialized correctly.");
    }
    ring R = reducedIBPs.over;
    setring R;
    list L = getRedIBPs(totalIBP, 101);
    if (size(L) < 2) {
        ERROR("getRedIBPs did not return expected two lists.");
    }
    list indpndIBP = L[1];
    print("Size of indpndIBP: " + string(size(indpndIBP)));
    list masterAndTailIntgrals = L[2];
    print("Size of masterAndTailIntgrals: " + string(size(masterAndTailIntgrals)));
    if (size(reducedIBPs.IBP) == 0) {
        reducedIBPs.IBP = indpndIBP;
    } else {
        for (int i = 1; i <= size(indpndIBP); i++) {
            reducedIBPs.IBP[size(reducedIBPs.IBP) + 1] = indpndIBP[i];
        }
    }
    kill R;
    print("Size of masterAndTailIntgrals = " + string(size(masterAndTailIntgrals)));
    list w = updateWeb(web, list(j, k), masterAndTailIntgrals);
    web = w[1];
    print("w[2] = " + string(w[2])); // Fixed debug message
    list masterIntgralsInSector = w[2];
    print("Size of masterIntgralsInSector = " + string(size(masterIntgralsInSector)));
    if (size(MI) == 0) {
        MI = masterIntgralsInSector;
    } else {
        for (int i = 1; i <= size(masterIntgralsInSector); i++) {
            if (alreadyIntheList(MI, masterIntgralsInSector[i]) == 0) {
                MI[size(MI) + 1] = masterIntgralsInSector[i];
            }
        }
    }
    print("Completed computation in sector: " + string(k) + " at layer " + string(j) + ".");
totalIBP;
    setIBP totalIBP = computeManyIBP(G1, web[j][k].targetInts);
size(totalIBP.IBP);
size(totalIBP.IBP);
    print("Size of totalIBP.IBP: " + string(size(totalIBP.IBP)));
$
LIB "feynman.lib";
graph G = makeGraph(
  list(1,2,3,4,5,6), 
  list(
      list(6,1), list(4,6), list(1,2), list(3,5), 
      list(4,3), list(2,5), list(5,6), list(1), 
      list(2), list(3), list(4)
  )
);
// Define a list of target integrals
list targetInt = list(
  list(1, 1, 1, -1, -3, 1, -1, -1, -1), 
  list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
    if (size(targetInt) == 0) {
        ERROR("Empty target integral list provided.");
    }
    // Debug: Ensure the input graph G and target integrals are correctly passed
    print("Graph G: " + string(G));
    print("Target Integrals: " + string(targetInt));
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
    web = setSectorMap(web);
    print("Generated web: " + string(web));
    list w4 = updateWeb(web, list(1,1), targetInt);
    web = w4[1];
    print("Size of updated web: " + string(size(web)));
print("web.")
    labeledgraph G1 = computeBaikovMatrix(G);
    setIBP reducedIBPs;
    list MI;
    print("Size of targetInt: " + string(size(targetInt)));
    int te = 0;
    reducedIBPs.seed = targetInt;
    int j = 1;
    if (size(web) < j) {
        ERROR("Web list does not contain layer j=" + string(j));
    }
    int nSectors = size(web[j]);
    if (nSectors == 0) {
        ERROR("No sectors available in web[" + string(j) + "]");
    }
    int k = 1;
    if (size(web[j]) < k) {
        ERROR("Web[" + string(j) + "] does not contain sector k=" + string(k));
    }
    print("Computing IBP for sector: " + string(web[j][k]));
    setIBP totalIBP = computeManyIBP(G1, web[j][k].targetInts);
    print("Size of totalIBP.IBP: " + string(size(totalIBP.IBP)));
$
LIB "feynman.lib";
graph G = makeGraph(
  list(1,2,3,4,5,6), 
  list(
      list(6,1), list(4,6), list(1,2), list(3,5), 
      list(4,3), list(2,5), list(5,6), list(1), 
      list(2), list(3), list(4)
  )
);
// Define a list of target integrals
list targetInt = list(
  list(1, 1, 1, -1, -3, 1, -1, -1, -1), 
  list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
 if (size(targetInt) == 0) {
        ERROR("Empty target integral list provided.");
    }
    // Debug: Ensure the input graph G and target integrals are correctly passed
    print("Graph G: " + string(G));
    print("Target Integrals: " + string(targetInt));
    list L = pickHighestSector(targetInt);
    if (size(L) == 0) {
        ERROR("pickHighestSector returned an empty list.");
    }
    if (size(L) > 1) {
        ERROR("Provided integrals belong to more than one integral class.");
    }
    list web = generateWebSectors(L[1][1]);
    web = setSectorMap(web);
    print("Generated web: " + string(web));
    list w4 = updateWeb(web, list(1,1), targetInt);
    web = w4[1];
    print("Size of updated web: " + string(size(web)));
print("web.")
    labeledgraph G1 = computeBaikovMatrix(G);
    setIBP reducedIBPs;
    list MI;
    print("Size of targetInt: " + string(size(targetInt)));
    int te = 0;
    reducedIBPs.seed = targetInt;
    int j = 1;
    if (size(web) < j) {
        ERROR("Web list does not contain layer j=" + string(j));
    }
    int nSectors = size(web[j]);
    if (nSectors == 0) {
        ERROR("No sectors available in web[" + string(j) + "]");
    }
    int k = 1;
    if (size(web[j]) < k) {
        ERROR("Web[" + string(j) + "] does not contain sector k=" + string(k));
    }
    print("Computing IBP for sector: " + string(web[j][k]));
    print("Size of updated web: " + string(size(web)));
labeledgraph G1 = computeBaikovMatrix(G);
    setIBP reducedIBPs;
    list MI;
    print("Size of targetInt: " + string(size(targetInt)));
    int te = 0;
    reducedIBPs.seed = targetInt;
    int j = 1;
    if (size(web) < j) {
        ERROR("Web list does not contain layer j=" + string(j));
    }
    int nSectors = size(web[j]);
    if (nSectors == 0) {
        ERROR("No sectors available in web[" + string(j) + "]");
    }
    int k = 1;
    if (size(web[j]) < k) {
        ERROR("Web[" + string(j) + "] does not contain sector k=" + string(k));
    }
    print("Computing IBP for sector: " + string(web[j][k]));
    setIBP totalIBP = computeManyIBP(G1, web[j][k].targetInts);
    print("Size of totalIBP.IBP: " + string(size(totalIBP.IBP)));
    print("Computing IBP for sector: " + string(web[j][k]));
    print("Computing IBP for sector: " + string(web[j][k].targetInts));
  setIBP S=computeManyIBP(G,targetInt);
$
LIB "feynman.lib";
 graph G = makeGraph(
    list(1,2,3,4,5,6), 
    list(
        list(6,1), list(4,6), list(1,2), list(3,5), 
        list(4,3), list(2,5), list(5,6), list(1), 
        list(2), list(3), list(4)
    )
  );
  
  // Define a list of target integrals
  list targetInt = list(
    list(1, 1, 1, -1, -3, 1, -1, -1, -1), 
    list(1, -1, 1, -1, -3, -1, -1, -4, -1)
  );

  setIBP S=computeManyIBP(G,targetInt);
  size(S.IBP);  

  list targetInt1 = list(1, 1, 1, -1, -3, 1, -1, -1, -1  );
  setIBP S=computeManyIBP(G,targetInt1);
  size(S.IBP);  
setIBP IBP2=computeIBP(G1,targetInt1);
  size(IBP1.IBP);

 setIBP IBP2=computeIBP(G,targetInt1);
  size(IBP1.IBP);
  size(IBP2.IBP);

  setIBP IBP2=computeIBP(G,targetInt1);
  size(IBP2.IBP);
$
