// Write test data
link l = "ssi:w /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/test.ssi";
write(l, "This is a test line 1\n");
write(l, "This is a test line 2\n");
close(l);
// Read the test file
link l = "ssi:r /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/test.ssi";
def m = read(l);
m;
link l = "ssi:w /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/test.ssi";
write(l, "This is a test line 1", "\n");
write(l, "This is a test line 2", "\n");
close(l);
link l = "ssi:r /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/test.ssi";
def m = read(l);  // Reads the file into a list
m;                // Displays the entire content of the file
kill l, m;
link l = "ssi:r /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/test.ssi";
def m = read(l);
m;
link l = "ssi:w /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/test.ssi";
write(l, "Debug Line 1\n");
write(l, "Debug Line 2\n");
close(l);
link l = "ssi:r /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/test.ssi";
def m = read(l);
m;
m;
 m.r_data;
link l = "ssi:w /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/test.ssi";
write(l, "Debug Line 1");
write(l, "Debug Line 2");
close(l);
link l = "ssi:r /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/test.ssi";
def m = list();
while (!eof(l)) {
  m[size(m) + 1] = readline(l);  // Read each line into the list
}
close(l);
m;
link l = "ssi:w /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/test.ssi";
write(l, "Debug Line 1\nDebug Line 2\n");
close(l);
link l = "ssi:r /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/test.ssi";
def str = readline(l);  // Read entire content as a single string
close(l);
def m = split(str, "\n");  // Split the string by newline
m;
link l = "ssi:w /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/debug.ssi";
write(l, "Debug Line 1");
write(l, "Debug Line 2");
write(l, "Additional Info");
close(l);
link l = "ssi:r /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/debug.ssi";
def line1 = read(l);
def line2 = read(l);
def line3 = read(l);
close(l);
line1;
line2;
line3;
link l = "ssi:r /home/atraore/gpi/try_gpi/feynman_ibp/example_dir/temp/debug.ssi";
def line1 = read(l);
def line2 = read(l);
def line3 = read(l);
close(l);
line1;
line2;
line3;
// Define the path to the file
string path = "/home/atraore/gpi/try_gpi/feynman_ibp/example_dir/hi.ssi";  // Adjust path if necessary
// Open the file for writing using a link
link l = "ssi:w " + path;
// Write debug information
write(l, "D\n");
write(l, 22, "\n");  // Adjust this to the actual size of elimvars if needed
// Close the link after writing
close(l);
 link l="ssi:r hi.ssi";
def m=read(l);
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1 = computeBaikovMatrix(G);
LIB "feynman.lib"
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1 = computeBaikovMatrix(G);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1 = computeBaikovMatrix(G);
G1;
G1.baikovmatrix;
quit,;
quit;
LIB "feynman.lib"
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1 = computeBaikovMatrix(G);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1 = computeBaikovMatrix(G);
quit;
LIB "feynman.lib"
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1 = computeBaikovMatrix(G);
quit,;
quit;
LIB "feynman.lib"
LIB "feynman.lib";
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
 ring RB= G1.baikovover;
  setring RB;
G1.baikovmatrix;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
G1.baikovmatrix;
typeof(G1);
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
G1.baikovover;
G1.baikovmatrix;
labeledgraph G1 = computeBaikovMatrix(G);
setring(G1.baikovover); // Ensure the Baikov ring is active
G1.baikovmatrix;
 ring RB= G1.baikovover;
  setring RB;
  RB;
  matrix B = G1.baikovmatrix;
B;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
G1.baikovmatrix;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
G1.baikovmatrix;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
ring RB= G1.baikovover;
  setring RB;
G1.baikovmatrix;
G1;
setring(G1.baikovover);
G1;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
G1;
quit;
LIB "feynman.lib";
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
matrix BaikovMatrix = getBaikovMatrix(G1);
atrix bMatrix = getBaikovMatrix(G1);
print(bMatrix);
matrix BaikovMatrix = getBaikovMatrix(G1);
BaikovMatrix;
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
matrix bMatrix = getBaikovMatrix(G1);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
G1;
matrix bMatrix = getBaikovMatrix(G1);
matrix mm = getBaikovMatrix(G1);
getBaikovMatrix(G1);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
getBaikovMatrix(G1);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
getBaikovMatrix(G1);
matrix mm = getBaikovMatrix(G1);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
labeledgraph mm = getBaikovMatrix(G1);
mm;
mm.baikovmatrix;
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
mm.baikovmatrix;
getBaikovMatrix(G1);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
getBaikovMatrix(G1);
quit;
;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
getBaikovMatrix(G1);
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
getBaikovMatrix(G1);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
getBaikovMatrix(G1);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
getBaikovMatrix(G1);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
getBaikovMatrix(G1);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
getBaikovMatrix(G1);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
G1;
G1.baikovmatrix;
G1.baikovover;
G1.baikovmatrix;
  setring RB;
  ring RB= G1.baikovover;
  setring RB;
G1.baikovmatrix;
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
G1=computeBaikovMatrix(G);
computeBaikovMatrix(G);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
G1;
// Print all field names of labeledgraph G1
list fieldnames(G1);
list fields = fieldnames(G1);
quit;
LIB "feynman.lib";
list fields = fieldnames(G1);
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
G1;
G1.baikovmatrix;
ring RB= G1.baikovover;
  setring RB;
  ring RB= G1.baikovover;
quit;
LIB "feynman.lib";
graph G = makeGraph(list(1,2,3,4,5,6), list(list(6,1), list(4,6), list(1,2), list(3,5), list(4,3), list(2,5), list(5,6), list(1), list(2), list(3), list(4)));
labeledgraph G1 = computeBaikovMatrix(G);
G1;
 G1.baikovover;
  ring RB= G1.baikovover;
  setring RB;
  matrix B = G1.baikovmatrix;
G1.baikovmatrix;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
G1.baikovover;
G1.over;
G1.baikovmatrix;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
computeBaikovMatrix(G);
  labeledgraph G1=computeBaikovMatrix(G);
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
computeBaikovMatrix(G);
quit;
LIB "feynman.lib";
computeBaikovMatrix(G);
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
computeBaikovMatrix(G);
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
computeBaikovMatrix(G);
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
computeBaikovMatrix(G);
  labeledgraph G1=computeBaikovMatrix(G);
G1.baikovover;
G1.baikovmatrix;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
G1.baikovover;
G1.baikovmatrix;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
quit;
LIB "feynman.lib";
LIB "feynman.lib";
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list finalset = getReducedIBPSystem(G,targetInt);
;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list finalset = getReducedIBPSystem(G,targetInt);
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list setInt=list(list(1,1,1,1,1,1,1,-5,0));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  list w2=updateWeb(web,list(1,1),L1[1]); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web
  web=w2[1]; 
  setIBP S=computeIBP(G1,L1[1][1]);
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list finalset=getReducedIBPSystem(G,targetInt);
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
    list L=pickHighestSector(targetInt);
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  int te=0;
  reducedIBPs.seed=targetInt;
  int nLayers=size(web);
      int nSectors=size(web[j]);
int j=1;
int k=1;
web[j];
web[j][1].targetInts;
web[j][1].targetInts;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
list targetInt = list(list(1, 2, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list setInt = list(list(1, 2, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  list w2=updateWeb(web,list(1,1),L1[1]); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web
  web=w2[1]; 
  setIBP S=computeIBP(G1,L1[1][1]);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101); //L[1]=list of independent IBPs,L[2]=list of master integrals
  list independIBPs=L[1];
  list masterAndTailIntgrals=L[2];
  size(independIBPs) < size(S.IBP); //number of linearly independent set of IBPs are less than the number of orginal IBPs. So this returns true
  oneIBP I1=independIBPs[18];     //Here is an example for one IBP i
  I1;
  list w3=updateWeb(web,list(1,1),masterAndTailIntgrals); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web
  web=w3[1];   
  size(web[1][1].targetInts);
w3;
  size(web[2][2].targetInts);
web;
w3;
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
list targetInt = list(list(1, 2, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
quit;
LIB "feynman.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
list targetInt = list(list(1, 2, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
int j=1;
int k=1;
  list targetInt = list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list L = pickHighestSector(targetInt);
  if (size(L) > 1)                           //if size(L)>1, we have to do the same for each list in L.
  {
    ERROR("provided integrals belong to more than one integral class");
  }
  // L[1] is the list of target integrals belong to one integral family but it has arranged so that.. 
  //..L[1][1] is the integral belong to the superior sector.
 // we use this seed (i.e. target integral) to create the web structure 
 //When we do computation sequentially, it is better to have web structure of the sectors upfront.
 //We denote it by a list web, where web[i] contains the sectors belong to that layer.
  list web = generateWebSectors(L[1][1]);
  web = setSectorMap(web);
  //After creating the web, we have to update it by including the target integrals to the corresponding sectors
  //Because, when we do the intended computation in sectors, we read seeds from this updated 
  //This update step need to perform with tail integrals of each sector, once the computations correspond to sectors in each layer are done. 
  //If the computation done correctly, tail integrals will only be assigned to the sectors in the below layers.
  list w4 = updateWeb(web, list(1, 1), targetInt);
  web = w4[1];
  // *this return a list w4, where w4[1] is the updated web and
  // w4[2] is the list of integrals that does not belong to the current web (if any have. usually dont!) 
  // We set two places to store reduced IBP relations (a setIBP), and master integrals (a list) that are comes from..
  //..the intended computations relevent to each sector   
  //before we go further,we first create the labelled graph G1 of G computing Baikov matrix
  labeledgraph G1 = computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te = 0;
  reducedIBPs.seed = targetInt;
reducedIBPs.seed;
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
size(web[j][k].targetInts);
          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
list L=pickHighestSector(targetInt);
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  labeledgraph G1=computeBaikovMatrix(G);
G1;
quit;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  
 list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }
   // L[1] is the list of target integrals belong to one integral family but it has arranged so that.. 
   //..L[1][1] is the integral belong to the superior sector.
  // we use this seed (i.e. target integral) to create the web structure 
  //When we do computation sequentially, it is better to have web structure of the sectors upfront.
  //We denote it by a list web, where web[i] contains the sectors belong to that layer.
  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);
  //After creating the web, we have to update it by including the target integrals to the corresponding sectors
  //Because, when we do the intended computation in sectors, we read seeds from this updated 
  //This update step need to perform with tail integrals of each sector, once the computations correspond to sectors in each layer are done. 
  //If the computation done correctly, tail integrals will only be assigned to the sectors in the below layers.
  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  // *this return a list w4, where w4[1] is the updated web and
  // w4[2] is the list of integrals that does not belong to the current web (if any have. usually dont!) 
  // We set two places to store reduced IBP relations (a setIBP), and master integrals (a list) that are comes from..
  //..the intended computations relevent to each sector   
  
  //before we go further,we first create the labelled graph G1 of G computing Baikov matrix
  
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  
  int nLayers=size(web);
reducedIBPs.seed;
int j=1;
int k=1;
setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
totalIBP;
size(totalIBP.IBP);
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //here we compute set of IBPs correspond to two seeds seperately
  setIBP IBP1=computeIBP(G1,list(1,1,0,1,0,1,0,-1,0));
  setIBP IBP2=computeIBP(G1,list(1,2,0,3,0,1,0,-2,0));
  size(IBP1.IBP);
  size(IBP2.IBP);
  
  //here we compute set of IBPs correspond both seeds simultaneously 
  //We can use this only when both integrals belongs to the same sector
  setIBP S=computeManyIBP(G,list(list(1,1,0,1,0,1,0,-1,0),list(1,2,0,3,0,1,0,-2,0)));
  size(S.IBP);  
size(IBP1.IBP);
G1;
  size(IBP2.IBP);
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  S;
  oneIBP I=S.IBP[1];
  I;
  size(S.IBP);
quit;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  S;
  oneIBP I=S.IBP[1];
  I;
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module M2=computeM2(G1,list(1,1,1,0,0,1,0,0,0));
M2;
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
M1;
ML;
G.over;
G1.over;
npars(G1.over);
 nvars(G1.over);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
ML;
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //here we compute set of IBPs correspond to two seeds seperately
  setIBP IBP1=computeIBP(G1,list(1,1,0,1,0,1,0,-1,0));
  setIBP IBP2=computeIBP(G1,list(1,2,0,3,0,1,0,-2,0));
  size(IBP1.IBP);
  size(IBP2.IBP);
  
  //here we compute set of IBPs correspond both seeds simultaneously 
  //We can use this only when both integrals belongs to the same sector
  setIBP S=computeManyIBP(G,list(list(1,1,0,1,0,1,0,-1,0),list(1,2,0,3,0,1,0,-2,0)));
  size(S.IBP);  
  
  size(IBP1.IBP);
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  S;
  oneIBP I=S.IBP[1];
  I;
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
ML;
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module M2=computeM2(G1,list(1,1,1,0,0,1,0,0,0));
    module M2=computeM2(G1, list(1,1,1,1,1,1,1,-5,0));
   
    M2;
size(M1);
size(ML);
ML;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
size(ML);
quit;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1 = computeBaikovMatrix(G);
  //here we compute set of IBPs correspond to two seeds seperately
  setIBP IBP1 = computeIBP(G1,list(1,1,0,1,0,1,0,-1,0));
  setIBP IBP2 = computeIBP(G1,list(1,2,0,3,0,1,0,-2,0));
  size(IBP1.IBP);
  size(IBP2.IBP);
  //here we compute set of IBPs correspond both seeds simultaneously 
  //We can use this only when both integrals belongs to the same sector
  setIBP S = computeManyIBP(G,list(list(1,1,0,1,0,1,0,-1,0),list(1,2,0,3,0,1,0,-2,0)));
  size(S.IBP);
quit;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //here we compute set of IBPs correspond to two seeds seperately
  setIBP IBP1=computeIBP(G1,list(1,1,0,1,0,1,0,-1,0));
  setIBP IBP2=computeIBP(G1,list(1,2,0,3,0,1,0,-2,0));
  size(IBP1.IBP);
  size(IBP2.IBP);
  
  //here we compute set of IBPs correspond both seeds simultaneously 
  //We can use this only when both integrals belongs to the same sector
  setIBP S=computeManyIBP(G,list(list(1,1,0,1,0,1,0,-1,0),list(1,2,0,3,0,1,0,-2,0)));
  size(S.IBP);  
  
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
ML;
quit;
LIB "feynman.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
    ML;
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB= G1.baikovover;
  setring RB;
  RB;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
LIB "feynman.lib";
quit;
