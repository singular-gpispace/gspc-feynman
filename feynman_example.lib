// Assuming mod_init() has been called to define structs
LIB "general.lib";
LIB "feynman.lib";
// Define a ring for reducedIBPs.over
//    
// Helper procedure to compare two integer lists for equality
proc eq_int_list(list a, list b) {
    if (size(a) != size(b)) {
        return(0);
    }
    for (int i = 1; i <= size(a); i++) {
        if (a[i] != b[i]) {
            return(0);
        }
    }
    return(1);
}

// Helper procedure to merge two lists of integer vectors, removing duplicates
proc merge_int_vectors(list A, list B) {
    if (size(A) == 0 && size(B) == 0) {
        return(list());
    }
    list C = A;
    for (int i = 1; i <= size(B); i++) {
        int found = 0;
        for (int j = 1; j <= size(A); j++) {
            if (eq_int_list(A[j], B[i])) {
                found = 1;
                break;
            }
        }
        if (found == 0) {
            C[size(C) + 1] = B[i];
        }
    }
    return(C);
}

// Helper procedure to merge two lists of sectors, combining targetInts where labs match
proc merge_sector_lists(list A, list B) {
    if (size(A) < 0 || size(B) < 0) {
        print("merge_sector_lists: Error: Negative size detected (A: " + string(size(A)) + ", B: " + string(size(B)) + ")");
        return(list());
    }
    list C = list();
    for (int i = 1; i <= size(A); i++) {
        if (defined(A[i].lab) == 0 || defined(A[i].targetInts) == 0) {
            print("merge_sector_lists: Error: A[" + string(i) + "] missing lab or targetInts");
            return(list());
        }
        C[i] = A[i];
    }
    for (int i = 1; i <= size(B); i++) {
        if (defined(B[i].lab) == 0 || defined(B[i].targetInts) == 0) {
            print("merge_sector_lists: Error: B[" + string(i) + "] missing lab or targetInts");
            return(list());
        }
        int found = 0;
        int idx = 0;
        for (int j = 1; j <= size(A); j++) {
            if (eq_int_list(A[j].lab, B[i].lab)) {
                found = 1;
                idx = j;
                break;
            }
        }
        if (found) {
            C[idx].targetInts = merge_int_vectors(C[idx].targetInts, B[i].targetInts);
        } else {
            C[size(C) + 1] = B[i];
        }
    }
    return(C);
}

// Modified mergeFeynman to accept a list of feynman structs
proc mergeFeynman(list data_list)
"USAGE: mergeFeynman(data_list); data_list list of feynman structs
ASSUME: All feynman structs in data_list have compatible rings and web structures.
RETURN: A single feynman structure combining all inputs, with IBPs appended without detailed duplicate removal.
KEYWORDS: Feynman graph, merge, IBPs"
{
    if (size(data_list) == 0) {
        print("mergeFeynman: Error: Empty input list");
        feynman empty;
        return(empty);
    }
    if (size(data_list) == 1) {
        return(data_list[1]); // Return the single item as-is
    }

    feynman out;
    // Initialize with the first data's ring
    out.reducedIBPs.over = data_list[1].reducedIBPs.over;

    // Merge MI
    print("mergeFeynman: Merging MI");
    out.MI = list();
    for (int k = 1; k <= size(data_list); k++) {
        if (size(data_list[k].web) == 0) {
            print("mergeFeynman: Error: Web is empty for data " + string(k));
            return(out);
        }
        out.MI = merge_int_vectors(out.MI, data_list[k].MI);
    }

    // Merge seeds
    print("mergeFeynman: Merging seeds");
    out.reducedIBPs.seed = list();
    for (int k = 1; k <= size(data_list); k++) {
        out.reducedIBPs.seed = merge_int_vectors(out.reducedIBPs.seed, data_list[k].reducedIBPs.seed);
    }

    // Merge IBPs
    out.reducedIBPs.IBP = list();
    int idx = 0;
    for (int k = 1; k <= size(data_list); k++) {
        for (int i = 1; i <= size(data_list[k].reducedIBPs.IBP); i++) {
            idx = idx + 1;
            out.reducedIBPs.IBP[idx] = data_list[k].reducedIBPs.IBP[i];
        }
    }

    // Determine maximum number of web layers
    int max_layers = size(data_list[1].web);
    for (int k = 2; k <= size(data_list); k++) {
        if (size(data_list[k].web) > max_layers) {
            max_layers = size(data_list[k].web);
        }
    }

    // Merge web
    out.web = list();
    for (int i = 1; i <= max_layers; i++) {
        print("mergeFeynman: Merging web layer " + string(i));
        list layer_sectors = list();
        for (int k = 1; k <= size(data_list); k++) {
            if (i <= size(data_list[k].web)) {
                if (size(layer_sectors) == 0) {
                    layer_sectors = data_list[k].web[i];
                } else {
                    layer_sectors = merge_sector_lists(layer_sectors, data_list[k].web[i]);
                }
            }
        }
        out.web[i] = layer_sectors;
        if (size(out.web[i]) == 0) {
            print("mergeFeynman: Warning: Web layer " + string(i) + " merge resulted in empty list");
        }
    }

    // print("mergeFeynman: Merge complete");
    return(out);
}

// Example with three feynman structs
example {
    // Define a ring for reducedIBPs.over
    ring R = (0,t1,t2,D), (z(1..9)), dp;

    // Helper to create a oneSector struct
    proc createSector(list lab, list sectorMap, list targetInts) {
        oneSector s;
        s.lab = lab;
        s.sectorMap = sectorMap;
        s.targetInts = targetInts;
        return(s);
    }

    // Helper to create a oneIBP struct
    proc createIBP(list coeff, list integrals) {
        oneIBP ibp;
        ibp.c = coeff;
        ibp.i = integrals;
        return(ibp);
    }

    // Create data_a
    feynman data_a;
    data_a.MI = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -1),
        list(1, 1, 1, -1, -3, 0, -1, -1, -2)
    );
    data_a.reducedIBPs.over = R;
    data_a.reducedIBPs.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    data_a.reducedIBPs.IBP = list(
        createIBP(
            list(t1*t2, -t2^2),
            list(list(1, 1, 0, -2, -3, 0, -1, -1, -1), list(1, 1, 0, -1, -4, 0, -1, -1, -1))
        )
    );
    data_a.web = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -1))),
            createSector(list(1, 3), list(1, 3), list(list(1, 1, 1, -2, -3, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -1)))
        )
    );

    // Create data_b
    feynman data_b;
    data_b.MI = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -2),
        list(1, 1, 1, -1, -3, 0, -1, -1, -3)
    );
    data_b.reducedIBPs.over = R;
    data_b.reducedIBPs.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    data_b.reducedIBPs.IBP = list(
        createIBP(
            list(t1^2, -t1*t2),
            list(list(1, 1, 1, -1, -3, 0, -1, -1, -2), list(1, 1, 1, -2, -3, 0, -1, -1, -2))
        )
    );
    data_b.web = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -2))),
            createSector(list(1, 4), list(1, 4), list(list(1, 1, 1, -1, -4, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -2)))
        )
    );

    // Create data_c (third dataset)
    feynman data_c;
    data_c.MI = list(
        list(1, 1, 1, -1, -3, 0, -1, -1, -3),
        list(1, 1, 1, -1, -3, 0, -1, -1, -4)
    );
    data_c.reducedIBPs.over = R;
    data_c.reducedIBPs.seed = list(
        list(1, 1, 1, -1, -3, 1, -1, -1, -1)
    );
    data_c.reducedIBPs.IBP = list(
        createIBP(
            list(t2^2, -t1),
            list(list(1, 0, 1, -1, -3, 0, -1, -1, -2), list(1, 0, 1, -1, -4, 0, -1, -1, -2))
        )
    );
    data_c.web = list(
        list(
            createSector(list(1, 2), list(1, 2), list(list(1, 1, 1, -1, -3, 0, -1, -1, -3))),
            createSector(list(1, 5), list(1, 5), list(list(1, 1, 1, -1, -5, 0, -1, -1, -1)))
        ),
        list(
            createSector(list(2, 3), list(2, 3), list(list(1, 1, 0, -1, -3, 0, -1, -1, -3)))
        )
    );

    // Merge all three datasets
    list data_to_merge = list(data_a, data_b, data_c);
    feynman merged_abc = mergeFeynman(data_to_merge);

    // Print results
    print("Merged data_a, data_b, and data_c MI size: " + string(size(merged_abc.MI)));
    print("Merged data_a, data_b, and data_c IBP size: " + string(size(merged_abc.reducedIBPs.IBP)));
    print("Merged data_a, data_b, and data_c web size: " + string(size(merged_abc.web)));
    for (int i = 1; i <= size(merged_abc.web); i++) {
        print("Merged web layer " + string(i) + " size: " + string(size(merged_abc.web[i])));
        for (int j = 1; j <= size(merged_abc.web[i]); j++) {
            print("  Sector " + string(j) + " lab: " + string(merged_abc.web[i][j].lab));
            print("  Sector " + string(j) + " targetInts size: " + string(size(merged_abc.web[i][j].targetInts)));
        }
    }
}