//////////////////////////////////////////////////////////////////////////////
version="version classify2.lib 4.0.0.0 Jun_2013 "; // $Id:  $
category="Commutative Algebra";
info="
LIBRARY: feynman.lib   Feynman integrals and IBP

OVERVIEW:
We generate the Feynman integrand associated to a Feynman diagram.

KEYWORDS:
Feynman integral;

PROCEDURES:
makeGraph(list, list)                                   generate a graph from a list of vertices and a list of edges
makeLabeledGraph(list, list)                            generate a labeled graph from a list of vertices and a list of edges
printGraph(graph)                                       print procedure for graphs
labelGraph(graph)                                       label a graph with variables for vertices and edges
balancingIdeal(labeledgraph)                            ideal of balancing conditions
eliminateVariables(labeledgraph)                        eliminate variables according to balancing condition
propagators(labeledgraph)         	                    generate ideal generated by denominators of the Feynman integral assocated to graph
ISP(labeledgraph)			                                  extend the propagators to a basis of the quadratic forms
removeElimVars(labeledgraph)                            Removes the variables from G.elimvars. This key is generated by the procedure eliminateVariables.
computeBaikovMatrix(graph)                              computes the Baikov matrix of G defined in G1.baikovover and stores it in G1.baikovmatrix
computeM1(labeledgraph)                                 generate the module M1 over G1.baikovover that requires to compute IBP identities 
computeM2(labeledgraph,list)                            generate the module M2 over G1.baikovover that requires to compute IBP identities 
computeIBP(labeledgraph,list)                           generate the set of IBPS correspond to the given indices of denominators of the feynman integral.
getSector(list)                                         returns the sector (a list of 1s and 0s) that the integral belongs
listCombintions(list,int)                               returns the list of r-combinations of the elements in the list L
generateWebSectors(list)                                generate the Web structure of the sectors L, where L is the list and L[1] is the sector that correspond to the seed and 
                                                        L[i]  contain the subsectors of the sectors in L[i-1]. Not that sector maps between the sectors have not been setted.
isSubList(l1,l2)                                        return 1 if elements in l1 contain in l2  0 if elements in l1 do not contain in l2
getSectorMap(L1,L2)                                     L1 where sectorMap  of each sector in the list L1 is filled.
setSectorMap(sectorWeb)                                 sectorWeb where the field sectorMap field of each sector in sectorWeb is filled.
findSector(sectorWeb,currentPosition,L)                 return position of the sector in the sectorWeb, where the L belongs. return -1, if the sector is not found
updateOneSector(sectorWeb,currentPosition,oneInt)       updated sectorWeb, where the oneInt is assigned to the targetInts field of the seector correspond to provided oneInt
updateWeb(sectorWeb,currentPosition,setInt)             return a list(sectorWeb,MasterInt,notInWeb) where,sectorWeb is the updated web by assingning integrals to correspondng sectors, masterInt is the list integrals belong to the sector at currentPosition notInWeb is the list of integrals that are not belong the integral family associated the SectorWeb.
pickHighestSector(targetInt)                            return the intgral that belong to the heighest sector, if all integrals belong to the same sector web; otherwise, it returns a list of collection of integrals each need to be handled using different sector webs
getSortMeasures(l)                                      return list of sort measures that are used in Laporta Algorithm
extractCoef(I,ind,l)                                    return list of values where, the i-th element is the evaluation of coefficient function  at values in the list l of the IBP relation oneIBP, whose index is i=ind[i][1]. Columns of the matrix correspond to the all used indices in the setIBP which are ordered with respect to the output ofgetSortMeasures.
setMat(S,val)                                           return matrix,where i-th row correspond to the evaluation of coefficient functions of i-th IBP in setIBP. 
getRedIBPs(S,p)                                         list L, L[1]=indIBP, L[2]=seed where, indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. seed contain the indeces correspond to the non-free columns in rref.
getSortedIntegrals(I)                                            return list ind where each entry is a pair (indv,sortmeasures), indv is the list of indices(seed) appered in the setIBP and sortmeasures is the output of getSortMeasures(indv).The function getSortedIntegrals extract the seeds appeared in the IBP identities of the setIBP, sort them lexicographically based on the values got from getSortMeasures and return the output.
computeManyIBP(G0,setNu)                                return setIBP S, where it contains all the IBP relations obtained by module intersection and seeding
";

LIB "linalg.lib";

proc mod_init()
{
LIB "general.lib";
newstruct("graph","list vertices, list edges");
newstruct("labeledgraph","list vertices, list edges, ring over, list labels, ring overpoly, list elimvars, ring baikovover, matrix baikovmatrix");
newstruct("Net","list rows");
newstruct("oneIBP","list c, list i");
newstruct("setIBP","ring over,list seed,list IBP");
newstruct("oneSector","list lab, list sectorMap ,list targetInts ");
system("install","labeledgraph","print",printLabeledGraph,1);
system("install","graph","print",printGraph,1);
system("install","oneIBP","print",printIBP,1);
system("install","setIBP","print",printsetIBP,1);
system("install","Net","print",printNet,1);

system("install","Net","+",catNet,2);
option(noredefine);
}


          ////////////////////////////////////////////////////////////////////////////////////////////
          //                              Compute Baikov matrix                                     //
          ///////////////////////////////////////////////////////////////////////////////////////////


static proc catNet(Net N, Net M)
{
list L;
list LN=N.rows;
list LM=M.rows;
int widthN=size(LN[1]);
int widthM=size(LM[1]);
int nm=max(size(LN),size(LM));
for (int j=1; j<=nm; j++)
{
    if (j>size(LN)){LN[j]=emptyString(widthN);}
    if (j>size(LM)){LM[j]=emptyString(widthM);}
    L[j]=LN[j]+LM[j];
}
Net NM;
NM.rows=L;
return(NM);}


static proc netList(list L1)
{
  Net N=net("[");
  for (int j=1; j<=size(L1)-1; j++)
  {
     N=N+net(L1[j])+net(", ");
  }
  N=N+net(L1[size(L1)])+net("]");
  return(N);
}

static proc printNet(Net N)
{
list L = N.rows;
for (int j=1; j<=size(L); j++)
{
   print(L[j]);
}
}

static proc net(def M){
  if (typeof(M)=="Net"){
    return(M);
  }
  if (typeof(M)=="list"){
    return(netList(M));
  }
  Net N;
  list L;
  L[1]=string(M);
  N.rows=L;
return(N);}


proc printMat(matrix M)
"USAGE:  printMat(M); M matrix@*
ASSUME:  M is a matrix.
THEORY:  This is the print function used by Singular to print a matrix.
KEYWORDS: matrix
EXAMPLE:  example printMat; shows an example
"
{
  int r=nrows(M);
  int c=ncols(M);
  list mWidth;

  for(int j=1;j <= c;j++)
  { 
    int m=0;
    for(int i=1 ; i <= r ;i++)
    {
      int entr=size(string(M[i,j]));
      if(entr>m)
      {
        m=entr;
      }
    }
    mWidth[j]=m;
  }


  for(int i=1;i <= r ; i++)
  {
    string rstar="[";
    for(int j=1;j <= c;j++)
    {
      string ent = string(M[i,j]);
      int p=mWidth[j]-size(ent);
      rstar=rstar+ent;
      if(j<c)
      {
        for(int k=1;k<=p+2;k++)
        {
          rstar=rstar+" ";
        }
        rstar=rstar+",";
      }

    }
    rstar=rstar+"]";
    print(rstar);
  }
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x),lp;
  matrix M[2][3]=1,243,3,4,522222,6;
  printMat(M);
}

proc printGraph(graph G)
"USAGE:  printGraph(G); G graph@*
ASSUME:  G is a graph.
THEORY:  This is the print function used by Singular to print a graph.
KEYWORDS: graph
EXAMPLE:  example printGraph; shows an example
"
{
  print(netList(G.edges));
  int ct = 0;
  for (int i =1 ; i<=size(G.edges); i++){if (size((G.edges)[i])==1){ct=ct+1;}}
  if (ct!=0)
  {
      print("Graph with "+string(size(G.vertices))+" vertices, "+string(size(G.edges)-ct)+" bounded edges and "+string(ct)+" unbounded edges");
  } else {
      print("Graph with "+string(size(G.vertices))+" vertices and "+string(size(G.edges))+" edges");
  }
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  G;
}


proc printLabeledGraph(labeledgraph G)
"USAGE:  printLabeledGraph(G); G labeledgraph@*
ASSUME:  G is a labeled graph.
THEORY:  This is the print function used by Singular to print a labeled graph.
KEYWORDS: Feynman graph
EXAMPLE:  example printLabeledGraph; shows an example
"
{
  print(netList(G.edges));
  int ct;
  for (int i =1 ; i<=size(G.edges); i++){if (size((G.edges)[i])==1){ct=ct+1;}}
  if (ct!=0)
  {
      print("Graph with "+string(size(G.vertices))+" vertices, "+string(size(G.edges)-ct)+" bounded edges and "+string(ct)+" unbounded edges");
  } else {
      print("Graph with "+string(size(G.vertices))+" vertices and "+string(size(G.edges))+" edges");
  }
  int ringdef = (typeof(basering)=="ring");
  if (ringdef){def R1 = basering;}
  def R2 = G.over;
  setring R2;
  list labels =G.labels;
  "";
  print("Edgeterms: ");
  list ev;
  Net ne;
  for (i = 1; i<=size(G.edges);i++){
     ne = net(G.edges[i])+net(" => ")+net(string(labels[i]));
     ev[i]=ne;
  }
  print(netList(ev));
  kill labels;
  if (ringdef){setring R1;}

}
example
{ "EXAMPLE:"; echo=2;
  ring R=(0),q(1..6),dp;
  labeledgraph G = makeLabeledGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4)),R, list (q(1),q(2),q(3),q(4),q(5),q(6)),R);
  G;
}

proc printIBP(oneIBP I)
"USAGE:  printIBP(I); I oneIBP@*
ASSUME:  I is an IBP identity computed using computeIBP.
THEORY:  This is the print function used by Singular to print an IBP relation.
KEYWORDS: Feynman graph
EXAMPLE:  example printLabeledGraph; shows an example
"
{
Net ne;
ne = net(string(I.c[1]))+net("I")+net("(")+net(string(I.i[1]))+net(")");
  for (int j = 2; j<=size(I.c);j++){
     ne = ne+net("+")+net(string(I.c[j]))+net("I")+net("(")+net(string(I.i[j]))+net(")");
     
  }
  ne=ne+net("=0");
printNet(ne);
}

proc printsetIBP(setIBP I)
"USAGE:  printIBP(I); I setIBP@*
ASSUME:  I is the set of IBP identities computed using computeIBP.
THEORY:  This is the print function used by Singular to print setIBP.
KEYWORDS: Feynman graph
EXAMPLE:  example printLabeledGraph; shows an example
"
{
  setring I.over;
print("Collection of IBP identities of the given graph with respect to the seed "+string(I.seed)+".");
print("Total number of identities= "+string(size(I.IBP)));
}


proc makeGraph(list v, list e)
"USAGE:  makeGraph(v,e); v list, e list@*
ASSUME:  v is a list of integers, e is a list of two element lists of v.
RETURN:  graph with vertices v and edges e
THEORY:  Creates a graph from a list of vertices and edges. The vertices can be any type. The data structure 
         respects the ordering of vertices of edges, so can be used for directed graphs,
KEYWORDS: graph
EXAMPLE:  example makeGraph; shows an example
"
{
  graph G;
  G.vertices = v;
  G.edges = e;
  return(G);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4)));
  G;
}

proc makeLabeledGraph(list v, list e, def R, list lab, def Rpoly)
"USAGE:  makeLabeledGraph(v,e,R,l,P); v list, e list, R ring, l list, P ring @*
ASSUME:  v is a list of integers, e is a list of two element lists of pairwise different elements of v, R is a ring, l is a list of labels, P is a ring
RETURN:  labeled graph with vertices v and edges e with labels of the edges in R with infinite edges being constants
KEYWORDS: Feynman graph
EXAMPLE:  example makeLabeledGraph; shows an example
"
{
  labeledgraph G;
  G.vertices = v;
  G.edges = e;
  G.over = R;
  G.overpoly = Rpoly;
  G.labels = lab;
  return(G);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=(0),q(1..6),dp;
  labeledgraph G = makeLabeledGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4)),R, list (q(1),q(2),q(3),q(4),q(5),q(6)),R);
  G;
}



proc labelGraph(graph G, int ch)
"USAGE:  labelGraph(G); G graph@*
ASSUME:  G is a graph and ch is either zero or a prime.
RETURN:  labeled graph with polynomial variables q_i at the bounded edges and function field variables p_i at the unbounded edges over a prime field of characteristic ch
KEYWORDS: Feynman graph
EXAMPLE:  example labelGraph; shows an example
"
{
  int ringdef = (typeof(basering)=="ring");
  if (ringdef){def R1 = basering;}
  int ct;
  for (int i = 1 ; i<=size(G.edges); i++){if (size((G.edges)[i])==1){ct=ct+1;}}
  int anzq = size(G.edges)-ct;
  ring P = (ch),(p(1..ct),q(1..anzq)),ip;
  ring R = (ch,p(1..ct)),(q(1..anzq)),ip;
  list lab;
  int pidx = 1;
  int qidx = 1;
  for (i = 1 ; i<=size(G.edges); i++){
      if (size((G.edges)[i])==1){
          lab[i]=p(pidx);
          pidx = pidx+1;
      } else {
          lab[i]=q(qidx);
          qidx = qidx+1;
      }
  }
  labeledgraph lG = makeLabeledGraph(G.vertices,G.edges,R, lab,P);
  if (ringdef){setring R1;}
  return(lG);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  lG;
}

proc balancingIdeal(labeledgraph G)
"USAGE:  balancingIdeal(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  ideal of balancing condition of the graph, basering is assumed to be G.over
KEYWORDS: Feynman graph
EXAMPLE:  example balancingIdeal; shows an example
"
{
 
  list v = G.vertices;
  list e = G.edges;
  list lab = G.labels;
  int i,j;
  ideal I;
  poly edg;
  poly rel;
  for (i = 1; i<=size(v); i++){
    edg=0;
    for (j = 1; j<=size(e); j++){
     if (size(e[j])==2){
       if (e[j][1]==v[i]){edg=edg+lab[j];}
       if (e[j][2]==v[i]){edg=edg-lab[j];}
     } else {
       if (e[j][1]==v[i]){edg=edg+lab[j];}
     }
    }
    I=I+ideal(edg);
  }
  for (j = 1; j<=size(e); j++){
   if (size(e[j])==1){
     rel=rel+lab[j];
   }
  }
  I=I,rel;
  return(I);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  def R= lG.over;
  setring R;
  ideal I = balancingIdeal(lG);
}


proc eliminateVariables(labeledgraph G)
"USAGE:  eliminateVariables(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  labeled graph with variables of the bounded edges eliminated according to balancing condition
KEYWORDS: Feynman graph
EXAMPLE:  example eliminateVariables; shows an example
"
{
  int ringdef = (typeof(basering)=="ring");
  if (ringdef){def R1 = basering;}
  def RP=G.overpoly;
  def R=G.over;
  setring R;
  ideal I = balancingIdeal(G);
  setring RP;
  ideal I = imap(R,I);
  option(redSB);
  I=std(I);
  poly ld;
  poly ta;
  labeledgraph G1=G;
  list eliminatedVariables;
  for (int i = 1; i<=size(I);i++){
     ld=lead(I[i]);
     ta=ld-I[i];
     setring R;
     poly ld = imap(RP,ld);
     eliminatedVariables[i]=ld;
     poly ta = imap(RP,ta);
     G1=substituteGraph(G1,ld,ta);
     kill ld,ta;
     setring RP; 
  ;}
  kill ld,ta;
  setring R;
  kill I;
  G1.elimvars=eliminatedVariables;
  kill eliminatedVariables;
  setring RP;
  kill I;
  if (ringdef){setring R1;}
return(G1);}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  eliminateVariables(lG);
}

proc deleteFromIntvec(intvec v, int j){
intvec w;
int idx=1;
for (int i = 1;i<=size(v);i++){
   if (j != i){w[idx]=v[i];idx=idx+1;}
}
return(w);}


proc removeVariable(def R, int j)
"USAGE:  removeVariable(R); R ring@*
ASSUME:  R is a polynomial ring
RETURN:  polynomial ring with j-th variable removed
KEYWORDS: ring
EXAMPLE:  example removeVariable; shows an example
"
{
list L = ringlist(R);
int nv;
if ((j<1) or (j>(nvars(R)))){ERROR("Index out of range");}
L[2]=delete(L[2],j);
for (int i = 1;i<=size(L[3])-1;i++){
   nv=nv+size(L[3][i][2]);
   if (nv>=j){
      if (size(L[3][i][2])==1){L[3]=delete(L[3],i);break;}
      L[3][i][2]=deleteFromIntvec(L[3][i][2],j-nv+size(L[3][i][2]));
      break;
   }
}
def S = ring(L);
return(S);}
example
{ "EXAMPLE:"; echo=2;
ring R=0,(x,y,z),(lp(2),dp(1));
def S= removeVariable(R,2);
S;
}


proc removeParameter(def R, int j)
"USAGE:  removeParameter(R); R ring@*
ASSUME:  R is a polynomial ring
RETURN:  polynomial ring with j-th variable removed
KEYWORDS: ring
EXAMPLE:  example removeParameter; shows an example
"
{
list L0 = ringlist(R);
list L = L0[1];
int nv;
if ((j<1) or (j>(size(L[2])))){ERROR("Index out of range");}
L[2]=delete(L[2],j);
for (int i = 1;i<=size(L[3])-1;i++){
   nv=nv+size(L[3][i][2]);
   if (nv>=j){
      if (size(L[3][i][2])==1){L[3]=delete(L[3],i);break;}
      L[3][i][2]=deleteFromIntvec(L[3][i][2],j-nv+size(L[3][i][2]));
      break;
   }
}
L0[1]=L;
def S = ring(L0);
return(S);}
example
{ "EXAMPLE:"; echo=2;
ring R=(0,p(1),p(2),p(3)),(x,y,z),(lp(2),dp(1));
def S= removeParameter(R,2);
S;
}




proc substituteGraph(labeledgraph G, poly a, poly b)
"USAGE:  substituteGraph(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  substitute the variable a in the labeling by b
KEYWORDS: Feynman graph
EXAMPLE:  example eliminateVariables; shows an example
"
{
  list L=G.labels;
  for (int i = 1; i<=size(L);i++){
    L[i]=subst(L[i],a,b);
  }
  labeledgraph G1 = makeLabeledGraph(G.vertices,G.edges,G.over,L,G.overpoly);
return(G1);
}



proc feynmanDenominators(labeledgraph G)
"USAGE:  feynmanDenominators(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  ideal containing the propagators in the Feynman integral
KEYWORDS: Feynman graph
EXAMPLE:  example feynmanDenominators; shows an example
"
{
  list L = G.labels;
  def S= G.over;
  setring S;
  ideal J;
  for (int i = 1; i<=size(L);i++){
      if (size(G.edges[i])==2){J[i]=L[i]^2;}
  }
  return(J);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph lGelim = eliminateVariables(lG);
  def R = lGelim.over;
  setring R;
  ideal I = feynmanDenominators(lGelim);
  I;
}


proc propagators(labeledgraph G)
"USAGE:  propagators(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  ideal, containing the denominators in the Feynman integral
KEYWORDS: Feynman graph
EXAMPLE:  example propagators; shows an example
"
{
  list L = G.labels;
  def S= G.over;
  def RP= G.overpoly;
  setring S;
  ideal J;
  for (int i = 1; i<=size(L);i++){
      if (size(G.edges[i])==2){J[i]=L[i]^2;}
  }
  ideal infedges;
  for (i = 1; i<=size(G.edges);i++){
      if(size(G.edges[i])==1){infedges[i]=G.labels[i]^2;}
  }
  setring RP;
  ideal J = imap(S,J);
  ideal infedges = imap(S,infedges);
  J=reduce(J,std(infedges));
  setring S;
 ideal J=imap(RP,J);
  return(J);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph lGelim = eliminateVariables(lG);
  def R = lGelim.over;
  setring R;
  ideal I = propagators(lGelim);
  I;
}

proc ISP(labeledgraph G)
"USAGE:   ISP(G); G labeledgraph@*
ASSUME:   G is a labeled graph
RETURN:   ideal, containing the irreducible scalar products, that is, those scalar product which are not 
          linearly dependent on the propagators.
KEYWORDS: Feynman graph
EXAMPLE:  example ISP; shows an example
"
{
  int i;
  def S= G.over;
  def RP = G.overpoly;
  setring S;
  ideal J = propagators(G);
  list el = G.elimvars;
  ideal infedges;
  for (i = 1; i<=size(G.edges);i++){
      if(size(G.edges[i])==1){infedges[i]=G.labels[i];}
  }
  setring RP;
  ideal J = imap(S,J);
  ideal infedges = imap(S,infedges);
  J=J+infedges^2;
  if (not defined(el)){list el = imap(S,el);}
  for (i = 1; i<=size(el);i++){
      J=J+ideal(el[i]);
  }
  J=std(J);
  list L = kbase(J,2);
  ideal I = L[1..size(L)];
  kill J,infedges,el,L;
  setring S;
  ideal K=imap(RP,I);
  return(K);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(1,2),list(3,6),list(4,5),list(1,6),list(2,3),list(5,6),list(3,4),list(1),list(2),list(5),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  G1;
  ring R= G1.over;
  setring R;
  R;
  ISP(G1);
}

proc removeElimVars(labeledgraph G)
"USAGE:  removeElimVars(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  Removes the variables from G.elimvars. This key is generated by the procedure eliminateVariables.
KEYWORDS: Feynman graph
EXAMPLE:  removeElimVars G; shows an example
"
{
labeledgraph G1;
def R= G.over;
def RP = G.overpoly;
G1.vertices=G.vertices;
G1.edges = G.edges;
setring R;
list el = G.elimvars;
list lb = G.labels;
list iv,ip;
int j,i;
for (i = 1; i<=size(el);i++){
  if (rvar(el[i]) != 0){
     iv[size(iv)+1]=rvar(el[i]);
  } else {
     for (j=1;j<=npars(R);j++){ 
       if (par(j)==el[i]){ip[size(ip)+1]=j;break;}
     }
  }
}
iv = sort(iv)[1];
ip = sort(ip)[1];
def R1 = R;
for (i = size(iv); i>=1;i--){
  R1 = removeVariable(R1,iv[i]);
}
for (i = size(ip); i>=1;i--){
  R1 = removeParameter(R1,ip[i]);
}
kill iv;
setring RP;
list el = imap(R,el);
list iv;
for (i = 1; i<=size(el);i++){
  iv[size(iv)+1]=rvar(el[i]);
}
iv = sort(iv)[1];
def RP1 = RP;
for (int i = size(iv); i>=1;i--){
  RP1 = removeVariable(RP1,iv[i]);
}
setring R1;
list tr =imap(R,lb);
G1.labels = tr;
G1.over = R1;
G1.overpoly = RP1;
G1.elimvars =list();
return(G1);}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(1,2),list(3,6),list(4,5),list(1,6),list(2,3),list(5,6),list(3,4),list(1),list(2),list(5),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);
  G2;
  ring R= G2.over;
  setring R;
  R;
  G2;
}


proc computeBaikovMatrix(def G0)
"USAGE:  computeBaikovMatrix(G); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
RETURN:  a labeled graph G1, computes the Baikov matrix of G defined in G1.baikovover and stores it in G1.baikovmatrix
KEYWORDS: Feynman graph
EXAMPLE:  removeElimVars G; shows an example
"
{
  
if (typeof(G0)=="graph"){
  labeledgraph lG = labelGraph(G0,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);
  //return(computeBaikovMatrix(G2));
  kill G0;
  labeledgraph G0 = G2;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
def RP = G.overpoly;
setring R;
ideal P = propagators(G);
ideal I = ISP(G);
ideal PI=P,I;
setring RP;
ideal PI = imap(R,PI);
int i,j;
ideal gram;
int idx=1;
int startvars= npars(R)+1;
for (i = 1;i<=nvars(RP);i++){
   for (j = 1;j<=nvars(RP);j++){
     if ((i>=startvars) or (j>=startvars)){
        gram[idx] = var(i)*var(j);
     } else {
        gram[idx] = 0;
     }
     idx++;
   }
}
for (i = 1;i<startvars;i++){
   for (j = i+1;j<startvars;j++){
      PI=PI,var(i)*var(j);
  }
}
matrix A = lift(PI,gram);
int m = npars(R);
int m2 = (m*(m-1)) div 2;
int mt= m2-1;
int n = ncols(PI)-m2;
ring Z = (0,(t(1..mt),D)),(z(1..n)),dp; //change this
//ring Z = (0,t(1..mt)),(z(1..n)),dp;
matrix B[nvars(RP)][nvars(RP)];
int idx=1;
poly sumt;
list pq;
for (i=1; i<=m;i++){
  for (j=i+1; j<=m;j++){
    if (idx<=mt){
      B[i,j]=1/2*t(idx);
      sumt=sumt+1/2*t(idx);
      pq[idx] = 1/2*t(idx);
    } else {
      B[i,j]=-sumt;
      pq[idx]=-sumt;
    }
    B[j,i]=B[i,j];
    idx++;
  }
}
matrix zvars[1][n+m2] = z(1..n),pq[1..m2];
matrix A = imap(RP,A);
matrix Bentries = zvars * A;
matrix B1[nvars(RP)][nvars(RP)] = Bentries[1,1..ncols(Bentries)];
B=B+B1;
labeledgraph GG =G;
GG.baikovover=Z;
GG.baikovmatrix = B;
return(GG);}
example
{ "EXAMPLE:"; echo=2;labeledgraph G1 = computeBaikovMatrix(G);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB= G1.baikovover;
  setring RB;
  RB;
  matrix B = G1.baikovmatrix;
  printMat(B);
}


          ////////////////////////////////////////////////////////////////////////////////////////////
          //            Generate IBP identities using Module Intersecation                         //
          ///////////////////////////////////////////////////////////////////////////////////////////


proc computeM1(def G0)
"USAGE:  computeM1(G0); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
RETURN:  The module M1 over G1.baikovover that requires to compute IBP identities 
KEYWORDS: Feynman graph
"

{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
 // return(computeM1(G1));
 kill G0;
 labeledgraph G0=G1;
 
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
matrix C[n][n];
int tem=0;
int E = m;
int L = nvars(R);
list x;
for(int i=1;i<=E;i++){
  for(int j=E+1;j<=E+L;j++){ 
    tem=tem+1;
    x[tem]=[i,j];   
    for(int k=1;k<=n;k++){
      C[tem,k]=diff(B[i,j],z(k));
    }
  }
}
for(int i=E+1;i<=E+L;i++){
  for(int j=i;j<=E+L;j++){ 
    tem=tem+1;   
    x[tem]=[i,j];
    for(int k=1;k<=n;k++){
      C[tem,k]=diff(B[i,j],z(k));
    }
  }
}

matrix D=inverse(C);
module M;
int tem=1;
for(int i=E+1;i<=E+L;i++){
  for(int j=1;j<=E+L;j++){
    
    vector t=0*gen(n+1);
    for(int l=1;l<=n;l++){
      poly a=0;
      for(int k=1;k<=E+L;k++){
        //find the right row correspond to derivative
            int o=0;
            int c1;
            poly c2=0;
            if(i==k){
              c1=2;
            } else {
              c1=1;
            }
            
          for(int r=1;r<=size(x);r++){
            if([i,k]==x[r] or [k,i]==x[r] ){
              o=r;
              
            }
          }

          if(o != 0){
            c2=D[l,o];
          }
          a=a+c1*c2*B[j,k];
      }
    t=t+a*gen(l);
    }
    if(i==j){
      t=t-2*gen(n+1);
    } else {
      t=t+0*gen(n+1);
    }
    M[tem]=t;
    tem=tem+1;
  }
}
print("size M in M1");
print(size(M));
//Test the computation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
    }
  testP=testP+M[j][n+1]*F;
  if(testP != 0){
    print("Something wrong");
  }

}

return(M);
}

example
{ "EXAMPLE:"; echo=2;labeledgraph G1 = computeBaikovMatrix(G);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
    ML;
}

proc computeM2(def G0,list Nu)
"USAGE:  computeM2(G,Nu); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The module M2 over G1.baikovover that requires to compute IBP identities 
KEYWORDS: Feynman graph
"
{
  if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
 // return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0 = G1;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}

labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);

if(size(Nu) != n){
   ERROR("The length of the vector nu must equal to number of Baikov variables");
}

int tem=0;
int E = m;
int L = nvars(R);

module M2;

for(int i=1;i<=n;i++){
  if(Nu[i]>0){
              M2[i]=z(i)*gen(i);
              } else {
                      M2[i]=1*gen(i);
                      }
}
M2[n+1]=1*gen(n+1);
return(M2);
}

example
{ "EXAMPLE:"; echo=2;labeledgraph G1 = computeBaikovMatrix(G);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module M2=computeM2(G1,list(1,1,1,0,0,1,0,0,0));
    module M2=computeM2(G1, list(1,1,1,1,1,1,1,-5,0));
    
    module M2=computeM2(G1, list(1, 1, 1, -1, -3, -1, -1, -1, -1));

    M2;
  list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));

}



proc computeIBP(def G0,list Nu)
"USAGE:  computeIBP(G0,Nu); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The set of IBPS correspond to G0 and given Nu.
KEYWORDS: Feynman graph
"
{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  //return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0 = G1; 
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}

labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);

if(size(Nu) != n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}

module M1=computeM1(G,Nu);
module M2=computeM2(G,Nu);
timer=0;

option(redSB);
module MM=intersect(M1,M2);
print("size of MM");
print(MM);

module M=std(MM);
print("size of M");
print(size(M));
int elapsed_time=timer;
print("time elapsed for compute module intersection: " + string(elapsed_time));
// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
    }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}
//

ring Z= (0,t(1..(m-1)),D),(z(1..n)),dp;
setIBP S;
S.over=Z;
//S.over=RB;
S.seed=Nu;
setring Z;
module M=imap(RB,M);
int p=1;
for(int i=1;i<=size(M);i++){
  list y;
  list l;
  //computation of polynomial
  poly f=0;
  for(int j=1;j<=n;j++){
    f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));  
  }
  poly h=(D-L-E-1)/2;
  f=f-M[i][n+1]*h; 
  if(f != 0){
    int t=1;
      while(f != 0){
        y[t]=leadcoef(f);
        list nu;
        for(int k=1;k<=size(Nu);k++){
          nu[k]=Nu[k]-leadexp(f)[k];
        }
      l[t]=nu;
      t=t+1;
      f=f-lead(f);
      }
    oneIBP I;
    I.c=y;
    I.i=l;
    S.IBP[p]=I;
    p=p+1;  
  }

}
//ring Z= 0,(t(1..(m-1)),D),dp;
//S.over=Z;
return(S);

}
example
{ "EXAMPLE:"; echo=2;labeledgraph G1 = computeBaikovMatrix(G);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
    setIBP S=computeIBP(G1, list(1, 2, 1, -1, -3, -1, -1, -1, -1));

  ring R=S.over;
  setring R;
  S;
  oneIBP I=S.IBP[1];
  I;
    module M2=computeM2(G1, list(1, 2, 1, -1, -3, -1, -1, -1, -1));

}

          ////////////////////////////////////////////////////////////////////////////////////////////
          // Getting reduced IBP system to solve the reduction problem for given target integrals   //
          ///////////////////////////////////////////////////////////////////////////////////////////


//**Steps(to solve the problem sequentially)
//0. We are given the feynman graph and list of target integrals assocated to the graph which we need to solve the reduction problem
//1. Create the labelled graph and compute Baikov matrix
//2. Decide whether we need one sector web or more than one web (there are more than one integral family), to solve the problem. If there are more than one web, we have to handle them sepeately
//   so that we have different set of reduced IBP relations for each integral class.
// ** Assume we can solve the problem using one sector web
//3. Create the initial sector Web structure. Also create two lists to store independent IBP identities (say indIBPs), and master integrals (MI)
//4. Upadate the web including target integrals to the web
//5. Starting from the top layer of the web,
//6. For each sector in that layer, generate IBP relations correspond to each integrals belong to that sector.
//7. Then using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
//8. update indIBPs and ML
//9. using tail integrals, update the sector Web.
//10.If we have done step 6-8 for each sector in that layer, then move to next layer and so on.

// ** master integrals are the integrals (in our consideration) are the integrals correspond to nonzero coefficients in rref  that are belong to 
//    corresponding sector. others will be tail integrals


proc getSector(list l)
"USAGE:   getSector(l); l list@*
ASSUME:   l is a list of integer indices of a Feynman integral 
RETURN:   list L, L[1]=s The sector (a list of 1s and 0s) that the corresponding integral belongs
          L[2]=n the sector (a list of indices of s where has non-zero entries) that the corresponding integral belongs
KEYWORDS: Feynman graph
"
{
  list s;
  list n;
  for(int i=1;i<=size(l);i++){
    if(l[i]>0){ //changed
      s[i]=1;
      n[size(n)+1]=i;
    }
    else
    {
      s[i]=0;
    }
  }
  return(list(s,n));
}
example
{ "EXAMPLE:"; echo=2;list s= getSector(l);
  list l=list(1,2,-3,-4,0,1);
  list s=getSector(l);
  s;
}


proc getCombinations(list L,int r,list pre)
{
  int n=size(L);
  list op;
  if(size(pre)==r){
    op[size(op)+1]=pre;
    return(op);
  }
  if(n==0)
  {
    return(list());
  }
  list remL=delete(L,1);
  list npre=pre;
  npre[size(npre)+1]=L[1];
  list ex1=getCombinations(remL,r,npre);
  list ex2=getCombinations(remL,r,pre);
return(ex1+ex2);
}


proc listCombinations(list L,int r)
"USAGE:   listCombintions(L,r); L list, r int@*
ASSUME:  
RETURN:   list of r-combinations of the elements in the list L 
KEYWORDS: feynman graph
EXAMPLE:  example listCombinations; shows an example
"
{
  
  return(getCombinations(L,r,list()));
}

example{
ring R=0,(x,y,z),dp;
list L=listCombinations(list(1,2,3,4),3);
L[1];

}


proc generateWebSectors(list seed)
"USAGE:   generateWebSectors(seed);seed list@*
ASSUME:   seed is a list of integer values.
RETURN:   Web structure of the sectors L, where L is the list and L[1] is the sector that correspond to the seed and L[i] 
          contain the subsectors of the sectors in L[i-1]. Not that sector maps between the sectors have not been setted. 
KEYWORDS: feynman graph
EXAMPLE:  example generateWebSectors; shows an example
"
{
list L=getSector(seed);
list sector=L[1];
int nSectors=2^size(L[2]);
list sectorWeb;
for(int i=0;i<size(L[2]);i++)
  {
    list comb=listCombinations(L[2],size(L[2])-i);
    list l;
    for(int j=1;j<=size(comb);j++){
      oneSector s;
      s.lab=comb[j];
      l[j]=s;
    }
  sectorWeb[i+1]=l;
  }
return(sectorWeb);
}
example{

  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
}



proc isSubList(list l1,list l2)
"USAGE:   isSubList(l1,l2); l1 list, l2 list@*
ASSUME:   l1 and l2 are list of positive integers
RETURN:   1 if elements in l1 contain in l2
          0 if elements in l1 do not contain in l2
KEYWORDS: 
EXAMPLE:  isSubList; shows an example
"
{
  if(size(l1) > size(l2)){
    return(-1);
  }
  else{
    int ind=0;
    for(int i=1;i <= size(l1);i++){
      for(int j=1;j <= size(l2);j++){
        if(l2[j]==l1[i]){
          ind=ind+1;
        }
      }
    }
    if(ind==size(l1)){
      return(1);
    }
    else{
      return(0);
    }
  }
}
example{
  ring R=0,(x,y,z),dp;
  list l1=list(1,2,3,4,5,6,7);
  list l2=list(1,4,6);
  list l3=list(1,2,8);
  list l4=list(1,4,6);
  isSubList(l2,l1);
  isSubList(l3,l1);
  isSubList(l1,l2);
  isSubList(l2,l4);
}





proc getSectorMap(list L1,list L2)
"USAGE:   getSectorMap(L1,L2); L1 list, L2 list, sector@*
ASSUME:   L1 and L2 are list of sectors where the lab field oe each sector in both lists are filled(i.e. two layers of a sector web)
RETURN:   L1 where sectorMap  of each sector in the list L1 is filled.
KEYWORDS: sector,graph,feynman,setIBP
EXAMPLE:  getSectorMap; shows an example
"

{
//compare the containment
for(int i=1;i<=size(L1);i++)
{

  for(int j=1;j<=size(L2);j++)
  {
    oneSector s=L2[j];
    if(isSubList(L2[j].lab,L1[i].lab)==1)
    {
      L1[i].sectorMap[size(L1[i].sectorMap)+1]=j;
    }
  }
}
return(L1);
}
example{
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=getSectorMap(w[1],w[2]);
  w1[1].sectorMap;
  list w2=getSectorMap(w[2],w[3]);
  w2[2].sectorMap;
}


proc setSectorMap(list sectorWeb)
"USAGE:   setSectorMap(sectorWeb); sectorWeb list, sector@*
ASSUME:   sectorWeb is an output produced by the function @*generateWebSectors
RETURN:   sectorWeb where the field sectorMap field of each sector in sectorWeb is filled.
KEYWORDS: sector, generateWebSectors, getSectorMap
EXAMPLE:  setSectorMap; shows an example
"
{
  for(int i=1;i<=size(sectorWeb)-1;i++)
  {
    list L1=sectorWeb[i];
    list L2=sectorWeb[i+1];
    sectorWeb[i]=getSectorMap(L1,L2);
  }
  return(sectorWeb);
}
example{
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=setSectorMap(w);

}

proc findSector(list sectorWeb, list currentPosition, list L)
"USAGE:   findSector(sectorWeb,currentPosition,L); sectorWeb list,currentPosition list,L list,
ASSUME:   sectorWeb is an output produced by the function generateWebSectors@*, L is an output produced by the function getSector@*
RETURN:   position of the sector in the sectorWeb, where the L belongs. 
          -1, if the sector is not found
KEYWORDS: sector, generateWebSectors, getSectorMap
EXAMPLE:  findSector; shows an example
"
{ 
  list pos;
  for(int i=currentPosition[1];i <= size(sectorWeb);i++)
  {
    for(int j=currentPosition[2]; j<= size(sectorWeb[i]);j++)
    {
      if(isSubList(L,sectorWeb[i][j].lab) ==  1 and isSubList(sectorWeb[i][j].lab,L)  ==  1)
      {
          pos[1]=i;
          pos[2]=j;
      } 
    }

  }
  if(size(pos)==0){
    return(-1);
  }
  else
  {
    return(pos);
  }

}
example{
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=setSectorMap(w);
  list oneInt=list(4,-1,-1,0,-1,-2);
  list L=getSector(oneInt);
  def pos=findSector(w1,list(1,1),L[2]);
  isSubList(w[pos[1]][pos[2]].lab,L[2])==1 && isSubList(L[2],w[pos[1]][pos[2]].lab); //this returns 1, since the given integral is in the sector at pos.

  //example for a integral that is not in the set
  list oneInt=list(4,1,0,-1,-2,3);
  list L=getSector(oneInt);
  def pos=findSector(w1,list(1,1),L[2]);
  pos;
  
}



proc updateOneSector(list sectorWeb, list currentPosition,list oneInt)
"USAGE:   updateOneSector(sectorWeb,currentPosition,oneInt); sectorWeb list, sector@*
ASSUME:   sectorWeb is an output produced by the function generateWebSectors@*, oneInt is a list of indeces of the denominators 
          associated to an integral correspond to a given feynman graph. Also assume the sectorweb isalso  associated to the same feynman graph.
RETURN:   updated sectorWeb, where the oneInt is assigned to the targetInts field of the seector correspond to provided oneInt
KEYWORDS: sector, generateWebSectors, getSectorMap,updateWeb,findSector
EXAMPLE:  updateOneSector; shows an example
"
{
  list L=getSector(oneInt);
  list a=findSector(sectorWeb,currentPosition,L[2]);
  if(size(a)<=1)
  {
    print("given integral is not belong to the given Web");
    return(sectorWeb);
  }
  
  sectorWeb[a[1]][a[2]].targetInts[size(sectorWeb[a[1]][a[2]].targetInts)+1]=oneInt;
  return(sectorWeb);
}
example{
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=setSectorMap(w);
  list oneInt=list(4,-1,-1,0,-1,-2);
  list w2=updateOneSector(w1,list(1,1),oneInt);
  list L=getSector(oneInt);
  L[2];
  w2[3][2].lab;
}

proc updateWeb(list sectorWeb, list currentPosition,list setInt)

"USAGE:   updateWeb(sectorWeb,currentPosition,setInt); sectorWeb list, sector@*
ASSUME:   sectorWeb is an output produced by the function generateWebSectors@*, setInt is a list of indeces of the denominators 
          associated to  integrals correspond to a given feynman graph. Also assume the sectorweb is also  associated to the same feynman graph.
RETURN:   list (sectorWeb,MasterInt,notInWeb) where,
          sectorWeb is the updated web by assingning integrals to correspondng sectors,
          masterInt is the list integrals belong to the sector at currentPosition
          notInWeb is the list of integrals that are not belong the integral family associated the SectorWeb.
KEYWORDS: generateWebSectors, getSector,findSector
EXAMPLE:  updateWeb; shows an example
"

{ 
  list masterInt;
  list notInWeb;
  for(int i=1;i <= size(setInt);i++)
  { list oneInt=setInt[i];
    list L=getSector(oneInt);
    list a=findSector(sectorWeb,currentPosition,L[2]);
    if(size(a) <= 1)
    {
      notInWeb[size(notInWeb)+1]=oneInt;
    }
  
    else
    {
      sectorWeb[a[1]][a[2]].targetInts[size(sectorWeb[a[1]][a[2]].targetInts)+1]=oneInt;
      if(a[1] == currentPosition[1] and a[2] == currentPosition[2])
      {
        masterInt[size(masterInt)+1]=oneInt;
      }
    }
  }

  return(list(sectorWeb,masterInt,notInWeb));
}
example{
  "EXAMPLE:"; echo=2;
  ring R=(0,(t,D)),(x,y,z),dp;
  list l=list(1,2,1);
  list w=generateWebSectors(l);
  list w1=setSectorMap(w);
  list setInt=list(list(1,2,3),list(-1,1,2),list(1,1,-1),list(-1,0,-2));
  list setInt=list(list(1,2,3));
  list setInt=list(l);
  
  list L1=pickHighestSector(setInt);
  list w2=updateWeb(w1,list(1,1),L1[1]);
  w2[2]; //master integrals
  w2[3];//integrals not in the web
}
example{
"EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RZ= G1.baikovover;
  printMat(G1.baikovmatrix);
  
  list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list web=generateWebSectors(setInt[1]);
  list w1=setSectorMap(web); 
  web=w1;
  list L1=pickHighestSector(setInt);  
  
  list w2=updateWeb(web,list(1,1),L1[1]); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web
  web=w2[1]; 
  setIBP S=computeIBP(G1,L1[1][1]);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101); //L[1]=list of independent IBPs,L[2]=list of master integrals
  list independIBPs=L[1];
  list masterAndTailIntgrals=L[2];
  size(independIBPs) < size(S.IBP); //number of linearly independent set of IBPs are less than the number of orginal IBPs. So this returns true
  
  oneIBP I1=independIBPs[18];     //Here is an example for one IBP i
  I1;
  list w3=updateWeb(web,list(1,1),masterAndTailIntgrals); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web
  web=w3[1];   
  size(web[1][1].targetInts);
}

//-------------------------------------------------------------------------------
proc getHighestSectorIndex(list targetInt)
"USAGE:  pickHighestSector(targetInt); G is a list of list of integers of same length
ASSUME:  targetInt is the list of target integrals 
RETURN:  the intgral that belong to the heighest sector, if all integrals belong to the same sector web; otherwise, it returns a list of collection of integrals 
         each need to be handled using different sector webs,
KEYWORDS: Feynman graph
"
{
  list sortedInt1;
  list sortedInt2;
  list intsWithSectors;
  
  for(int i=1;i <= size(targetInt);i++)
  {
    list L=getSector(targetInt[i]);
    intsWithSectors[size(intsWithSectors)+1]=list(list(L[2],targetInt[i],i),list(size(L[2])));
  }
  list L=lexSort(intsWithSectors);
 return(L[size(L)][1][3]);
}



//----------------functions to unite all the tasks---------------------------------
proc pickHighestSector(list targetInt)
"USAGE:  pickHighestSector(targetInt); G is a list of list of integers of same length
ASSUME:  targetInt is the list of target integrals 
RETURN:  the intgral that belong to the heighest sector, if all integrals belong to the same sector web; otherwise, it returns a list of collection of integrals 
         each need to be handled using different sector webs,
KEYWORDS: Feynman graph
"
{
  list sortedInt1;
  list sortedInt2;
  list intsWithSectors;
  
  for(int i=1;i <= size(targetInt);i++)
  {
    list L=getSector(targetInt[i]);
    intsWithSectors[size(intsWithSectors)+1]=list(list(L[2],targetInt[i]),list(size(L[2])));
  }
  list L=lexSort(intsWithSectors);
  for(int i=size(L);i>=1;i--)
  {
    if(size(sortedInt1)==0)
    {
      sortedInt1[1]=L[i][1][1];
      sortedInt2[1]=list(L[i][1][2]);
    }
    else
    { 
      int id=0;
      for(int j=1;j<=size(sortedInt1);j++)
      { 
        if( isSubList(L[i][1][1],sortedInt1[j])==1)
        {
          sortedInt2[j][size(sortedInt2[j])+1]=L[i][1][2];
          id=id+1;
        }
      }
      if(id==0)
      {
        sortedInt1[size(sortedInt1)+1]=L[i][1][1];
        sortedInt2[size(sortedInt2)+1]=list(L[i][1][2]);
      }
    }
  } 
 
return(sortedInt2);
}
example{
  list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web
  list L=pickHighestSector(setInt);
  size(L);

  list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2)); //here we need more than one web
  list L=pickHighestSector(setInt);
  size(L);
}






proc setSerial(list L)
{
  string s= "";
  for(int i=1;i<=size(L);i++){
    s=s+string(L[i])+",";
  }
  return(s);
}


proc isInList(list l,string a)
{
int ind=0;
int t;
for(int m=1;m <= size(l);m++){
 // t=0;
 // for(int j=1;j<=size(a);j++){
 //     if(l[m][j]!=a[j]){
 //       t++;
 //     }
  //  }
  
  if(l[m]==a){
    ind++;
  }
          
}
    if(ind==0)
    {
      return(0);
    }
    else
    {
      return(1);
    }
}

//return 1 for true
proc alreadyIntheList(list l,list a)
{
int ind=0;
int t;
for(int m=1;m <= size(l);m++)
{
 // t=0;
 // for(int j=1;j<=size(a);j++){
 //     if(l[m][j]!=a[j]){
 //       t++;
 //     }
  //  }
  
  if(t!=0){
    ind++;
  }
          
}
    if(ind==size(l))
    {
      return(0);
    }
    else
    {
      return(1);
    }
}

proc heaviside(number x)
{
  if(x<0)
  {
    return(0);
  }
  else{
    return(1);
  }
}


proc getSortMeasures(list l)
"USAGE:   getSortMeasures(l); l list, 
ASSUME:   l is a list of integers (i.e a seed). 
RETURN:   list of sort measures that are used in Laporta Algorithm
KEYWORDS: Feynman graph
EXAMPLE:  getSortMeasures; shows an example
"
{
 int Nprop=0;
 int   Nid=0;
 int   r=0;
 int   s=0;
 for(int j=1;j<=size(l);j++){
      Nprop=Nprop+heaviside(l[j]-1/2);
        Nid=Nid+heaviside(l[j]-1/2)*2^(j-1);
        r=r+l[j]*heaviside(l[j]-1/2);
        s=s+absValue(l[j])*heaviside(-l[j]+1/2);
 }
return(list(Nprop,Nid,r,s));
}

proc comp_lex(list l1,list l2)
{
  for(int i=1;i <= size(l1);i++){
    if(l1[i]<l2[i]) {return(-1);} //l1<l2
    if(l1[i]>l2[i]) {return(1);} //l1>l2 
  }
  return(0); // l1=l2
}

proc lexSort(list L)
{
  int n=size(L);
  for(int i=1;i<n;i++)
  {
    for(int j=1;j <= n-i;j++)
    {
      if(comp_lex(L[j][2],L[j+1][2])==1)
      {
        list temp=L[j];
        L[j]=L[j+1];
        L[j+1]=temp;
      }
    }
  }
  return(L);
}


proc substituteList(poly f,list l)
{
  for(int i=1;i <= size(l);i++)
  { f=subst(f,par(i),l[i]);
  }
  return(f);
}
example
{ "EXAMPLE:"; echo=2;list s= getSector(l);
ring R= (0,t,D),(x,y),dp;
poly f=t*D*y+t+D;
list l=list(1,2);
substituteList(f,l);
}

proc extractCoef(oneIBP I,list ind,list l)
"USAGE:   extractCoef(I,ind,l); I oneIBP,ind list,l list,
ASSUME:   ind is the output of getSortedIntegrals, and l is the list of values over the base field I.baikovover. 
          size(l)=npars(I.baikovover)
RETURN:   list of values where, the i-th element is the evaluation of coefficient function  at values in the list l of the IBP relation oneIBP, whose index is i=ind[i][1].
KEYWORDS: feynman graph,IBPs
EXAMPLE:  extractCoef; shows an example
"
{ list v;

  for(int j=1;j <= size(ind);j++){
    int tem=0;
    for(int k=1;k <= size(I.c);k++){
      if(comp_lex(ind[j][1],I.i[k])==0){
        v[j]=substituteList(I.c[k],l);
        tem++;
      }
      if(tem==0){
        v[j]=0;
      }
    }
  } 
  return(v); 
}
example
{ "EXAMPLE:"; echo=2;list s= getSector(l);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  oneIBP I=S.IBP[1];
  I;
  list rowCorrespondToI=extractCoef(I,ind,list(1,2,9)); 
  
  // the nonzero coefficient of the IBP relation correspond to integral I(1,1,0,1,0,0,0,1,0).
  // when we use lex ordering to order the used integrals in set of IBPs, this integral correspond to the 90th place.
 // so we get only a nonzero value at position 90 and the below, the output will be 7.

  rowCorrespondToI[90]; //output will be 7
}

proc setMat(setIBP S,list val)
"USAGE:   setMat(S,val); I oneIBP,ind list,l list,
ASSUME:   size(val)=npars(I.baikovover)
RETURN:   matrix,where i-th row correspond to the evaluation of coefficient functions of i-th IBP in setIBP. 
          Columns of the matrix correspond to the all used indices in the setIBP which are ordered with respect 
          to the output ofgetSortMeasures. 
KEYWORDS: feynman graph,IBPs
EXAMPLE:  setMat; shows an example
"
{
  ring RZ=S.over;
  list ind = getSortedIntegrals(S);
  matrix X[size(S.IBP)][size(ind)];
  for(int j=1;j <= size(S.IBP);j++){
    oneIBP L=S.IBP[j];
    list v=extractCoef(L,ind,val);
    for(int k=1;k <= size(v);k++){
      X[j,k]=v[k];
    }
  }

  return(X);
}


proc setMat(setIBP S,list val,list ind){
  ring RZ=S.over;
 // list ind = getSortedIntegrals(S);
  matrix X[size(S.IBP)][size(ind)];
  for(int j=1;j <= size(S.IBP);j++){
    oneIBP L=S.IBP[j];
    list v=extractCoef(L,ind,val);
    for(int k=1;k <= size(v);k++){
      X[j,k]=v[k];
    }
  }

  return(X);
}

example
{ "EXAMPLE:"; echo=2;list s= getSector(l);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  matrix N=setMat(S,list(1,2,3),ind);
  
}


proc getRandom(int p,int s)
"USAGE:   getRandom(p,s); 
ASSUME:   p and s are positive integers.
RETURN:   a list of randomly generted integers between 0-(p-1)  size s.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRandom; shows an example
"
{
list L;
intmat m=random(p-1,1,s);
for(int i=1;i <= s;i++)
{
  L[i]=m[1,i];
}
return(L);
}

proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"

{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);

  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        indIBP[l]=S.IBP[k];
        l++;
      }
    }

  }

  //identify non-zero columns
  list seed;
  int l=1;

  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
print("size(seed)="+string(size(seed)));
  return(list(indIBP,seed));
}
example
{ "EXAMPLE:"; echo=2;list s= getSector(l);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list top = list(1, 1, 1, -1, -3, -1, -1, -1, -1);

  setIBP S=computeIBP(G1,top);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
  size(L[1])<size(S.IBP);
}



proc getSortedIntegrals(setIBP I)
"USAGE:  getSortedIntegrals(I); I setIBP,
ASSUME:   
RETURN:  list ind where each entry is a pair (indv,sortmeasures),
          indv is the list of indices(seed) appered in the setIBP 
          and sortmeasures is the output of getSortMeasures(indv).
          The function getSortedIntegrals extract the seeds appeared in the IBP identities of the setIBP,
          sort them lexicographically based on the values got from getSortMeasures and return the output.
KEYWORDS: Feynman graph
"
{
  ring RZ=I.over;
  list ind;
  list indS;
  for(int j=1;j<=size(I.IBP);j++)
  {
      oneIBP oneI=I.IBP[j];
      for(int k=1;k <= size(oneI.i);k++)
      {
        list indv=oneI.i[k];
        if(size(ind)==0){
          ind[size(ind)+1]=list(indv,getSortMeasures(indv));
          indS[size(indS)+1]=setSerial(indv);
        }
        else
        { 
          if(isInList(indS,setSerial(indv))==0){
              ind[size(ind)+1]=list(indv,getSortMeasures(indv));
              indS[size(indS)+1]=setSerial(indv);
          }
        }
      }
  }
  

  list indc=lexSort(ind);
return(indc);
}

example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); //L list of pair of sorted integrals and the corresponding sorting measures
L[1];
}



proc computeManyIBP(def G0,list setNu)

"USAGE:  computeManyIBP(G0,setNu); G0 graph@*,
ASSUME:  setNu is a list of seeds correspond to the graph G0 which are belong to the same sector 
RETURN:  setIBP S, where it contains all the IBP relations obtained by module intersection and seeding
KEYWORDS: Feynman graph,IBPs
"

{ 
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  //return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0=G1;
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
list Nu=setNu[1];
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);

if(size(Nu) != n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}
 module M1 = computeM1(G);
print("size of M1 in Many");
print(size(M1));
  module M2 = computeM2(G, Nu);
print("size of M2 in Many");
print(size(M2));

module MM=intersect(M1,M2);
print("size of MM in Many");
print(size(MM));
  option(redSB);
  module M = std(MM);
print("size of M in Many");
print(size(M));
int elapsed_time=timer;
print("time elapsed for the computation of  module intersection: " + string(elapsed_time));

// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
  }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}
//

//ring Z= (0,t(1..(m-1)),D),(z(1..n)),dp;
ring Z=RB;
setIBP S;

S.over=Z;
//S.over=RB;

S.seed=Nu;
//setring Z;
//module M=imap(RB,M);
int p=1;
for(int b=1;b<=size(setNu);b++)
{
  list Nu=setNu[b];

  for(int i=1;i<=size(M);i++)
  {
    list y;
    list l;
  //computation of polynomial
    poly f=0;
    for(int j=1;j<=n;j++)
    {
      f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));  
    }
    poly h=(D-L-E-1)/2;
    f=f-M[i][n+1]*h; 
    if(f != 0)
    {
      int t=1;
        while(f != 0)
        {
          y[t]=leadcoef(f);
          list nu;
          for(int k=1;k<=size(Nu);k++)
          {
            nu[k]=Nu[k]-leadexp(f)[k];
          }
        l[t]=nu;
        t=t+1;
        f=f-lead(f);
        }
      oneIBP I;
      I.c=y;
      I.i=l;
      S.IBP[p]=I;
      p=p+1;  
    }

  }
}
//ring Z= 0,(t(1..(m-1)),D),dp;
//S.over=Z;
return(S);
}
example{
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);

  //here we compute set of IBPs correspond to two seeds seperately
  setIBP IBP1=computeIBP(G1,list(1,1,0,1,0,1,0,-1,0));
  setIBP IBP2=computeIBP(G1,list(1,2,0,3,0,1,0,-2,0));
  size(IBP1.IBP);
  size(IBP2.IBP);
  
  //here we compute set of IBPs correspond both seeds simultaneously 
  //We can use this only when both integrals belongs to the same sector
  list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  list top = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1));
  setIBP SS=computeManyIBP(G,top);
  setIBP S=computeManyIBP(G,targetInt);
  //setIBP S=computeManyIBP(G,list(list(1,1,0,1,0,1,0,-1,0),list(1,2,0,3,0,1,0,-2,0)));
  size(S.IBP);  
}

proc getReducedIBPSystem(graph G,list targetInt )
"USAGE:  getReducedIBPSystem(G,targetInt); targetInt list,G graph@*,
ASSUME:  G is a graph and targetInt is a list of seeds of target integrals. 
RETURN:  list (reducedIBPs,MI) where  reducedIBPs::setIBP, MI::list.
          reducedIBPs contain the reduced IBP system for the target integrals
          MI contain the master integrals

KEYWORDS: Feynman graph,IBPs
"

{
  //Better to check that the provided integrals belong to the same integral family
    
    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }

   // L[1] is the list of target integrals belong to one integral family but it has arranged so that.. 
   //..L[1][1] is the integral belong to the superior sector.
  // we use this seed (i.e. target integral) to create the web structure 


  //When we do computation sequentially, it is better to have web structure of the sectors upfront.
  //We denote it by a list web, where web[i] contains the sectors belong to that layer.

  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);

  //After creating the web, we have to update it by including the target integrals to the corresponding sectors
  //Because, when we do the intended computation in sectors, we read seeds from this updated 
  //This update step need to perform with tail integrals of each sector, once the computations correspond to sectors in each layer are done. 
  //If the computation done correctly, tail integrals will only be assigned to the sectors in the below layers.

  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];

  // *this return a list w4, where w4[1] is the updated web and
  // w4[2] is the list of integrals that does not belong to the current web (if any have. usually dont!) 

  // We set two places to store reduced IBP relations (a setIBP), and master integrals (a list) that are comes from..
  //..the intended computations relevent to each sector   
  
  //before we go further,we first create the labelled graph G1 of G computing Baikov matrix
  
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;


  int nLayers=size(web);

print("They are j=" + string(nLayers) + " layers");

for (int j = 1; j <= nLayers; j++) {
    int sectorSize = size(web[j]);

    for (int k = 1; k <= sectorSize; k++) {
      print("Layer " + string(j) + " has " + string(k) + " sectors");
    }
}

  for(int j=1; j <= nLayers; j++)
    {

//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.

 int nSectors=size(web[j]);
      for(int k=1; k <= nSectors; k++)
      {
        print("Starting the computation in the sector:"+string(k)+ " at layer "+string(j)+". ");

        
        if(size(web[j][k].targetInts)>=1)
        {

          print("size(web[j][k].targetInts) before computeManyIBP " + string(size(web[j][k].targetInts)));

          setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
          print("size(totalIBP.IBP)="+string(size(totalIBP.IBP)));
         
          if(te==0){
            reducedIBPs.over=totalIBP.over;
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
//using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
          list L=getRedIBPs(totalIBP,101);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
          list indpndIBP=L[1];
          print("size(indpndIBP)="+string(size(indpndIBP)));
          list masterAndTailIntgrals=L[2];
          print("size(masterAndTailIntgrals)="+string(size(masterAndTailIntgrals)));
          
// update reducedIBPs. 
          setring R;
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];

            }
          }
    kill R;
//Update the sectors below to the current sector using masterAndTailIntgrals. In this step, we can also.. 
//..distingush the master integrals which will be assigned to MI.
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated

          print("size(web[j][k].targetInts) after updateweb "+string(size(web[j][k].targetInts)));
          list masterIntgralsInSector=w[2];
          print("size(masterIntgralsInSector)="+string(size(masterIntgralsInSector)));
          if(size(MI)==0)
          { 
            MI=masterIntgralsInSector;
          }
          else
          {
            for(int i=1;i <= size(masterIntgralsInSector);i++)
            {
              if(alreadyIntheList(MI,masterIntgralsInSector[i])==0)
              {
                MI[size(MI)+1]=masterIntgralsInSector[i];
              }
                //MI[size(MI)+1]=masterIntgralsInSector[i];
            }
          }
          print("completed the computation in the sector:"+string(k)+ " at layer "+string(j)+". ");
          
        }   
      }

    }
return(list(reducedIBPs,MI));
}
example{

  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list((1,1,1,-1,-3,-1,-1,-1,-1)), list(1,-1,1,-1,-3,-1,-1,-4,-1)); 
 
  list finalset=getReducedIBPSystem(G,targetInt);
  
  setIBP S=finalset[1];
  ring R=S.over;
  setring R;
  oneIBP I=S.IBP[5];
  I;
  size(finalset[2]);
}










proc getReducedIBPSystems(graph G,list targetInt )
"USAGE:  getReducedIBPSystem(G,targetInt); targetInt list,G graph@*,
ASSUME:  G is a graph and targetInt is a list of seeds of target integrals. 
RETURN:  list (reducedIBPs,MI) where  reducedIBPs::setIBP, MI::list.
          reducedIBPs contain the reduced IBP system for the target integrals
          MI contain the master integrals

KEYWORDS: Feynman graph,IBPs
"

{
  //Better to check that the provided integrals belong to the same integral family
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));

    list L=pickHighestSector(targetInt);
    if(size(L)>1)                           //if size(L)>1, we have to do the same for each list in L.
    {
      ERROR("provided integrals belong to more than one integral class");
    }

  list web=generateWebSectors(L[1][1]); 
  web=setSectorMap(web);

  list w4=updateWeb(web,list(1,1),targetInt); 
  web=w4[1];
  print("web=w4[1]"); 
  print(web);
  print(" ");
 
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP reducedIBPs;
  list MI;
  //reducedIBPs.over=G1.baikovover;
  int te=0;
  reducedIBPs.seed=targetInt;
  

  int nLayers=size(web);
  int nLayers=1;
int j=1;

//For each sector in that layer j, generate IBP relations correspond to each integrals belong to that sector.

    //  int nSectors=size(web[j]);
      int nSectors=1;
int k=1;
        
  
          print("size(web[j][k].targetInts) before computeManyIBP " + string(size(web[j][k].targetInts)));
                    setIBP totalIBP=computeManyIBP(G1,web[j][k].targetInts);
         
          if(te==0){
       
            reducedIBPs.over=totalIBP.over;

       
            te=te+1;
          }
         ring R=reducedIBPs.over;
                
//using finite field row reduction, identify independent IBPs, master integrals and tails integrals.
          list L=getRedIBPs(totalIBP,101);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
          list indpndIBP=L[1];
          print(" size of indpndIBP"+" "+string(size(indpndIBP)));
          list masterAndTailIntgrals=L[2];
          print("size of masterAndTailIntgrals");
          print(size(masterAndTailIntgrals));
// update reducedIBPs. 
          setring R;
          print("size(reducedIBPs.IBP)");
          print(size(reducedIBPs.IBP));
          
          if(size(reducedIBPs.IBP)==0)
          {
            //list resr = imap(reducedIBPs.over,indpndIBP);
            //reducedIBPs.IBP=resr;
            reducedIBPs.IBP=indpndIBP;
            print("reducedIBPs.IBP_Before");
            print(size(reducedIBPs.IBP));
          }
          else
          {
            for(int i=1;i <= size(indpndIBP);i++)
            {
             // reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=imap(reducedIBPs.over,indpndIBP[i]);
               reducedIBPs.IBP[size(reducedIBPs.IBP)+1]=indpndIBP[i];
            }
            print("reducedIBPs.IBP_After");
            print(size(reducedIBPs.IBP));
          }
    kill R;
//Update the sectors below to the current sector using masterAndTailIntgrals. In this step, we can also.. 
//..distingush the master integrals which will be assigned to MI.
          list w=updateWeb(web,list(j,k),masterAndTailIntgrals);
          web=w[1]; //here the web is updated

          print("size(web[j][k].targetInts) after updateweb");
          print(size(web[j][k].targetInts));

          print(" size of w[2]=");
          print(size(w[2]));
          list masterIntgralsInSector=w[2];
          print("size of masterIntgralsInSector " + string(size(masterIntgralsInSector)));
          if(size(MI)==0)
          { 
            MI=masterIntgralsInSector;
          }
          else
          {
            for(int i=1;i <= size(masterIntgralsInSector);i++)
            {
              if(alreadyIntheList(MI,masterIntgralsInSector[i])==0)
              {
                MI[size(MI)+1]=masterIntgralsInSector[i];
              }
                //MI[size(MI)+1]=masterIntgralsInSector[i];
            }
          }
          print("completed the computation in the sector:"+string(k)+ " at layer "+string(j)+". ");
          
return(list(reducedIBPs,MI));
}
example{
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt = list(list(1, 1, 1, -1, -3, 1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  //list targetInt=list(list(1,2,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5),list(0,1,1,1,1,1,1,-5,0),list(1,0,1,1,1,1,1,0,-5),list(1,1,0,1,1,1,1,-5,0),list(1,1,1,0,1,1,1,0,-5),list(1,1,1,1,0,1,1,-5,0),list(1,1,1,1,1,0,1,0,-5),list(1,1,1,1,1,1,0,-5,0),list(0,1,1,1,1,1,1,0,-5),list(1,0,1,1,1,1,1,-5,0),list(1,1,0,1,1,1,1,0,-5),list(1,1,1,0,1,1,1,-5,0),list(1,1,1,1,0,1,1,0,-5),list(1,1,1,1,1,0,1,-5,0),list(1,1,1,1,1,1,0,0,-5));
  //list targetInt=list(list(1,1,1,1,1,1,1,-5,0));
  list finalset=getReducedIBPSystem(G,targetInt);
  setIBP S=finalset[1];
  ring R=S.over;
  setring R;
  oneIBP I=S.IBP[5];
  I;
  size(finalset[2]);
}



