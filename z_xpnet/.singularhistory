;
LIB "feynman_ibp.lib";
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
list targetInt=userInput[1];
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt);
  list web = generateWebSectors(L[1][1]);
  return(web);
}
web_g(targetInt);
proc subset(list small, list big) {
  for (int i = 1; i <= size(small); i++) {
      if (!contains(big, small[i])) {
          return (0);
      }
  }
  return (1);
}
/**
* Checks if list L contains element x
* @param L: List to search
* @param x: Element to find
* @return: 1 if found, 0 otherwise
*/
proc contains(list L, int x) {
  for (int i = 1; i <= size(L); i++) {
      if (L[i] == x) {
          return (1);
      }
  }
  return (0);
}
//************************************************************************************************************************** */
// Graph Generation Function
//************************************************************************************************************************** */
/**
* Generates graph structure from web T, combining vertices and labels
* @param T: Web structure representing sector hierarchy
* @return: List containing verticesWithLabels and edges
*/
proc getGraph(list T) {
  list verticesWithLabels = list();
  list edges = list();
  int v_idx = 1;
  int e_idx = 1;
  
  // Log web size
  print("Size of web T: " + string(size(T)));
  
  // Generate vertices with labels
  for (int i = 1; i <= size(T); i++) {
      print("Size of layer " + string(i) + ": " + string(size(T[i])));
      for (int j = 1; j <= size(T[i]); j++) {
          // Store vertex coordinates and label together
          verticesWithLabels[v_idx] = list(list(i, j), T[i][j].lab);
          v_idx++;
      }
  }
  
  // Print vertices with labels
  print("Vertices with Labels:");
  for (int i = 1; i <= size(verticesWithLabels); i++) {
      list vertex = verticesWithLabels[i][1];
      list label = verticesWithLabels[i][2];
      print("(" + string(vertex[1]) + ", " + string(vertex[2]) + ")" + 
            "    Label: " + string(label));
  }
  
  // Generate edges based on subset relationships
  for (int i = 1; i < size(T); i++) {
      for (int j = 1; j <= size(T[i]); j++) {
          for (int k = 1; k <= size(T[i+1]); k++) {
              if (subset(T[i+1][k].lab, T[i][j].lab)) {
                  edges[e_idx] = list(list(i,j), list(i+1,k));
                  e_idx++;
              }
          }
      }
  }
  
  // Print edges
  print("Edges:");
  for (int i = 1; i <= size(edges); i++) {
      print("(" + string(edges[i][1][1]) + ", " + string(edges[i][1][2]) + ")" + 
            " -> (" + string(edges[i][2][1]) + ", " + string(edges[i][2][2]) + ")");
  }
  
  return (list(verticesWithLabels, edges));
}
proc getlabels(list web, int i, int j)
{
  return(web[i][j].lab);  
}
list web=web_g(targetInt);
proc subset(list small, list big) {
  for (int i = 1; i <= size(small); i++) {
      if (!contains(big, small[i])) {
          return (0);
      }
  }
  return (1);
}
/**
* Checks if list L contains element x
* @param L: List to search
* @param x: Element to find
* @return: 1 if found, 0 otherwise
*/
proc contains(list L, int x) {
  for (int i = 1; i <= size(L); i++) {
      if (L[i] == x) {
          return (1);
      }
  }
  return (0);
}
//************************************************************************************************************************** */
// Graph Generation Function
//************************************************************************************************************************** */
/**
* Generates graph structure from web T, combining vertices and labels
* @param T: Web structure representing sector hierarchy
* @return: List containing verticesWithLabels and edges
*/
proc getGraph(list T) {
  list verticesWithLabels = list();
  list edges = list();
  int v_idx = 1;
  int e_idx = 1;
  
  // Log web size
  print("Size of web T: " + string(size(T)));
  
  // Generate vertices with labels
  for (int i = 1; i <= size(T); i++) {
      print("Size of layer " + string(i) + ": " + string(size(T[i])));
      for (int j = 1; j <= size(T[i]); j++) {
          // Store vertex coordinates and label together
          verticesWithLabels[v_idx] = list(list(i, j), T[i][j].lab);
          v_idx++;
      }
  }
  
  // Print vertices with labels
  print("Vertices with Labels:");
  for (int i = 1; i <= size(verticesWithLabels); i++) {
      list vertex = verticesWithLabels[i][1];
      list label = verticesWithLabels[i][2];
      print("(" + string(vertex[1]) + ", " + string(vertex[2]) + ")" + 
            "    Label: " + string(label));
  }
  
  // Generate edges based on subset relationships
  for (int i = 1; i < size(T); i++) {
      for (int j = 1; j <= size(T[i]); j++) {
          for (int k = 1; k <= size(T[i+1]); k++) {
              if (subset(T[i+1][k].lab, T[i][j].lab)) {
                  edges[e_idx] = list(list(i,j), list(i+1,k));
                  e_idx++;
              }
          }
      }
  }
  
  // Print edges
  print("Edges:");
  for (int i = 1; i <= size(edges); i++) {
      print("(" + string(edges[i][1][1]) + ", " + string(edges[i][1][2]) + ")" + 
            " -> (" + string(edges[i][2][1]) + ", " + string(edges[i][2][2]) + ")");
  }
  
  return (list(verticesWithLabels, edges));
}
proc getlabels(list web, int i, int j)
{
  return(web[i][j].lab);  
}
list web_struct=getGraph(web);
 labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
$
LIB "feynman_ibp.lib";
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
  list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
SectOutput123;
string(SectOutput123);
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
 list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
  list tail123=SectOutput123[3];
string(SectOutput123);
$
LIB "feynman_ibp.lib";
 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
 list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
string(SectOutput123);
list size=size_OneSectorComputation(SectOutput123);
list size_sector=size_OneSectorComputation(SectOutput123);
size_sector;
SectOutput123;
SectOutput123[1];
SectOutput123[2];
SectOutput123[3];
typeof(SectOutput123[1]);
typeof(SectOutput123[2]);
typeof(SectOutput123[3]);
typeof(SectOutput123);
SectOutput123[1].IBP;
list size_sector=size_OneSectorComputation(SectOutput123);
size_sector;
SectOutput123[1].IBP;
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
  tail_[1]=list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt);
  list web = generateWebSectors(L[1][1]);
  return(web);
}
proc getlabels(list web, int i, int j)
{
  return(web[i][j].lab);  
}
//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
$
LIB "feynman_ibp.lib";

proc web_g(list targetInt)
{

  list L = pickHighestSector(targetInt);

  list web = generateWebSectors(L[1][1]);

  return(web);
}


proc getlabels(list web, int i, int j)
{
  return(web[i][j].lab);  
}


 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;


//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];

proc OneSectorComputation(labeledgraph G1,list tailInts,list sector_lab )
"USAGE:  
ASSUME:  
RETURN:  
KEYWORDS: Feynman graph,IBPs
"
{ 
  list targetInt;
  setIBP reducedIBPs; //a place to store the independent IBPs coming out from current sector
  list MIs;  //a place to store the Master integrals coming out from current sector
  list OutputtailInts;  //a place to store the tail integrals coming out from current sector
  
//1.Extract target integrals for current sector (which are tail integrals coming from parent 
//sectors)

  for(int i=1;i<=size(tailInts);i++)
  {
    for(int j=1;j<=size(tailInts[i]);j++)
    {
            if(string(getSector(tailInts[i][j])[2])==string(sector_lab)){
        targetInt[size(targetInt)+1]=tailInts[i][j];
      }
    }

  }
  print("size of targetInt: "+string(size(targetInt)));
  if(size(targetInt)==0){
    print("No input integrals came from the parents");
    return(reducedIBPs,MIs,OutputtailInts);
  }
  

//2. Computations related to sector

  setIBP totalIBP=computeManyIBP(G1,targetInt);
  list L=getRedIBPs(totalIBP,7853);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
  reducedIBPs.seed=sector_lab;
  reducedIBPs.over=G1.baikovover;
  reducedIBPs.IBP=L[1];
  for(int i=1;i<=size(L[2]);i++){
    if(string(getSector(L[2][i])[2])==string(sector_lab)){
      MIs[size(MIs)+1]=L[2][i];
    }
    else{
      OutputtailInts[size(OutputtailInts)+1]=L[2][i];
    }
  }

  
  return(list(reducedIBPs,MIs,OutputtailInts));

}

//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];

proc web_g(list targetInt)
{

  list L = pickHighestSector(targetInt);

  list web = generateWebSectors(L[1][1]);

  return(web);
}


proc getlabels(list web, int i, int j)
{
  list lab = web[i][j].lab;
  return(lab);  
}


//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
proc getlabels(list web, int i, int j)
{
  print("web: "+string(web));
  list labs = web[i][j].lab;
  return(labs);  
}


//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];

 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;


//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);

proc web_g(list targetInt)
{

  list L = pickHighestSector(targetInt);

  list web = generateWebSectors(L[1][1]);

  return(web);
}
RB;
  list web=web_g(userInput);


proc web_g(list targetInt)
{


  list L = pickHighestSector(targetInt[1]);

  list web = generateWebSectors(L[1][1]);

  return(web);
}
  list web=web_g(userInput);

web;
  list label_11=getlabels(web,1,1);

web;
web[1];
web[1][1];
web[1][1].lab;
proc getlabels(list web, int i, int j)
{
  list labs = web[i][j].lab;
  return(labs);  
}
web[1][1].lab;
  list label_11=getlabels(web,1,1);

label_11;
 list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];

proc OneSectorComputation(labeledgraph G1,list tailInts,list sector_lab )
"USAGE:  
ASSUME:  
RETURN:  
KEYWORDS: Feynman graph,IBPs
"
{ 
  list targetInt;
  setIBP reducedIBPs; //a place to store the independent IBPs coming out from current sector
  list MIs;  //a place to store the Master integrals coming out from current sector
  list OutputtailInts;  //a place to store the tail integrals coming out from current sector
  
//1.Extract target integrals for current sector (which are tail integrals coming from parent 
//sectors)

  for(int i=1;i<=size(tailInts);i++)
  {
    for(int j=1;j<=size(tailInts[i]);j++)
    {
            if(string(getSector(tailInts[i][j])[2])==string(sector_lab)){
        targetInt[size(targetInt)+1]=tailInts[i][j];
      }
    }

  }
  print("size of targetInt: "+string(size(targetInt)));
  if(size(targetInt)==0){
    print("No input integrals came from the parents");
    return(reducedIBPs,MIs,OutputtailInts);
  }
  

//2. Computations related to sector

  setIBP totalIBP=computeManyIBP(G1,targetInt);
  list L=getRedIBPs(totalIBP,7853);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
  reducedIBPs.seed=sector_lab;
  reducedIBPs.over=G1.baikovover;
  reducedIBPs.IBP=L[1];
  for(int i=1;i<=size(L[2]);i++){
    if(string(getSector(L[2][i])[2])==string(sector_lab)){
      MIs[size(MIs)+1]=L[2][i];
    }
    else{
      OutputtailInts[size(OutputtailInts)+1]=L[2][i];
    }
  }
  print("size of reducedIBPs.IBP: "+string(size(reducedIBPs.IBP)));
  print("size of MIs: "+string(size(MIs)));
  print("size of OutputtailInts: "+string(size(OutputtailInts)));
  return(list(reducedIBPs,MIs,OutputtailInts));
}
 list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
list input21;
  input21[1]=userInput[1];
  input21[2]=tail_11;
  list label_21=getlabels(web,2,1);
  list SectOutput_21=OneSectorComputation(G1,input21,label_21);
  list tail_21=SectOutput_21[3];
 list input22;
  input22[1]=userInput[1];
  input22[2]=tail_11;
  list label_22=getlabels(web,2,2);
  list SectOutput22=OneSectorComputation(G1,input22,label_22);
  list tail22=SectOutput22[3];
list input23;
  input23[1]=userInput[1];
  input23[2]=tail_11;
  list label_23=getlabels(web,2,3);
  list SectOutput23=OneSectorComputation(G1,input23,label_23);
  list tail23=SectOutput23[3];
list input33;
  input33[1]=userInput[1];
  input33[2]=tail_22;
  input33[3]=tail_23;
  input33[4]=tail_11;
  list label_33=getlabels(web,3,3);
  list SectOutput33=OneSectorComputation(G1,input33,label_33);
  list tail33=SectOutput33[3];
list input33;
  input33[1]=userInput[1];
  input33[2]=tail_22;
  input33[3]=tail_23;
  input33[4]=tail_11;
  list tail_23=SectOutput23[3];

list input33;
  input33[1]=userInput[1];
  input33[2]=tail_22;
  input33[3]=tail_23;
  input33[4]=tail_11;
  list tail_22=SectOutput_22[3];

$
