;
LIB "feynman_ibp.lib";
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
list targetInt=userInput[1];
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt);
  list web = generateWebSectors(L[1][1]);
  return(web);
}
web_g(targetInt);
proc subset(list small, list big) {
  for (int i = 1; i <= size(small); i++) {
      if (!contains(big, small[i])) {
          return (0);
      }
  }
  return (1);
}
/**
* Checks if list L contains element x
* @param L: List to search
* @param x: Element to find
* @return: 1 if found, 0 otherwise
*/
proc contains(list L, int x) {
  for (int i = 1; i <= size(L); i++) {
      if (L[i] == x) {
          return (1);
      }
  }
  return (0);
}
//************************************************************************************************************************** */
// Graph Generation Function
//************************************************************************************************************************** */
/**
* Generates graph structure from web T, combining vertices and labels
* @param T: Web structure representing sector hierarchy
* @return: List containing verticesWithLabels and edges
*/
proc getGraph(list T) {
  list verticesWithLabels = list();
  list edges = list();
  int v_idx = 1;
  int e_idx = 1;
  
  // Log web size
  print("Size of web T: " + string(size(T)));
  
  // Generate vertices with labels
  for (int i = 1; i <= size(T); i++) {
      print("Size of layer " + string(i) + ": " + string(size(T[i])));
      for (int j = 1; j <= size(T[i]); j++) {
          // Store vertex coordinates and label together
          verticesWithLabels[v_idx] = list(list(i, j), T[i][j].lab);
          v_idx++;
      }
  }
  
  // Print vertices with labels
  print("Vertices with Labels:");
  for (int i = 1; i <= size(verticesWithLabels); i++) {
      list vertex = verticesWithLabels[i][1];
      list label = verticesWithLabels[i][2];
      print("(" + string(vertex[1]) + ", " + string(vertex[2]) + ")" + 
            "    Label: " + string(label));
  }
  
  // Generate edges based on subset relationships
  for (int i = 1; i < size(T); i++) {
      for (int j = 1; j <= size(T[i]); j++) {
          for (int k = 1; k <= size(T[i+1]); k++) {
              if (subset(T[i+1][k].lab, T[i][j].lab)) {
                  edges[e_idx] = list(list(i,j), list(i+1,k));
                  e_idx++;
              }
          }
      }
  }
  
  // Print edges
  print("Edges:");
  for (int i = 1; i <= size(edges); i++) {
      print("(" + string(edges[i][1][1]) + ", " + string(edges[i][1][2]) + ")" + 
            " -> (" + string(edges[i][2][1]) + ", " + string(edges[i][2][2]) + ")");
  }
  
  return (list(verticesWithLabels, edges));
}
proc getlabels(list web, int i, int j)
{
  return(web[i][j].lab);  
}
list web=web_g(targetInt);
proc subset(list small, list big) {
  for (int i = 1; i <= size(small); i++) {
      if (!contains(big, small[i])) {
          return (0);
      }
  }
  return (1);
}
/**
* Checks if list L contains element x
* @param L: List to search
* @param x: Element to find
* @return: 1 if found, 0 otherwise
*/
proc contains(list L, int x) {
  for (int i = 1; i <= size(L); i++) {
      if (L[i] == x) {
          return (1);
      }
  }
  return (0);
}
//************************************************************************************************************************** */
// Graph Generation Function
//************************************************************************************************************************** */
/**
* Generates graph structure from web T, combining vertices and labels
* @param T: Web structure representing sector hierarchy
* @return: List containing verticesWithLabels and edges
*/
proc getGraph(list T) {
  list verticesWithLabels = list();
  list edges = list();
  int v_idx = 1;
  int e_idx = 1;
  
  // Log web size
  print("Size of web T: " + string(size(T)));
  
  // Generate vertices with labels
  for (int i = 1; i <= size(T); i++) {
      print("Size of layer " + string(i) + ": " + string(size(T[i])));
      for (int j = 1; j <= size(T[i]); j++) {
          // Store vertex coordinates and label together
          verticesWithLabels[v_idx] = list(list(i, j), T[i][j].lab);
          v_idx++;
      }
  }
  
  // Print vertices with labels
  print("Vertices with Labels:");
  for (int i = 1; i <= size(verticesWithLabels); i++) {
      list vertex = verticesWithLabels[i][1];
      list label = verticesWithLabels[i][2];
      print("(" + string(vertex[1]) + ", " + string(vertex[2]) + ")" + 
            "    Label: " + string(label));
  }
  
  // Generate edges based on subset relationships
  for (int i = 1; i < size(T); i++) {
      for (int j = 1; j <= size(T[i]); j++) {
          for (int k = 1; k <= size(T[i+1]); k++) {
              if (subset(T[i+1][k].lab, T[i][j].lab)) {
                  edges[e_idx] = list(list(i,j), list(i+1,k));
                  e_idx++;
              }
          }
      }
  }
  
  // Print edges
  print("Edges:");
  for (int i = 1; i <= size(edges); i++) {
      print("(" + string(edges[i][1][1]) + ", " + string(edges[i][1][2]) + ")" + 
            " -> (" + string(edges[i][2][1]) + ", " + string(edges[i][2][2]) + ")");
  }
  
  return (list(verticesWithLabels, edges));
}
proc getlabels(list web, int i, int j)
{
  return(web[i][j].lab);  
}
list web_struct=getGraph(web);
 labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
$
LIB "feynman_ibp.lib";
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
  list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
SectOutput123;
string(SectOutput123);
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
 list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
  list tail123=SectOutput123[3];
string(SectOutput123);
$
LIB "feynman_ibp.lib";
 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
 list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
string(SectOutput123);
list size=size_OneSectorComputation(SectOutput123);
list size_sector=size_OneSectorComputation(SectOutput123);
size_sector;
SectOutput123;
SectOutput123[1];
SectOutput123[2];
SectOutput123[3];
typeof(SectOutput123[1]);
typeof(SectOutput123[2]);
typeof(SectOutput123[3]);
typeof(SectOutput123);
SectOutput123[1].IBP;
list size_sector=size_OneSectorComputation(SectOutput123);
size_sector;
SectOutput123[1].IBP;
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
  tail_[1]=list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt);
  list web = generateWebSectors(L[1][1]);
  return(web);
}
proc getlabels(list web, int i, int j)
{
  return(web[i][j].lab);  
}
//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
$
LIB "feynman_ibp.lib";
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt);
  list web = generateWebSectors(L[1][1]);
  return(web);
}
proc getlabels(list web, int i, int j)
{
  return(web[i][j].lab);  
}
 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
proc OneSectorComputation(labeledgraph G1,list tailInts,list sector_lab )
"USAGE:  
ASSUME:  
RETURN:  
KEYWORDS: Feynman graph,IBPs
"
{ 
  list targetInt;
  setIBP reducedIBPs; //a place to store the independent IBPs coming out from current sector
  list MIs;  //a place to store the Master integrals coming out from current sector
  list OutputtailInts;  //a place to store the tail integrals coming out from current sector
  
//1.Extract target integrals for current sector (which are tail integrals coming from parent 
//sectors)
  for(int i=1;i<=size(tailInts);i++)
  {
    for(int j=1;j<=size(tailInts[i]);j++)
    {
            if(string(getSector(tailInts[i][j])[2])==string(sector_lab)){
        targetInt[size(targetInt)+1]=tailInts[i][j];
      }
    }
  }
  print("size of targetInt: "+string(size(targetInt)));
  if(size(targetInt)==0){
    print("No input integrals came from the parents");
    return(reducedIBPs,MIs,OutputtailInts);
  }
  
//2. Computations related to sector
  setIBP totalIBP=computeManyIBP(G1,targetInt);
  list L=getRedIBPs(totalIBP,7853);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
  reducedIBPs.seed=sector_lab;
  reducedIBPs.over=G1.baikovover;
  reducedIBPs.IBP=L[1];
  for(int i=1;i<=size(L[2]);i++){
    if(string(getSector(L[2][i])[2])==string(sector_lab)){
      MIs[size(MIs)+1]=L[2][i];
    }
    else{
      OutputtailInts[size(OutputtailInts)+1]=L[2][i];
    }
  }
  
  return(list(reducedIBPs,MIs,OutputtailInts));
}
//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt);
  list web = generateWebSectors(L[1][1]);
  return(web);
}
proc getlabels(list web, int i, int j)
{
  list lab = web[i][j].lab;
  return(lab);  
}
//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
proc getlabels(list web, int i, int j)
{
  print("web: "+string(web));
  list labs = web[i][j].lab;
  return(labs);  
}
//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt);
  list web = generateWebSectors(L[1][1]);
  return(web);
}
RB;
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt[1]);
  list web = generateWebSectors(L[1][1]);
  return(web);
}
  list web=web_g(userInput);
web;
  list label_11=getlabels(web,1,1);
web;
web[1];
web[1][1];
web[1][1].lab;
proc getlabels(list web, int i, int j)
{
  list labs = web[i][j].lab;
  return(labs);  
}
web[1][1].lab;
  list label_11=getlabels(web,1,1);
label_11;
 list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
proc OneSectorComputation(labeledgraph G1,list tailInts,list sector_lab )
"USAGE:  
ASSUME:  
RETURN:  
KEYWORDS: Feynman graph,IBPs
"
{ 
  list targetInt;
  setIBP reducedIBPs; //a place to store the independent IBPs coming out from current sector
  list MIs;  //a place to store the Master integrals coming out from current sector
  list OutputtailInts;  //a place to store the tail integrals coming out from current sector
  
//1.Extract target integrals for current sector (which are tail integrals coming from parent 
//sectors)
  for(int i=1;i<=size(tailInts);i++)
  {
    for(int j=1;j<=size(tailInts[i]);j++)
    {
            if(string(getSector(tailInts[i][j])[2])==string(sector_lab)){
        targetInt[size(targetInt)+1]=tailInts[i][j];
      }
    }
  }
  print("size of targetInt: "+string(size(targetInt)));
  if(size(targetInt)==0){
    print("No input integrals came from the parents");
    return(reducedIBPs,MIs,OutputtailInts);
  }
  
//2. Computations related to sector
  setIBP totalIBP=computeManyIBP(G1,targetInt);
  list L=getRedIBPs(totalIBP,7853);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
  reducedIBPs.seed=sector_lab;
  reducedIBPs.over=G1.baikovover;
  reducedIBPs.IBP=L[1];
  for(int i=1;i<=size(L[2]);i++){
    if(string(getSector(L[2][i])[2])==string(sector_lab)){
      MIs[size(MIs)+1]=L[2][i];
    }
    else{
      OutputtailInts[size(OutputtailInts)+1]=L[2][i];
    }
  }
  print("size of reducedIBPs.IBP: "+string(size(reducedIBPs.IBP)));
  print("size of MIs: "+string(size(MIs)));
  print("size of OutputtailInts: "+string(size(OutputtailInts)));
  return(list(reducedIBPs,MIs,OutputtailInts));
}
 list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
list input21;
  input21[1]=userInput[1];
  input21[2]=tail_11;
  list label_21=getlabels(web,2,1);
  list SectOutput_21=OneSectorComputation(G1,input21,label_21);
  list tail_21=SectOutput_21[3];
 list input22;
  input22[1]=userInput[1];
  input22[2]=tail_11;
  list label_22=getlabels(web,2,2);
  list SectOutput22=OneSectorComputation(G1,input22,label_22);
  list tail22=SectOutput22[3];
list input23;
  input23[1]=userInput[1];
  input23[2]=tail_11;
  list label_23=getlabels(web,2,3);
  list SectOutput23=OneSectorComputation(G1,input23,label_23);
  list tail23=SectOutput23[3];
list input33;
  input33[1]=userInput[1];
  input33[2]=tail_22;
  input33[3]=tail_23;
  input33[4]=tail_11;
  list label_33=getlabels(web,3,3);
  list SectOutput33=OneSectorComputation(G1,input33,label_33);
  list tail33=SectOutput33[3];
list input33;
  input33[1]=userInput[1];
  input33[2]=tail_22;
  input33[3]=tail_23;
  input33[4]=tail_11;
  list tail_23=SectOutput23[3];
list input33;
  input33[1]=userInput[1];
  input33[2]=tail_22;
  input33[3]=tail_23;
  input33[4]=tail_11;
  list tail_22=SectOutput_22[3];
$
LIB "feynman_ibp.lib";
graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
 list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
proc OneSectorComputation(labeledgraph G1,list tailInts,list sector_lab )
"USAGE:  
ASSUME:  
RETURN:  
KEYWORDS: Feynman graph,IBPs
"
{ 
  list targetInt;
  setIBP reducedIBPs; //a place to store the independent IBPs coming out from current sector
  list MIs;  //a place to store the Master integrals coming out from current sector
  list OutputtailInts;  //a place to store the tail integrals coming out from current sector
  
//1.Extract target integrals for current sector (which are tail integrals coming from parent 
//sectors)
  for(int i=1;i<=size(tailInts);i++)
  {
    for(int j=1;j<=size(tailInts[i]);j++)
    {
            if(string(getSector(tailInts[i][j])[2])==string(sector_lab)){
        targetInt[size(targetInt)+1]=tailInts[i][j];
      }
    }
  }
  print("size of targetInt: "+string(size(targetInt)));
  if(size(targetInt)==0){
    print("No input integrals came from the parents");
    return(reducedIBPs,MIs,OutputtailInts);
  }
  
//2. Computations related to sector
  setIBP totalIBP=computeManyIBP(G1,targetInt);
  list L=getRedIBPs(totalIBP,7853);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
  print("size(L[1]): "+string(size(L[1])));
  print("size(L[2]): "+string(size(L[2])));
  reducedIBPs.seed=sector_lab;
  reducedIBPs.over=G1.baikovover;
  reducedIBPs.IBP=L[1];
  for(int i=1;i<=size(L[2]);i++){
    if(string(getSector(L[2][i])[2])==string(sector_lab)){
      MIs[size(MIs)+1]=L[2][i];
    }
    else{
      OutputtailInts[size(OutputtailInts)+1]=L[2][i];
    }
  }
  print("size of reducedIBPs.IBP: "+string(size(reducedIBPs.IBP)));
  print("size of MIs: "+string(size(MIs)));
  print("size of OutputtailInts: "+string(size(OutputtailInts)));
  return(list(reducedIBPs,MIs,OutputtailInts));
}
 list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
proc prepareRedIBPs(setIBP S, int p)
"USAGE:   prepareRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list containing matrix N and sorted indices
KEYWORDS: feynman graph,IBPs
"
{
  def R = S.over;
  setring R;
  
  list ind = getSortedIntegrals(S);
  list val = getRandom(p, npars(R));
  matrix N = setMat(S, val, ind);
  ring RZ = (p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  setring RZ;
  matrix N = imap(R,N);
  list output=list(N, RZ, p, ind, val);
  return(output);
}
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(list(1,1,1,-1,-3,-1,-1,-1,-1)));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,7853);
  
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,7853);
size(L[1]);
list prep=prepareRedIBPs(S,7853);
proc prepareRedIBPs(setIBP S, int p)
"USAGE:   prepareRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list containing matrix N and sorted indices
KEYWORDS: feynman graph,IBPs
"
{
  def R = S.over;
  setring R;
  
  list ind = getSortedIntegrals(S);
  list val = getRandom(p, npars(R));
  matrix N = setMat(S, val, ind);
  ring RZ = (p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  setring RZ;
  matrix N = imap(R,N);
  list output=list(string(N), RZ, p, ind, val);
  return(output);
}
list prep=prepareRedIBPs(S,7853);
prep[1];
size(prep[1]);
proc getRedIBP(setIBP S, int p)
"USAGE:   getRedIBP(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
"
{
  def R = S.over;
  setring R;
  
  // Prepare matrix and get indices
  list prep = prepareRedIBPs(S, p);
  matrix N = prep[1];
  ring RZ = prep[2];
  list ind = prep[4];
  list val = prep[6];
  
  // Perform Gauss reduction
  list Z = performGaussRed(N, RZ);
  
  setring R;
  list Z = imap(RZ,Z);
  
  // Process results
  list indIBP;
print("Z[4]: " + string(Z[4]));
print("ncols(Z[1]): " + string(ncols(Z[1])));
  int l = 1;
  for(int j = 1; j <= Z[4]; j++) {
    for(int k = 1; k <= ncols(Z[1]); k++) {
      if(Z[1][j,k] != 0) {
        indIBP[l] = S.IBP[k];
        l++;
      }
    }
  }
  // Identify non-zero columns
  list seed;
  l = 1;
  print("ncols(Z[3])*nrows(Z[3]): " + string(ncols(Z[3])*nrows(Z[3])));
  for(int k = 1; k <= ncols(Z[3]); k++) {
    for(int j = 1; j <= nrows(Z[3]); j++) {
      if(Z[3][j,k] != 0) {
        seed[l] = ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
  ring R=S.over;
  setring R;
  list LL=getRedIBPs(S,7853);
size(LL[1]);
size(LL[2]);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  print("N=setMat(S,val,ind) is the matrix");
  //print(string(N));
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  print("current ring: " + string(basering));
  //print("N is the matrix");
  printMat(N);
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
  print(" size of Z[1]:"+string(nrows(Z[1]))+" * "+string(ncols(Z[1])));
  print(" size of Z[2]:"+string(nrows(Z[2]))+" * "+string(ncols(Z[2])));
  print(" size of Z[3]:"+string(nrows(Z[3]))+" * "+string(ncols(Z[3])));
  print(" size of Z[4]:"+string(Z[4]));
   setring R;
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        print("Z["+string(j)+"]["+string(k)+"]="+string(Z[1][j,k]));
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  print("size of IndIBP"+string(size(indIBP)));
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
print("size of seed"+string(size(seed)));
  return(list(indIBP,seed));
}
  list LL=getRedIBPs(S,7853);
clear
;
clear;
clean;
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  //print("N=setMat(S,val,ind) is the matrix");
  //print(string(N));
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  print("current ring: " + string(basering));
  //print("N is the matrix");
  //printMat(N);
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
  print(" size of Z[1]:"+string(nrows(Z[1]))+" * "+string(ncols(Z[1])));
  print(" size of Z[2]:"+string(nrows(Z[2]))+" * "+string(ncols(Z[2])));
  print(" size of Z[3]:"+string(nrows(Z[3]))+" * "+string(ncols(Z[3])));
  print(" size of Z[4]:"+string(Z[4]));
   setring R;
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        print("Z["+string(j)+"]["+string(k)+"]="+string(Z[1][j,k]));
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  print("size of IndIBP"+string(size(indIBP)));
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
print("size of seed"+string(size(seed)));
  return(list(indIBP,seed));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1, 1, 1, -1, -3, -1, -1, -1, -1));
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,7853);
  list L=getRedIBPs(S,7853);
;
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  //print("N=setMat(S,val,ind) is the matrix");
  //print(string(N));
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  print("current ring: " + string(basering));
  //print("N is the matrix");
  //printMat(N);
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
  print(" size of Z[1]:"+string(nrows(Z[1]))+" * "+string(ncols(Z[1])));
  print(" size of Z[2]:"+string(nrows(Z[2]))+" * "+string(ncols(Z[2])));
  print(" size of Z[3]:"+string(nrows(Z[3]))+" * "+string(ncols(Z[3])));
  print(" size of Z[4]:"+string(Z[4]));
  print("Z[1] is the matrix");
  printMat(Z[1]);
   setring R;
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      if(Z[1][j,k] != 0){
        print("Z["+string(j)+"]["+string(k)+"]="+string(Z[1][j,k]));
        indIBP[l]=S.IBP[k];
        l++;
      }
    }
  }
  print("size of IndIBP"+string(size(indIBP)));
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
print("size of seed"+string(size(seed)));
  return(list(indIBP,seed));
}
  list L=getRedIBPs(S,7853);
$
LIB "feynman_ibp.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  S;
;
proc computeIBP(def G0,list Nu)
"USAGE:  computeIBP(G0,Nu); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The set of IBPS correspond to G0 and given Nu.
KEYWORDS: Feynman graph
"
{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  //return(computeM2(G1,Nu));
  kill G0;
  labeledgraph G0 = G1; 
}
if (typeof(G0) != "labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);
if(size(Nu) != n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}
module M1=computeM1(G,Nu);
module M2=computeM2(G,Nu);
timer=0;
option(redSB);
module M=std(intersect(M1,M2));
int elapsed_time=timer;
print("time elapsed for compute module intersection: " + string(elapsed_time));
// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
    }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP != 0){
    print("Something wrong");
  }
}
//
ring Z=RB;
setIBP S;
S.over=Z;
S.seed=Nu;
//setring Z;
//module M=imap(RB,M);
int p=1;
for(int i=1;i<=size(M);i++){
  list y;
  list l;
  //computation of polynomial
  poly f=0;
  for(int j=1;j<=n;j++){
    f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));  
  }
  poly h=(D-L-E-1)/2;
  f=f-M[i][n+1]*h; 
  if(f != 0){
    int t=1;
      while(f != 0){
        y[t]=leadcoef(f);
        list nu;
        for(int k=1;k<=size(Nu);k++){
          nu[k]=Nu[k]-leadexp(f)[k];
        }
      l[t]=nu;
      t=t+1;
      f=f-lead(f);
      }
    oneIBP I;
    I.c=y;
    I.i=l;
    S.IBP[p]=I;
    p=p+1;  
  }
}
//ring Z= 0,(t(1..(m-1)),D),dp;
//S.over=Z;
setring S.over;
list LL;
for (int i=1;i<=size(S.IBP);i++){
  LL[i][1]=S.IBP[i][1]; 
  LL[i][2]=S.IBP[i][2];
}
return(list(S,LL));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  ring R=S.over;
  setring R;
  S;
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
$
LIB "feynman_ibp.lib";
proc getSortedIntegrals(setIBP I)
"USAGE:  getSortedIntegrals(I); I setIBP,
ASSUME:   
RETURN:  list ind where each entry is a pair (indv,sortmeasures),
          indv is the list of indices(seed) appered in the setIBP 
          and sortmeasures is the output of getSortMeasures(indv).
          The function getSortedIntegrals extract the seeds appeared in the IBP identities of the setIBP,
          sort them lexicographically based on the values got from getSortMeasures and return the output.
KEYWORDS: Feynman graph
"
{
  ring RZ=I.over;
  list ind;
  list indS;
  for(int j=1;j<=size(I.IBP);j++)
  {
      oneIBP oneI=I.IBP[j];
      for(int k=1;k <= size(oneI.i);k++)
      {
        list indv=oneI.i[k];
        print("indv=oneI.i["+string(k)+"]: "+string(indv));
        if(size(ind)==0){
          print("getSortMeasures(indv): "+string(getSortMeasures(indv)));
          ind[size(ind)+1]=list(indv,getSortMeasures(indv));
          indS[size(indS)+1]=setSerial(indv);
        }
        else
        { 
          if(isInList(indS,setSerial(indv))==0){
              print("getSortMeasures(indv): "+string(getSortMeasures(indv)));
              ind[size(ind)+1]=list(indv,getSortMeasures(indv));
              indS[size(indS)+1]=setSerial(indv);
          }
        }
      }
  }
  
  list indc=lexSort(ind);
return(indc);
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S);
L;
string(L);
  print("size(I.IBP): "+string(size(I.IBP)));
 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
  list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
proc OneSectorComputation(labeledgraph G1,list tailInts,list sector_lab )
"USAGE:  
ASSUME:  
RETURN:  
KEYWORDS: Feynman graph,IBPs
"
{ 
  list targetInt;
  setIBP reducedIBPs; //a place to store the independent IBPs coming out from current sector
  list MIs;  //a place to store the Master integrals coming out from current sector
  list OutputtailInts;  //a place to store the tail integrals coming out from current sector
  
//1.Extract target integrals for current sector (which are tail integrals coming from parent 
//sectors)
  for(int i=1;i<=size(tailInts);i++)
  {
    for(int j=1;j<=size(tailInts[i]);j++)
    {
            if(string(getSector(tailInts[i][j])[2])==string(sector_lab)){
        targetInt[size(targetInt)+1]=tailInts[i][j];
      }
    }
  }
  print("size of targetInt: "+string(size(targetInt)));
  if(size(targetInt)==0){
    print("No input integrals came from the parents");
    return(reducedIBPs,MIs,OutputtailInts);
  }
  
//2. Computations related to sector
  setIBP totalIBP=computeManyIBP(G1,targetInt);
  list L=getRedIBPs(totalIBP,7853);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
  print("size(L[1]): "+string(size(L[1])));
  print("size(L[2]): "+string(size(L[2])));
  reducedIBPs.seed=sector_lab;
  reducedIBPs.over=G1.baikovover;
  reducedIBPs.IBP=L[1];
  for(int i=1;i<=size(L[2]);i++){
    if(string(getSector(L[2][i])[2])==string(sector_lab)){
      MIs[size(MIs)+1]=L[2][i];
    }
    else{
      OutputtailInts[size(OutputtailInts)+1]=L[2][i];
    }
  }
  print("size of reducedIBPs.IBP: "+string(size(reducedIBPs.IBP)));
  print("size of MIs: "+string(size(MIs)));
  print("size of OutputtailInts: "+string(size(OutputtailInts)));
  return(list(reducedIBPs,MIs,OutputtailInts));
}
example{"EXAMPLE:"; echo=2;
//Setting the graph details and Baikov computations
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
  
$
LIB "feynman_ibp.lib";
 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
  
 
//sector at(1,1), label:{1,2,3} computations
  list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
$
LIB "feynman_ibp.lib";
graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
  
 
//sector at(1,1), label:{1,2,3} computations
  list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
proc OneSectorComputation(labeledgraph G1,list tailInts,list sector_lab )
"USAGE:  
ASSUME:  
RETURN:  
KEYWORDS: Feynman graph,IBPs
"
{ 
  list targetInt;
  setIBP reducedIBPs; //a place to store the independent IBPs coming out from current sector
  list MIs;  //a place to store the Master integrals coming out from current sector
  list OutputtailInts;  //a place to store the tail integrals coming out from current sector
  
//1.Extract target integrals for current sector (which are tail integrals coming from parent 
//sectors)
  for(int i=1;i<=size(tailInts);i++)
  {
    for(int j=1;j<=size(tailInts[i]);j++)
    {
            if(string(getSector(tailInts[i][j])[2])==string(sector_lab)){
        targetInt[size(targetInt)+1]=tailInts[i][j];
      }
    }
  }
  print("size of targetInt: "+string(size(targetInt)));
  if(size(targetInt)==0){
    print("No input integrals came from the parents");
    return(reducedIBPs,MIs,OutputtailInts);
  }
  
//2. Computations related to sector
  setIBP totalIBP=computeManyIBP(G1,targetInt);
  print("v: "+string(targetInt));
  print("size(totalIBP.IBP): "+string(size(totalIBP.IBP)));
  list L=getRedIBPs(totalIBP,7853);    //L[1]=,set of independent IBPs, L[2]=master and tail integrals
  print("size(L[1]): "+string(size(L[1])));
  print("size(L[2]): "+string(size(L[2])));
  reducedIBPs.seed=sector_lab;
  reducedIBPs.over=G1.baikovover;
  reducedIBPs.IBP=L[1];
  for(int i=1;i<=size(L[2]);i++){
    if(string(getSector(L[2][i])[2])==string(sector_lab)){
      MIs[size(MIs)+1]=L[2][i];
    }
    else{
      OutputtailInts[size(OutputtailInts)+1]=L[2][i];
    }
  }
  print("size of reducedIBPs.IBP: "+string(size(reducedIBPs.IBP)));
  print("size of MIs: "+string(size(MIs)));
  print("size of OutputtailInts: "+string(size(OutputtailInts)));
  return(list(reducedIBPs,MIs,OutputtailInts));
}
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   userInput[1]=list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   
   userInput[1]=list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
  
 
//sector at(1,1), label:{1,2,3} computations
  list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
$
LIB "feynman_ibp.lib";
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   userInput[1]=list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   
   userInput[1]=list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
  
 
//sector at(1,1), label:{1,2,3} computations
  list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=targetInt;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
  
 
//sector at(1,1), label:{1,2,3} computations
  list SectOutput123=OneSectorComputation(G1,userInput,list(1,2,3));
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
  list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1))
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S);
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
  list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1))
  setIBP S=computeManyIBP(G1, targetInt);
$
LIB "feynman_ibp.lib";
timer=0;
 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
//For sector at(2,1), label:{1,2} computations
  list input_21;
  input_21[1]=tail_00;
  input_21[2]=tail_11;
  list label_21=getlabels(web,2,1);
  list SectOutput_21=OneSectorComputation(G1,input_21,label_21);
  list tail_21=SectOutput_21[3];
//For sector at(2,2), label:{2,3} computations
  list input_22;
  input_22[1]=tail_00;
  input_22[2]=tail_11;
  list label_22=getlabels(web,2,2);
  list SectOutput_22=OneSectorComputation(G1,input_22,label_22);
  list tail_22=SectOutput_22[3];
  
//For sector at(2,3), label:{1,3} computations
  list input_23;
  input_23[1]=tail_00;
  input_23[2]=tail_11;
  list label_23=getlabels(web,2,3);
  list SectOutput_23=OneSectorComputation(G1,input_23,label_23);
  list tail_23=SectOutput_23[3];
//For sector at(3,1) , label :{1} computations
  list input_31; //Note that sector at (3,1) has two parents ({1,2} and {1,3}) and one grandparent ({1,2,3})
  input_31[1]=tail_00;
  input_31[2]=tail_21;
  input_31[3]=tail_23;
  input_31[4]=tail_11;
  list label_31=getlabels(web,3,1);
  list SectOutput_31=OneSectorComputation(G1,input_31,label_31);
  list tail_31=SectOutput_31[3];
//For sector at(3,2), label:{2} computations
  list input_32;
  input_32[1]=tail_00;
  input_32[2]=tail_21;
  input_32[3]=tail_22;
  input_32[4]=tail_11;
  list label_32=getlabels(web,3,2);
  list SectOutput_32=OneSectorComputation(G1,input_32,label_32);
  list tail_32=SectOutput_32[3];
//For sector at(3,3), label:{3} computations
  list input_33;
  input_33[1]=tail_00;
  input_33[2]=tail_22;
  input_33[3]=tail_23;
  input_33[4]=tail_11;
  list label_33=getlabels(web,3,3);
  list SectOutput_33=OneSectorComputation(G1,input_33,label_33);
  list tail_33=SectOutput_33[3];
  int elapsed_time=timer;
print("time elapsed for sectors computations: " + string(elapsed_time));
graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt[1]);
  list web = generateWebSectors(L[1][1]);
  return(web);
}
proc getlabels(list web, int i, int j)
{
  list labs = web[i][j].lab;
  return(labs);  
}
timer=0;
 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
//For sector at(2,1), label:{1,2} computations
  list input_21;
  input_21[1]=tail_00;
  input_21[2]=tail_11;
  list label_21=getlabels(web,2,1);
  list SectOutput_21=OneSectorComputation(G1,input_21,label_21);
  list tail_21=SectOutput_21[3];
//For sector at(2,2), label:{2,3} computations
  list input_22;
  input_22[1]=tail_00;
  input_22[2]=tail_11;
  list label_22=getlabels(web,2,2);
  list SectOutput_22=OneSectorComputation(G1,input_22,label_22);
  list tail_22=SectOutput_22[3];
  
//For sector at(2,3), label:{1,3} computations
  list input_23;
  input_23[1]=tail_00;
  input_23[2]=tail_11;
  list label_23=getlabels(web,2,3);
  list SectOutput_23=OneSectorComputation(G1,input_23,label_23);
  list tail_23=SectOutput_23[3];
//For sector at(3,1) , label :{1} computations
  list input_31; //Note that sector at (3,1) has two parents ({1,2} and {1,3}) and one grandparent ({1,2,3})
  input_31[1]=tail_00;
  input_31[2]=tail_21;
  input_31[3]=tail_23;
  input_31[4]=tail_11;
  list label_31=getlabels(web,3,1);
  list SectOutput_31=OneSectorComputation(G1,input_31,label_31);
  list tail_31=SectOutput_31[3];
//For sector at(3,2), label:{2} computations
  list input_32;
  input_32[1]=tail_00;
  input_32[2]=tail_21;
  input_32[3]=tail_22;
  input_32[4]=tail_11;
  list label_32=getlabels(web,3,2);
  list SectOutput_32=OneSectorComputation(G1,input_32,label_32);
  list tail_32=SectOutput_32[3];
//For sector at(3,3), label:{3} computations
  list input_33;
  input_33[1]=tail_00;
  input_33[2]=tail_22;
  input_33[3]=tail_23;
  input_33[4]=tail_11;
  list label_33=getlabels(web,3,3);
  list SectOutput_33=OneSectorComputation(G1,input_33,label_33);
  list tail_33=SectOutput_33[3];
  int elapsed_time=timer;
print("time elapsed for sectors computations: " + string(elapsed_time));
;
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
 
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
  //For sector at(2,1), label:{1,2} computations
  print("starting sector at(2,1)");
  list input_21;
  input_21[1]=tail_00;
  input_21[2]=tail_11;
  list label_21=getlabels(web,2,1);
  list SectOutput_21=OneSectorComputation(G1,input_21,label_21);
  list tail_21=SectOutput_21[3];
  //For sector at(2,2), label:{2,3} computations
  list input_22;
  input_22[1]=tail_00;
  input_22[2]=tail_11;
  list label_22=getlabels(web,2,2);
  list SectOutput_22=OneSectorComputation(G1,input_22,label_22);
  list tail_22=SectOutput_22[3];
  
//For sector at(2,3), label:{1,3} computations
print("starting sector at(2,3)");
  list input_23;
  input_23[1]=tail_00;
  input_23[2]=tail_11;
  list label_23=getlabels(web,2,3);
  list SectOutput_23=OneSectorComputation(G1,input_23,label_23);
  list tail_23=SectOutput_23[3];
//For sector at(3,1) , label :{1} computations
print("starting sector at(3,1)");
  list input_31; //Note that sector at (3,1) has two parents ({1,2} and {1,3}) and one grandparent ({1,2,3})
  input_31[1]=tail_00;
  input_31[2]=tail_21;
  input_31[3]=tail_23;
  input_31[4]=tail_11;
  list label_31=getlabels(web,3,1);
  list SectOutput_31=OneSectorComputation(G1,input_31,label_31);
  list tail_31=SectOutput_31[3];
//For sector at(3,2), label:{2} computations
print("starting sector at(3,2)");
  list input_32;
  input_32[1]=tail_00;
  input_32[2]=tail_21;
  input_32[3]=tail_22;
  input_32[4]=tail_11;
  list label_32=getlabels(web,3,2);
  list SectOutput_32=OneSectorComputation(G1,input_32,label_32);
  list tail_32=SectOutput_32[3];
//For sector at(3,3), label:{3} computations
print("starting sector at(3,3)");
  list input_33;
  input_33[1]=tail_00;
  input_33[2]=tail_22;
  input_33[3]=tail_23;
  input_33[4]=tail_11;
  list label_33=getlabels(web,3,3);
  list SectOutput_33=OneSectorComputation(G1,input_33,label_33);
  list tail_33=SectOutput_33[3];
  
rtimer-t;
print("timer for sector computations in ms: " + string(rtimer));
$
$
LIB "feynman_ibp.lib";
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list targetInt=list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  //list targetInt=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
  list finalset=getReducedIBPSystem(G,targetInt);
rtimer-t;
print("timer for sector computations in ms: " + string(rtimer));
  kill G0;
$
LIB "feynman_ibp.lib";
 graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
 // list targetInt=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
 list targetInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
  list finalset=getReducedIBPSystem(G,targetInt);
LIB "feynman_ibp.lib";
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
 
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
  //For sector at(2,2), label:{2,3} computations
  list input_22;
  input_22[1]=tail_00;
  input_22[2]=tail_11;
  list label_22=getlabels(web,2,2);
  list SectOutput_22=OneSectorComputation(G1,input_22,label_22);
  list tail_22=SectOutput_22[3];
  
//For sector at(2,3), label:{1,3} computations
print("starting sector at(2,3)");
  list input_23;
  input_23[1]=tail_00;
  input_23[2]=tail_11;
  list label_23=getlabels(web,2,3);
  list SectOutput_23=OneSectorComputation(G1,input_23,label_23);
  list tail_23=SectOutput_23[3];
//For sector at(3,3), label:{3} computations
print("starting sector at(3,3)");
  list input_33;
  input_33[1]=tail_00;
  input_33[2]=tail_22;
  input_33[3]=tail_23;
  input_33[4]=tail_11;
  list label_33=getlabels(web,3,3);
  list SectOutput_33=OneSectorComputation(G1,input_33,label_33);
  list tail_33=SectOutput_33[3];
  
rtimer-t;
print("timer for sector computations in ms: " + string(rtimer));
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
 
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
  list web=web_g(userInput);
$
LIB "feynman_ibp.lib";
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
 
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
  //For sector at(2,2), label:{2,3} computations
  list input_22;
  input_22[1]=tail_00;
  input_22[2]=tail_11;
  list label_22=getlabels(web,2,2);
  list SectOutput_22=OneSectorComputation(G1,input_22,label_22);
  list tail_22=SectOutput_22[3];
  
//For sector at(2,3), label:{1,3} computations
print("starting sector at(2,3)");
  list input_23;
  input_23[1]=tail_00;
  input_23[2]=tail_11;
  list label_23=getlabels(web,2,3);
  list SectOutput_23=OneSectorComputation(G1,input_23,label_23);
  list tail_23=SectOutput_23[3];
//For sector at(3,3), label:{3} computations
print("starting sector at(3,3)");
  list input_33;
  input_33[1]=tail_00;
  input_33[2]=tail_22;
  input_33[3]=tail_23;
  input_33[4]=tail_11;
  list label_33=getlabels(web,3,3);
  list SectOutput_33=OneSectorComputation(G1,input_33,label_33);
  list tail_33=SectOutput_33[3];
  
rtimer-t;
print("timer for sector computations in ms: " + string(rtimer));
$
LIB "feynman_ibp.lib";
rtimer=0;
 system("--ticks-per-sec",1000); // set timer resolution to ms
 int t=rtimer;
 
  graph  G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB=G1.baikovover;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  list label_11=getlabels(web,1,1);
  list SectOutput_11=OneSectorComputation(G1,userInput,label_11);
  list tail_11=SectOutput_11[3];
  //For sector at(2,1), label:{1,2} computations
  print("starting sector at(2,1)");
  list input_21;
  input_21[1]=tail_00;
  input_21[2]=tail_11;
  list label_21=getlabels(web,2,1);
  list SectOutput_21=OneSectorComputation(G1,input_21,label_21);
  list tail_21=SectOutput_21[3];
  //For sector at(2,2), label:{2,3} computations
  list input_22;
  input_22[1]=tail_00;
  input_22[2]=tail_11;
  list label_22=getlabels(web,2,2);
  list SectOutput_22=OneSectorComputation(G1,input_22,label_22);
  list tail_22=SectOutput_22[3];
  
//For sector at(2,3), label:{1,3} computations
print("starting sector at(2,3)");
  list input_23;
  input_23[1]=tail_00;
  input_23[2]=tail_11;
  list label_23=getlabels(web,2,3);
  list SectOutput_23=OneSectorComputation(G1,input_23,label_23);
  list tail_23=SectOutput_23[3];
/* //For sector at(3,1) , label :{1} computations
print("starting sector at(3,1)");
  list input_31; //Note that sector at (3,1) has two parents ({1,2} and {1,3}) and one grandparent ({1,2,3})
  input_31[1]=tail_00;
  input_31[2]=tail_21;
  input_31[3]=tail_23;
  input_31[4]=tail_11;
  list label_31=getlabels(web,3,1);
  list SectOutput_31=OneSectorComputation(G1,input_31,label_31);
  list tail_31=SectOutput_31[3];
 */
//For sector at(3,2), label:{2} computations
print("starting sector at(3,2)");
  list input_32;
  input_32[1]=tail_00;
  input_32[2]=tail_21;
  input_32[3]=tail_22;
  input_32[4]=tail_11;
  list label_32=getlabels(web,3,2);
  list SectOutput_32=OneSectorComputation(G1,input_32,label_32);
  list tail_32=SectOutput_32[3];
//For sector at(3,3), label:{3} computations
print("starting sector at(3,3)");
  list input_33;
  input_33[1]=tail_00;
  input_33[2]=tail_22;
  input_33[3]=tail_23;
  input_33[4]=tail_11;
  list label_33=getlabels(web,3,3);
  list SectOutput_33=OneSectorComputation(G1,input_33,label_33);
  list tail_33=SectOutput_33[3];
  
rtimer-t;
print("timer for sector computations in ms: " + string(rtimer));
sectorMap;
web;
web[1][1];
web[1][1].sectorMap;
web[2][1].sectorMap;
web[4][1].sectorMap;
web[3][1].sectorMap;
$
LIB "feynman_ibp.lib";
$
LIB "getlabel.lib";
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  print_web(web);
  getGraph(web);
  list web=web_g(userInput);
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
  list web=web_g(userInput);
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
web;
proc print_web(list web)
"USAGE: print_web(web); web = list of lists of oneSector structs"
{
  print(" web is :");
  if (size(web) == 0) {
    print("  (empty list)");
    return;
  }
  for (int i = 1; i <= size(web); i++) {
    print("  Layer " + string(i) + ":");
    list layer = web[i];
    for (int j = 1; j <= size(layer); j++) {
      if (typeof(layer[j]) == "oneSector" && defined(layer[j].lab)) {
        print("    Sector " + string(j) + ":");
        print("      lab = " + string(layer[j].lab));
        print("      sectorMap = " + string(layer[j].sectorMap));
        print("      targetInts:");
        for (int k = 1; k <= size(layer[j].targetInts); k++) {
          string s = "        [" + string(k) + "] = ";
          for (int l = 1; l <= size(layer[j].targetInts[k]); l++) {
            s = s + string(layer[j].targetInts[k][l]);
            if (l < size(layer[j].targetInts[k])) { s = s + ","; }
          }
          print(s);
        }
      } else {
        print("    Sector " + string(j) + " = (invalid or undefined)");
      }
    }
  }
}
  print_web(web);
  getGraph(web);
proc web_g(list targetInt)
{
  //print("targetInt: " + string(targetInt[1]));
  list L = pickHighestSector(targetInt[1]);
  print("L[0].size(): " + string(L[0].size()));
  // print L
  //print("L=pickHighestSector(targetInt[1]): " + string(L));
  //print("L[1][1]: " + string(L[1][1]));
  list web = generateWebSectors(L[1][1]);
  return(web);
}
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  //print("targetInt: " + string(targetInt[1]));
  list L = pickHighestSector(targetInt[1]);
  print("L[0].size(): " + string(size(L[0])));
  // print L
  //print("L=pickHighestSector(targetInt[1]): " + string(L));
  //print("L[1][1]: " + string(L[1][1]));
  list web = generateWebSectors(L[1][1]);
  return(web);
}
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  //print("targetInt: " + string(targetInt[1]));
  list L = pickHighestSector(targetInt[1]);
  print("L[0].size(): " +   size(L[0]));
  // print L
  //print("L=pickHighestSector(targetInt[1]): " + string(L));
  //print("L[1][1]: " + string(L[1][1]));
  list web = generateWebSectors(L[1][1]);
  return(web);
}
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  getGraph(web);
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt[1]);
  print("L.size(): " + string(size(L)));
  list web = generateWebSectors(L[1]);
  return(web);
}
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
;
  list web=web_g(userInput);
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt[1]);
  print("L.size(): " + size(L));
  list web = generateWebSectors(L[1]);
  return(web);
}
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt[1]);
  print("L size : " + size(L));
  list web = generateWebSectors(L[1]);
  return(web);
}
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  list L = pickHighestSector(targetInt[1]);
  print("L size : ");
  print(size(L));
  list web = generateWebSectors(L[1]);
  return(web);
}
  list web=web_g(userInput);
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
proc getSector(list l)
"USAGE:   getSector(l); l list@*
ASSUME:   l is a list of integer indices of a Feynman integral 
RETURN:   list L, L[1]=s The sector (a list of 1s and 0s) that the corresponding integral belongs
          L[2]=n The sector in that the integral belongs 
KEYWORDS: Feynman graph
"
{
  list s;
  list n;
  int i;
  for(i=1;i<=size(l);i++){
    if(l[i]>0){ //changed
      s[i]=1;
      n[size(n)+1]=i;
    }
    else
    {
      s[i]=0;
    }
  }
  return(list(s,n));
}
list l=list(1,2,-3,-4,0,1);
  list s=getSector(l);
s;
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web
  list L=pickHighestSector(setInt);
  size(L);
L;
$
LIB "feynman_ibp.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  print_web(web);
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  print_web(web);
  getGraph(web);
  list label_11=getlabels(web,1,1);
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  print("targetInt: " + string(targetInt[1]));
  list L = pickHighestSector(targetInt[1]);
  // print L
  print("L=pickHighestSector(targetInt[1]): " + string(L));
  print("L[1][1]: " + string(L[1][1]));
  list web = generateWebSectors(L[1][1]);
  return(web);
}
;
  list web=web_g(userInput);
  print_web(web);
proc print_web(list web)
"USAGE: print_web(web); web = list of lists of oneSector structs"
{
  print(" web is :");
  if (size(web) == 0) {
    print("  (empty list)");
    return;
  }
  int i, j, k, l;
  for (i = 1; i <= size(web); i++) {
    print("  Layer " + string(i) + ":");
    list layer = web[i];
    for (j = 1; j <= size(layer); j++) {
      if (typeof(layer[j]) == "oneSector" && defined(layer[j].lab)) {
        print("    Sector " + string(j) + ":");
        print("      lab = " + string(layer[j].lab));
        print("      sectorMap = " + string(layer[j].sectorMap));
        print("      targetInts:");
        for (k = 1; k <= size(layer[j].targetInts); k++) {
          string s = "        [" + string(k) + "] = ";
          for (l = 1; l <= size(layer[j].targetInts[k]); l++) {
            s = s + string(layer[j].targetInts[k][l]);
            if (l < size(layer[j].targetInts[k])) { s = s + ","; }
          }
          print(s);
        }
      } else {
        print("    Sector " + string(j) + " = (invalid or undefined)");
      }
    }
  }
}
  print_web(web);
  getGraph(web);
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  print("targetInt: " + string(targetInt[1]));
  list LL = pickHighestSector(targetInt[1]);
  // print L
  print("L=pickHighestSector(targetInt[1]): " + string(LL));
  print("LL.size(): " + string(size(LL)));
  print("L[1][1]: " + string(LL[1][1]));
  list web = generateWebSectors(LL[1][1]);
  return(web);
}
  list web=web_g(userInput);
proc web_g(list targetInt)
{
  print("targetInt: " + string(targetInt[1]));
  list LL = pickHighestSector(targetInt[1]);
  // print L
  print("L=pickHighestSector(targetInt[1]): " + string(LL));
  print("LL[1].size(): " + string(size(LL[1])));
  print("LL[1][1]: " + string(LL[1][1]));
  list web = generateWebSectors(LL[1][1]);
  return(web);
}
  list web=web_g(userInput);
  getGraph(web);
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
$
LIB "feynman_ibp.lib";
rtimer = 0;
system("--ticks-per-sec", 1000);
int t = rtimer;
// Graph setup
graph G = makeGraph(list(1,2,3,4,5,6), list(
    list(6,1), list(4,6), list(1,2), list(3,5),
    list(4,3), list(2,5), list(5,6), list(1),
    list(2), list(3), list(4)
));
// Initial data
list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list userInput; userInput[1] = tail_00;
labeledgraph G1 = computeBaikovMatrix(G);
ring RB = G1.baikovover;
print("starting sector at(1,1)");
list web = web_g(userInput);
list label_11 = getlabels(web, 1, 1);
list SectOutput_11 = OneSectorComputation(G1, userInput, label_11);
list tail_11 = SectOutput_11[3];
// Dependency map
map<string, list> tails;
tails["00"] = tail_00;
tails["11"] = tail_11;
// Define graph: sector "rc" depends on tails from listed parents
list sectorGraph = list(
  list("21", list("00", "11")),
  list("22", list("00", "11")),
  list("23", list("00", "11")),
  //list("31", list("00", "21", "23", "11")),
  //list("32", list("00", "21", "22", "11")), // comment this to skip 32
  list("33", list("00", "22", "23", "11"))  // comment this to skip 33
);
// Sector coordinates
map<string, list> coords;
coords["21"] = list(2, 1);
coords["22"] = list(2, 2);
coords["23"] = list(2, 3);
coords["31"] = list(3, 1);
coords["32"] = list(3, 2);
coords["33"] = list(3, 3);
// Loop through and compute each sector
for (int i = 1; i <= size(sectorGraph); i++) {
  string name = sectorGraph[i][1];
  list deps = sectorGraph[i][2];
  // Skip sector if you comment it out above
  if (defined(coords[name]) == 0) {
    print("Skipping sector " + name);
    continue;
  }
  print("starting sector at(" + string(coords[name][1]) + "," + string(coords[name][2]) + ")");
  list input;
  for (int j = 1; j <= size(deps); j++) {
    input[j] = tails[deps[j]];
  }
  list lbl = getlabels(web, coords[name][1], coords[name][2]);
  list result = OneSectorComputation(G1, input, lbl);
  tails[name] = result[3];
}
rtimer - t;
print("timer for sector computations in ms: " + string(rtimer));
rtimer = 0;
system("--ticks-per-sec", 1000);
int t = rtimer;
// Graph setup
graph G = makeGraph(list(1,2,3,4,5,6), list(
    list(6,1), list(4,6), list(1,2), list(3,5),
    list(4,3), list(2,5), list(5,6), list(1),
    list(2), list(3), list(4)
));
// Initial data
list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list userInput; userInput[1] = tail_00;
labeledgraph G1 = computeBaikovMatrix(G);
ring RB = G1.baikovover;
print("starting sector at(1,1)");
list web = web_g(userInput);
list label_11 = getlabels(web, 1, 1);
list SectOutput_11 = OneSectorComputation(G1, userInput, label_11);
list tail_11 = SectOutput_11[3];
// Dependency map - using lists instead of maps
list tails;
tails[1] = list("00", tail_00);
tails[2] = list("11", tail_11);
// Define graph: sector "rc" depends on tails from listed parents
list sectorGraph = list(
  list("21", list("00", "11")),
  list("22", list("00", "11")),
  list("23", list("00", "11")),
  list("31", list("00", "21", "23", "11")),
  //list("32", list("00", "21", "22", "11")), // comment this to skip 32
  //list("33", list("00", "22", "23", "11"))  // comment this to skip 33
);
// Sector coordinates - using lists instead of maps
list coords;
coords[1] = list("21", list(2, 1));
coords[2] = list("22", list(2, 2));
coords[3] = list("23", list(2, 3));
coords[4] = list("31", list(3, 1));
coords[5] = list("32", list(3, 2));
coords[6] = list("33", list(3, 3));
// Loop through and compute each sector
for (int i = 1; i <= size(sectorGraph); i++) {
  string name = sectorGraph[i][1];
  list deps = sectorGraph[i][2];
  // Skip sector if you comment it out above
  int found = 0;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      found = 1;
      break;
    }
  }
  
  if (found == 0) {
    print("Skipping sector " + name);
    continue;
  }
  // Find coordinates for this sector
  int coord_i, coord_j;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      coord_i = coords[j][2][1];
      coord_j = coords[j][2][2];
      break;
    }
  }
  print("starting sector at(" + string(coord_i) + "," + string(coord_j) + ")");
  list input;
  for (int j = 1; j <= size(deps); j++) {
    // Find the tail for this dependency
    for (int k = 1; k <= size(tails); k++) {
      if (tails[k][1] == deps[j]) {
        input[j] = tails[k][2];
        break;
      }
    }
  }
  list lbl = getlabels(web, coord_i, coord_j);
  list result = OneSectorComputation(G1, input, lbl);
  
  // Add the result to tails
  int new_index = size(tails) + 1;
  tails[new_index] = list(name, result[3]);
}
rtimer - t;
print("timer for sector computations in ms: " + string(rtimer));
rtimer = 0;
system("--ticks-per-sec", 1000);
int t = rtimer;
// Graph setup
graph G = makeGraph(list(1,2,3,4,5,6), list(
    list(6,1), list(4,6), list(1,2), list(3,5),
    list(4,3), list(2,5), list(5,6), list(1),
    list(2), list(3), list(4)
));
// Initial data
list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list userInput; userInput[1] = tail_00;
labeledgraph G1 = computeBaikovMatrix(G);
ring RB = G1.baikovover;
print("starting sector at(1,1)");
list web = web_g(userInput);
list label_11 = getlabels(web, 1, 1);
list SectOutput_11 = OneSectorComputation(G1, userInput, label_11);
list tail_11 = SectOutput_11[3];
// Dependency map - using lists instead of maps
list tails;
tails[1] = list("00", tail_00);
tails[2] = list("11", tail_11);
// Define graph: sector "rc" depends on tails from listed parents
list sectorGraph;
sectorGraph[1] = list("21", list("00", "11"));
sectorGraph[2] = list("22", list("00", "11"));
sectorGraph[3] = list("23", list("00", "11"));
sectorGraph[4] = list("31", list("00", "21", "23", "11"));
//sectorGraph[5] = list("32", list("00", "21", "22", "11")); // comment this to skip 32
//sectorGraph[6] = list("33", list("00", "22", "23", "11")); // comment this to skip 33
// Sector coordinates - using lists instead of maps
list coords;
coords[1] = list("21", list(2, 1));
coords[2] = list("22", list(2, 2));
coords[3] = list("23", list(2, 3));
coords[4] = list("31", list(3, 1));
coords[5] = list("32", list(3, 2));
coords[6] = list("33", list(3, 3));
// Loop through and compute each sector
for (int i = 1; i <= size(sectorGraph); i++) {
  string name = sectorGraph[i][1];
  list deps = sectorGraph[i][2];
  // Skip sector if you comment it out above
  int found = 0;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      found = 1;
      break;
    }
  }
  
  if (found == 0) {
    print("Skipping sector " + name);
    continue;
  }
  // Find coordinates for this sector
  int coord_i, coord_j;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      coord_i = coords[j][2][1];
      coord_j = coords[j][2][2];
      break;
    }
  }
  print("starting sector at(" + string(coord_i) + "," + string(coord_j) + ")");
  list input;
  for (int j = 1; j <= size(deps); j++) {
    // Find the tail for this dependency
    for (int k = 1; k <= size(tails); k++) {
      if (tails[k][1] == deps[j]) {
        input[j] = tails[k][2];
        break;
      }
    }
  }
  list lbl = getlabels(web, coord_i, coord_j);
  list result = OneSectorComputation(G1, input, lbl);
  
  // Add the result to tails
  int new_index = size(tails) + 1;
  tails[new_index] = list(name, result[3]);
}
rtimer - t;
print("timer for sector computations in ms: " + string(rtimer));
rtimer = 0;
system("--ticks-per-sec", 1000);
int t = rtimer;
// Graph setup
graph G = makeGraph(list(1,2,3,4,5,6), list(
    list(6,1), list(4,6), list(1,2), list(3,5),
    list(4,3), list(2,5), list(5,6), list(1),
    list(2), list(3), list(4)
));
// Initial data
list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list userInput; userInput[1] = tail_00;
labeledgraph G1 = computeBaikovMatrix(G);
ring RB = G1.baikovover;
print("starting sector at(1,1)");
list web = web_g(userInput);
list label_123 = getlabels(web, 1, 1);
list SectOutput_123 = OneSectorComputation(G1, userInput, label_123);
list tail_123 = SectOutput_123[3];
// Dependency map - using lists instead of maps
list tails;
tails[1] = list("00", tail_00);
tails[2] = list("123", tail_123);
// Define graph: sector "rc" depends on tails from listed parents
list sectorGraph;
sectorGraph[1] = list("12", list("00", "123"));
sectorGraph[2] = list("23", list("00", "123"));
//sectorGraph[3] = list("13", list("00", "123"));
//sectorGraph[4] = list("1", list("00", "12", "13", "123"));
sectorGraph[5] = list("2", list("00", "12", "23", "123")); 
//sectorGraph[6] = list("3", list("00", "23", "13", "123")); 
// Sector coordinates 
list coords;
coords[1] = list("12", list(2, 1));
coords[2] = list("23", list(2, 2));
coords[3] = list("13", list(2, 3));
coords[4] = list("1", list(3, 1));
coords[5] = list("2", list(3, 2));
coords[6] = list("3", list(3, 3));
// Loop through and compute each sector
for (int i = 1; i <= size(sectorGraph); i++) {
  string name = sectorGraph[i][1];
  list deps = sectorGraph[i][2];
  // Skip sector if you comment it out above
  int found = 0;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      found = 1;
      break;
    }
  }
  
  if (found == 0) {
    print("Skipping sector " + name);
    continue;
  }
  // Find coordinates for this sector
  int coord_i, coord_j;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      coord_i = coords[j][2][1];
      coord_j = coords[j][2][2];
      break;
    }
  }
  print("starting sector at(" + string(coord_i) + "," + string(coord_j) + ")");
  list input;
  for (int j = 1; j <= size(deps); j++) {
    // Find the tail for this dependency
    for (int k = 1; k <= size(tails); k++) {
      if (tails[k][1] == deps[j]) {
        input[j] = tails[k][2];
        break;
      }
    }
  }
  list lbl = getlabels(web, coord_i, coord_j);
  list result = OneSectorComputation(G1, input, lbl);
  
  // Add the result to tails
  int new_index = size(tails) + 1;
  tails[new_index] = list(name, result[3]);
}
rtimer - t;
print("timer for sector computations in ms: " + string(rtimer));
rtimer = 0;
system("--ticks-per-sec", 1000);
int t = rtimer;
// Graph setup
graph G = makeGraph(list(1,2,3,4,5,6), list(
    list(6,1), list(4,6), list(1,2), list(3,5),
    list(4,3), list(2,5), list(5,6), list(1),
    list(2), list(3), list(4)
));
// Initial data
list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list userInput; userInput[1] = tail_00;
labeledgraph G1 = computeBaikovMatrix(G);
ring RB = G1.baikovover;
print("starting sector at(1,1)");
list web = web_g(userInput);
list label_11 = getlabels(web, 1, 1);
list SectOutput_11 = OneSectorComputation(G1, userInput, label_11);
list tail_11 = SectOutput_11[3];
// Dependency map - using lists instead of maps
list tails;
tails[1] = list("00", tail_00);
tails[2] = list("11", tail_11);
// Define graph: sector "rc" depends on tails from listed parents
list sectorGraph;
sectorGraph[1] = list("21", list("00", "11"));
//sectorGraph[2] = list("22", list("00", "11"));
sectorGraph[3] = list("23", list("00", "11"));
sectorGraph[4] = list("31", list("00", "21", "23", "11"));
//sectorGraph[5] = list("32", list("00", "21", "22", "11")); 
//sectorGraph[6] = list("33", list("00", "22", "23", "11")); 
// Sector coordinates - using lists instead of maps
list coords;
coords[1] = list("21", list(2, 1));
coords[2] = list("22", list(2, 2));
coords[3] = list("23", list(2, 3));
coords[4] = list("31", list(3, 1));
coords[5] = list("32", list(3, 2));
coords[6] = list("33", list(3, 3));
// Loop through and compute each sector
for (int i = 1; i <= size(sectorGraph); i++) {
  string name = sectorGraph[i][1];
  list deps = sectorGraph[i][2];
  // Skip sector if you comment it out above
  int found = 0;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      found = 1;
      break;
    }
  }
  
  if (found == 0) {
    print("Skipping sector " + name);
    continue;
  }
  // Find coordinates for this sector
  int coord_i, coord_j;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      coord_i = coords[j][2][1];
      coord_j = coords[j][2][2];
      break;
    }
  }
  print("starting sector at(" + string(coord_i) + "," + string(coord_j) + ")");
  list input;
  for (int j = 1; j <= size(deps); j++) {
    // Find the tail for this dependency
    for (int k = 1; k <= size(tails); k++) {
      if (tails[k][1] == deps[j]) {
        input[j] = tails[k][2];
        break;
      }
    }
  }
  list lbl = getlabels(web, coord_i, coord_j);
  list result = OneSectorComputation(G1, input, lbl);
  
  // Add the result to tails
  int new_index = size(tails) + 1;
  tails[new_index] = list(name, result[3]);
}
rtimer - t;
print("timer for sector computations in ms: " + string(rtimer));
rtimer = 0;
system("--ticks-per-sec", 1000);
int t = rtimer;
// Graph setup
graph G = makeGraph(list(1,2,3,4,5,6), list(
    list(6,1), list(4,6), list(1,2), list(3,5),
    list(4,3), list(2,5), list(5,6), list(1),
    list(2), list(3), list(4)
));
// Initial data
list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list userInput; userInput[1] = tail_00;
labeledgraph G1 = computeBaikovMatrix(G);
ring RB = G1.baikovover;
print("starting sector at(1,1)");
list web = web_g(userInput);
list label_11 = getlabels(web, 1, 1);
list SectOutput_11 = OneSectorComputation(G1, userInput, label_11);
list tail_11 = SectOutput_11[3];
// Dependency map - using lists instead of maps
list tails;
tails[1] = list("00", tail_00);
tails[2] = list("11", tail_11);
// Define graph: sector "rc" depends on tails from listed parents
list sectorGraph;
sectorGraph[1] = list("21", list("00", "11"));
//sectorGraph[2] = list("22", list("00", "11"));
sectorGraph[3] = list("23", list("00", "11"));
sectorGraph[4] = list("31", list("00", "21", "23", "11"));
//sectorGraph[5] = list("32", list("00", "21", "22", "11")); 
//sectorGraph[6] = list("33", list("00", "22", "23", "11")); 
// Sector coordinates - using lists instead of maps
list coords;
coords[1] = list("21", list(2, 1));
coords[2] = list("22", list(2, 2));
coords[3] = list("23", list(2, 3));
coords[4] = list("31", list(3, 1));
coords[5] = list("32", list(3, 2));
coords[6] = list("33", list(3, 3));
// Loop through and compute each sector
for (int i = 1; i <= size(sectorGraph); i++) {
  // Get the sector name and dependencies
  list sectorInfo = sectorGraph[i];
  string name = sectorInfo[1];
  list deps = sectorInfo[2];
  // Skip sector if you comment it out above
  int found = 0;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      found = 1;
      break;
    }
  }
  
  if (found == 0) {
    print("Skipping sector " + name);
    continue;
  }
  // Find coordinates for this sector
  int coord_i, coord_j;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      coord_i = coords[j][2][1];
      coord_j = coords[j][2][2];
      break;
    }
  }
  print("starting sector at(" + string(coord_i) + "," + string(coord_j) + ")");
  list input;
  for (int j = 1; j <= size(deps); j++) {
    // Find the tail for this dependency
    for (int k = 1; k <= size(tails); k++) {
      if (tails[k][1] == deps[j]) {
        input[j] = tails[k][2];
        break;
      }
    }
  }
  list lbl = getlabels(web, coord_i, coord_j);
  list result = OneSectorComputation(G1, input, lbl);
  
  // Add the result to tails
  int new_index = size(tails) + 1;
  tails[new_index] = list(name, result[3]);
}
rtimer - t;
print("timer for sector computations in ms: " + string(rtimer));
rtimer = 0;
system("--ticks-per-sec", 1000);
int t = rtimer;
// Graph setup
graph G = makeGraph(list(1,2,3,4,5,6), list(
    list(6,1), list(4,6), list(1,2), list(3,5),
    list(4,3), list(2,5), list(5,6), list(1),
    list(2), list(3), list(4)
));
// Initial data
list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list userInput; userInput[1] = tail_00;
labeledgraph G1 = computeBaikovMatrix(G);
ring RB = G1.baikovover;
print("starting sector at(1,1)");
list web = web_g(userInput);
list label_11 = getlabels(web, 1, 1);
list SectOutput_11 = OneSectorComputation(G1, userInput, label_11);
list tail_11 = SectOutput_11[3];
// Dependency map - using lists instead of maps
list tails;
tails[1] = list("00", tail_00);
tails[2] = list("11", tail_11);
// Define graph: sector "rc" depends on tails from listed parents
list sectorGraph;
sectorGraph[1] = list("21", list("00", "11"));
//sectorGraph[2] = list("22", list("00", "11"));
sectorGraph[3] = list("23", list("00", "11"));
sectorGraph[4] = list("31", list("00", "21", "23", "11"));
//sectorGraph[5] = list("32", list("00", "21", "22", "11")); 
//sectorGraph[6] = list("33", list("00", "22", "23", "11")); 
// Sector coordinates - using lists instead of maps
list coords;
coords[1] = list("21", list(2, 1));
coords[2] = list("22", list(2, 2));
coords[3] = list("23", list(2, 3));
coords[4] = list("31", list(3, 1));
coords[5] = list("32", list(3, 2));
coords[6] = list("33", list(3, 3));
// Loop through and compute each sector
for (int i = 1; i <= size(sectorGraph); i++) {
  // Get the sector name and dependencies
  list sectorInfo = sectorGraph[i];
  string name = sectorInfo[1];
  list deps = sectorInfo[2];
  // Skip sector if you comment it out above
  int found = 0;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      found = 1;
      break;
    }
  }
  
  if (found == 0) {
    print("Skipping sector " + name);
    continue;
  }
  // Find coordinates for this sector
  int coord_i, coord_j;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      coord_i = coords[j][2][1];
      coord_j = coords[j][2][2];
      break;
    }
  }
  print("starting sector at(" + string(coord_i) + "," + string(coord_j) + ")");
  list input;
  for (int j = 1; j <= size(deps); j++) {
    // Find the tail for this dependency
    for (int k = 1; k <= size(tails); k++) {
      if (tails[k][1] == deps[j]) {
        input[j] = tails[k][2];
        break;
      }
    }
  }
  list lbl = getlabels(web, coord_i, coord_j);
  list result = OneSectorComputation(G1, input, lbl);
  
  // Add the result to tails
  int new_index = size(tails) + 1;
  tails[new_index] = list(name, result[3]);
}
rtimer - t;
print("timer for sector computations in ms: " + string(rtimer));
rtimer = 0;
system("--ticks-per-sec", 1000);
int t = rtimer;
// Graph setup
graph G = makeGraph(list(1,2,3,4,5,6), list(
    list(6,1), list(4,6), list(1,2), list(3,5),
    list(4,3), list(2,5), list(5,6), list(1),
    list(2), list(3), list(4)
));
// Initial data
list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list userInput; userInput[1] = tail_00;
labeledgraph G1 = computeBaikovMatrix(G);
ring RB = G1.baikovover;
print("starting sector at(1,1)");
list web = web_g(userInput);
list label_11 = getlabels(web, 1, 1);
list SectOutput_11 = OneSectorComputation(G1, userInput, label_11);
list tail_11 = SectOutput_11[3];
// Dependency map - using lists instead of maps
list tails;
tails[1] = list("00", tail_00);
tails[2] = list("11", tail_11);
// Define graph: sector "rc" depends on tails from listed parents
list sectorGraph;
sectorGraph[1] = list("21", list("00", "11"));
//sectorGraph[2] = list("22", list("00", "11"));
sectorGraph[3] = list("23", list("00", "11"));
sectorGraph[4] = list("31", list("00", "21", "23", "11"));
//sectorGraph[5] = list("32", list("00", "21", "22", "11")); 
//sectorGraph[6] = list("33", list("00", "22", "23", "11")); 
// Sector coordinates - using lists instead of maps
list coords;
coords[1] = list("21", list(2, 1));
coords[2] = list("22", list(2, 2));
coords[3] = list("23", list(2, 3));
coords[4] = list("31", list(3, 1));
coords[5] = list("32", list(3, 2));
coords[6] = list("33", list(3, 3));
// Loop through and compute each sector
for (int i = 1; i <= size(sectorGraph); i++) {
  // Get the sector name and dependencies
  print("sectorGraph[i]: " + string(sectorGraph[i]));
  print("size of sectorGraph[i]: " + size(sectorGraph[i]));
  def sectorInfo = sectorGraph[i];
  string name = sectorInfo[1];
  list deps = sectorInfo[2];
  // Skip sector if you comment it out above
  int found = 0;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      found = 1;
      break;
    }
  }
  
  if (found == 0) {
    print("Skipping sector " + name);
    continue;
  }
  // Find coordinates for this sector
  int coord_i, coord_j;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      coord_i = coords[j][2][1];
      coord_j = coords[j][2][2];
      break;
    }
  }
  print("starting sector at(" + string(coord_i) + "," + string(coord_j) + ")");
  list input;
  for (int j = 1; j <= size(deps); j++) {
    // Find the tail for this dependency
    for (int k = 1; k <= size(tails); k++) {
      if (tails[k][1] == deps[j]) {
        input[j] = tails[k][2];
        break;
      }
    }
  }
  list lbl = getlabels(web, coord_i, coord_j);
  list result = OneSectorComputation(G1, input, lbl);
  
  // Add the result to tails
  int new_index = size(tails) + 1;
  tails[new_index] = list(name, result[3]);
}
rtimer - t;
print("timer for sector computations in ms: " + string(rtimer));
rtimer = 0;
system("--ticks-per-sec", 1000);
int t = rtimer;
// Graph setup
graph G = makeGraph(list(1,2,3,4,5,6), list(
    list(6,1), list(4,6), list(1,2), list(3,5),
    list(4,3), list(2,5), list(5,6), list(1),
    list(2), list(3), list(4)
));
// Initial data
list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list userInput; userInput[1] = tail_00;
labeledgraph G1 = computeBaikovMatrix(G);
ring RB = G1.baikovover;
print("starting sector at(1,1)");
list web = web_g(userInput);
list label_11 = getlabels(web, 1, 1);
list SectOutput_11 = OneSectorComputation(G1, userInput, label_11);
list tail_11 = SectOutput_11[3];
// Dependency map - using lists instead of maps
list tails;
tails[1] = list("00", tail_00);
tails[2] = list("11", tail_11);
// Define graph: sector "rc" depends on tails from listed parents
list sectorGraph;
sectorGraph[1] = list("21", list("00", "11"));
//sectorGraph[2] = list("22", list("00", "11"));
sectorGraph[3] = list("23", list("00", "11"));
sectorGraph[4] = list("31", list("00", "21", "23", "11"));
//sectorGraph[5] = list("32", list("00", "21", "22", "11")); 
//sectorGraph[6] = list("33", list("00", "22", "23", "11")); 
// Sector coordinates - using lists instead of maps
list coords;
coords[1] = list("21", list(2, 1));
coords[2] = list("22", list(2, 2));
coords[3] = list("23", list(2, 3));
coords[4] = list("31", list(3, 1));
coords[5] = list("32", list(3, 2));
coords[6] = list("33", list(3, 3));
// Loop through and compute each sector
for (int i = 1; i <= size(sectorGraph); i++) {
  // Get the sector name and dependencies
  print("sectorGraph[i]: " + string(sectorGraph[i]));
  print("type of sectorGraph[i]: " + typeof(sectorGraph[i]));
  list sectorInfo = sectorGraph[i];
  string name = sectorInfo[1];
  print("type of name: " + typeof(name));
  list deps = sectorInfo[2];
  print("type of deps: " + typeof(deps));
  // Skip sector if you comment it out above
  int found = 0;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      found = 1;
      break;
    }
  }
  
  if (found == 0) {
    print("Skipping sector " + name);
    continue;
  }
  // Find coordinates for this sector
  int coord_i, coord_j;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      coord_i = coords[j][2][1];
      coord_j = coords[j][2][2];
      break;
    }
  }
  print("starting sector at(" + string(coord_i) + "," + string(coord_j) + ")");
  list input;
  for (int j = 1; j <= size(deps); j++) {
    // Find the tail for this dependency
    for (int k = 1; k <= size(tails); k++) {
      if (tails[k][1] == deps[j]) {
        input[j] = tails[k][2];
        break;
      }
    }
  }
  list lbl = getlabels(web, coord_i, coord_j);
  list result = OneSectorComputation(G1, input, lbl);
  
  // Add the result to tails
  int new_index = size(tails) + 1;
  tails[new_index] = list(name, result[3]);
}
rtimer - t;
print("timer for sector computations in ms: " + string(rtimer));
rtimer = 0;
system("--ticks-per-sec", 1000);
int t = rtimer;
// Graph setup
graph G = makeGraph(list(1,2,3,4,5,6), list(
    list(6,1), list(4,6), list(1,2), list(3,5),
    list(4,3), list(2,5), list(5,6), list(1),
    list(2), list(3), list(4)
));
// Initial data
list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
list userInput; userInput[1] = tail_00;
labeledgraph G1 = computeBaikovMatrix(G);
ring RB = G1.baikovover;
print("starting sector at(1,1)");
list web = web_g(userInput);
list label_11 = getlabels(web, 1, 1);
list SectOutput_11 = OneSectorComputation(G1, userInput, label_11);
list tail_11 = SectOutput_11[3];
// Dependency map - using lists instead of maps
list tails;
tails[1] = list("00", tail_00);
tails[2] = list("11", tail_11);
// Define graph: sector "rc" depends on tails from listed parents
list sectorGraph;
sectorGraph[1] = list("21", list("00", "11"));
//sectorGraph[2] = list("22", list("00", "11"));
sectorGraph[3] = list("23", list("00", "11"));
sectorGraph[4] = list("31", list("00", "21", "23", "11"));
//sectorGraph[5] = list("32", list("00", "21", "22", "11")); 
//sectorGraph[6] = list("33", list("00", "22", "23", "11")); 
// Sector coordinates - using lists instead of maps
list coords;
coords[1] = list("21", list(2, 1));
coords[2] = list("22", list(2, 2));
coords[3] = list("23", list(2, 3));
coords[4] = list("31", list(3, 1));
coords[5] = list("32", list(3, 2));
coords[6] = list("33", list(3, 3));
// Loop through and compute each sector
for (int i = 1; i <= size(sectorGraph); i++) {
  // Check if this entry exists and is valid
  if (typeof(sectorGraph[i]) == "none") {
    print("Skipping undefined sector at index " + string(i));
    continue;
  }
  
  // Get the sector name and dependencies
  print("sectorGraph[i]: " + string(sectorGraph[i]));
  print("type of sectorGraph[i]: " + typeof(sectorGraph[i]));
  list sectorInfo = sectorGraph[i];
  
  string name = sectorInfo[1];
  print("type of name: " + typeof(sectorInfo[1]));
  list deps = sectorInfo[2];
  print("type of deps: " + typeof(deps));
  // Skip sector if you comment it out above
  int found = 0;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      found = 1;
      break;
    }
  }
  
  if (found == 0) {
    print("Skipping sector " + name);
    continue;
  }
  // Find coordinates for this sector
  int coord_i, coord_j;
  for (int j = 1; j <= size(coords); j++) {
    if (coords[j][1] == name) {
      coord_i = coords[j][2][1];
      coord_j = coords[j][2][2];
      break;
    }
  }
  print("starting sector at(" + string(coord_i) + "," + string(coord_j) + ")");
  list input;
  for (int j = 1; j <= size(deps); j++) {
    // Find the tail for this dependency
    for (int k = 1; k <= size(tails); k++) {
      if (tails[k][1] == deps[j]) {
        input[j] = tails[k][2];
        break;
      }
    }
  }
  list lbl = getlabels(web, coord_i, coord_j);
  list result = OneSectorComputation(G1, input, lbl);
  
  // Add the result to tails
  int new_index = size(tails) + 1;
  tails[new_index] = list(name, result[3]);
}
rtimer - t;
print("timer for sector computations in ms: " + string(rtimer));
LIB "feynman_ibp.lib";
$
LIB "feynman_ibp.lib";
LIB "feynman_ibp.lib";
$
LIB "getlabel.lib";
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   list tail_01 = list(list(1,1,1,1,1,1,1,0,-5), list(1,1,1,1,1,1,1,1,-4));
   //userInput[1]=tail_00;
   userInput[1]=tail_01;
  list web=web_g(userInput);
  print_web(web);
  getGraph(web);
$
LIB "getlabel.lib";
list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   //list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   //list tail_01 = list(list(1,1,1,1,1,1,1,0,-5), list(1,1,1,1,1,1,1,-1,-4));
list tail= list(
list(1,1,1,1,1,1,1,-5,0),
list(1,1,1,1,1,1,1,0,-5),
list(0,1,1,1,1,1,1,-5,0),
list(1,0,1,1,1,1,1,0,-5),
list(1,1,0,1,1,1,1,-5,0),
list(1,1,1,0,1,1,1,0,-5),
list(1,1,1,1,0,1,1,-5,0),
list(1,1,1,1,1,0,1,0,-5),
list(1,1,1,1,1,1,0,-5,0),
list(0,1,1,1,1,1,1,0,-5),
list(1,0,1,1,1,1,1,-5,0),
list(1,1,0,1,1,1,1,0,-5),
list(1,1,1,0,1,1,1,-5,0),
list(1,1,1,1,0,1,1,0,-5),
list(1,1,1,1,1,0,1,-5,0),
list(1,1,1,1,1,1,0,0,-5)
);
   //userInput[1]=tail_00;
   userInput[1]=tail;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  print_web(web);
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
   //list tail_01 = list(list(1,1,1,1,1,1,1,0,-5), list(1,1,1,1,1,1,1,-1,-4));
list tail= list(
list(1,1,1,1,1,1,1,-5,0),
list(1,1,1,1,1,1,1,0,-5),
list(0,1,1,1,1,1,1,-5,0),
list(1,0,1,1,1,1,1,0,-5),
list(1,1,0,1,1,1,1,-5,0),
list(1,1,1,0,1,1,1,0,-5),
list(1,1,1,1,0,1,1,-5,0),
list(1,1,1,1,1,0,1,0,-5),
list(1,1,1,1,1,1,0,-5,0),
list(0,1,1,1,1,1,1,0,-5),
list(1,0,1,1,1,1,1,-5,0),
list(1,1,0,1,1,1,1,0,-5),
list(1,1,1,0,1,1,1,-5,0),
list(1,1,1,1,0,1,1,0,-5),
list(1,1,1,1,1,0,1,-5,0),
list(1,1,1,1,1,1,0,0,-5)
);
   //userInput[1]=tail_00;
   userInput[1]=tail_00;
  list web=web_g(userInput);
  print_web(web);
  print_web(web);
  getGraph(web);
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
   //list tail_01 = list(list(1,1,1,1,1,1,1,0,-5), list(1,1,1,1,1,1,1,-1,-4));
list tail= list(
list(1,1,1,1,1,1,1,-5,0),
list(1,1,1,1,1,1,1,0,-5),
list(0,1,1,1,1,1,1,-5,0),
list(1,0,1,1,1,1,1,0,-5),
list(1,1,0,1,1,1,1,-5,0),
list(1,1,1,0,1,1,1,0,-5),
list(1,1,1,1,0,1,1,-5,0),
list(1,1,1,1,1,0,1,0,-5),
list(1,1,1,1,1,1,0,-5,0),
list(0,1,1,1,1,1,1,0,-5),
list(1,0,1,1,1,1,1,-5,0),
list(1,1,0,1,1,1,1,0,-5),
list(1,1,1,0,1,1,1,-5,0),
list(1,1,1,1,0,1,1,0,-5),
list(1,1,1,1,1,0,1,-5,0),
list(1,1,1,1,1,1,0,0,-5)
);
   //userInput[1]=tail_00;
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  print_web(web);
  getGraph(web);
  list label_11=getlabels(web,1,1);
}
 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
   //list tail_01 = list(list(1,1,1,1,1,1,1,0,-5), list(1,1,1,1,1,1,1,-1,-4));
list tail= list(
list(1,1,1,1,1,1,1,-5,0),
list(1,1,1,1,1,1,1,0,-5),
list(0,1,1,1,1,1,1,-5,0),
list(1,0,1,1,1,1,1,0,-5),
list(1,1,0,1,1,1,1,-5,0),
list(1,1,1,0,1,1,1,0,-5),
list(1,1,1,1,0,1,1,-5,0),
list(1,1,1,1,1,0,1,0,-5),
list(1,1,1,1,1,1,0,-5,0),
list(0,1,1,1,1,1,1,0,-5),
list(1,0,1,1,1,1,1,-5,0),
list(1,1,0,1,1,1,1,0,-5),
list(1,1,1,0,1,1,1,-5,0),
list(1,1,1,1,0,1,1,0,-5),
list(1,1,1,1,1,0,1,-5,0),
list(1,1,1,1,1,1,0,0,-5)
);
   //userInput[1]=tail_00;
   userInput[1]=tail_00;
//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  print_web(web);
  getGraph(web);
$
LIB "setmat.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); //L list of pair of sorted integrals and the corresponding sorting measures
  size(L);
$
LIB "setmat.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); 
string(L);
size(L);
$
LIB "setmat.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); //L list of pair of
string(L[1]);
string(L[2]);
string(L[1][1]);
string(L[1][2]);
string(L);
size(L);
$
LIB "setmat.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); //L
  size(L);
string(L[1][1]);
string(L[1]);
string(L[1][2]);
$
LIB "setmat.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); //L list of pair of sorted integrals and the corresponding sorting measures
  size(L);
$
LIB "setmat.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); //L list of pair of sorted integrals and the corresponding sorting measures
  size(L);
$
LIB "setmat.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); //L list of pair of sorted integrals and the corresponding sorting measures
  size(L);
$
LIB "setmat.lib";
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); //L list of pair of sorted integrals and the corresponding sorting measures
  size(L);
$
LIB "setmat.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); /
$
LIB "setmat.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  //setIBP S=computeIBP(G1,list(1,1,1,-1,-3,-1,-1,-1,-1));
list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getSortedIntegrals(S); /
string(L[1]);
string(L[1]);
string(L[1][1]);
string(L[1][2]);
size(L[1][2]);
string(L);
string(L[44]);
$
LIB "setmat.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  matrix N=setMat(S,list(1,2,3),ind);
N;
string(N);
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  oneIBP I=S.IBP[1];
  I;
  list rowCorrespondToI=extractCoef(I,ind,list(1,2,9)); 
  rowCorrespondToI[82]; //output will be -14
  rowCorrespondToI[6]; //output will be -14
$
LIB "setmat.lib";
[200~graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  
  list val=getRandom(7853,npars(R));
  matrix N=setMat(S,val,ind);~$
;
LIB "setmat.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
;
  setring R;
  list ind = getSortedIntegrals(S);
  list val=getRandom(7853,npars(R));
  matrix N=setMat(S,val,ind);
string(N);
val;
npars(R);
R;
  list val=getRandom(7853,npars(R));
val;
$
LIB "setmat.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  
  list val=getRandom(7853,npars(R));
  matrix N=setMat(S,val,ind);
  list val=getRandom(7853,npars(R));
  matrix N=setMat(S,val,ind);
$
LIB "setmat.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  list val=getRandom(7853,npars(R));
val;
  matrix N=setMat(S,val,ind);
string(N);
LIB "setmat.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  
  list val=getRandom(7853,npars(R));
$
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  
  list val=getRandom(7853,npars(R));
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
$
LIB "setmat.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
list val=getRandom(7853,npars(R));
  matrix N=setMat(S,val,ind);
  matrix N=setMat(S,val,ind);
$
LIB "setmat.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  list val=getRandom(7853,npars(R));
  matrix N=setMat(S,val,ind);
$
LIB "setmat.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  list val=getRandom(7853,npars(R));
  matrix N=setMat(S,val,ind);
$
LIB "setmat.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  
  list val=getRandom(7853,npars(R));
  matrix N=setMat(S,val,ind);
$
LIB "setmat.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  
  list val=getRandom(7853,npars(R));
  matrix N=setMat(S,val,ind);
printMat(N);
string(N);
size(N);
nrows(N);
ncols(N);
  matrix N=imap(R,N);
string(N);
N;
$
LIB "setmat.lib";
$
LIB "setmat.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  
  list val=getRandom(7853,npars(R));
  matrix N=setMat(S,val,ind);
string(N);
matrix N=imap(R,N);
string(N);
p=7853;
int p=7853;
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=setMat(S,val,ind);
$
LIB "setmat.lib";
labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
  setIBP S=computeManyIBP(G1, targetInt);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
ring R=S.over;
  setring R;
  list L=getRedIBPs(S,101);
proc getSortedIntegrals(setIBP I)
"USAGE:  getSortedIntegrals(I); I setIBP,
ASSUME:   
RETURN:  list ind where each entry is a pair (indv,sortmeasures),
          indv is the list of indices(seed) appered in the setIBP 
          and sortmeasures is the output of getSortMeasures(indv).
          The function getSortedIntegrals extract the seeds appeared in the IBP identities of the setIBP,
          sort them lexicographically based on the values got from getSortMeasures and return the output.
KEYWORDS: Feynman graph
"
{
  ring RZ=I.over;
  list ind;
  list indS;
  for(int j=1;j<=size(I.IBP);j++)
  {
      oneIBP oneI=I.IBP[j];
      for(int k=1;k <= size(oneI.i);k++)
      {
        list indv=oneI.i[k];
        if(size(ind)==0){
          ind[size(ind)+1]=list(indv,getSortMeasures(indv));
          indS[size(indS)+1]=setSerial(indv);
        }
        else
        { 
          if(isInList(indS,setSerial(indv))==0){
              ind[size(ind)+1]=list(indv,getSortMeasures(indv));
              indS[size(indS)+1]=setSerial(indv);
          }
        }
      }
  }
  
  list indc=lexSort(ind);
return(indc);
}
;
;
$
LIB "setmat.lib";
labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,7853);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
   print("Z[4]: ");
   print(Z[4]);  
   print("ncols(Z[1]): ");
   print(ncols(Z[1]));  
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      print("Z[1]["+string(j)+","+string(k)+"]: "+string(Z[1][j,k]));  
      if(Z[1][j,k] != 0){
        print("S.IBP["+string(k)+"]: "+string(S.IBP[k]));  
        indIBP[l]=S.IBP[k];
        print("indIBP["+string(l)+"]: "+string(indIBP[l]));  
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
  list L=getRedIBPs(S,7853);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
   print("ncols(Z[1]): "+string(ncols(Z[1])));  
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      print("Z[1]["+string(j)+","+string(k)+"]: "+string(Z[1][j,k]));  
      if(Z[1][j,k] != 0){
        print("S.IBP["+string(k)+"]: "+string(S.IBP[k]));  
        indIBP[l]=S.IBP[k];
        print("indIBP["+string(l)+"]: "+string(indIBP[l]));  
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
  list L=getRedIBPs(S,7853);
proc getRedIBPs(setIBP S,int p)
"USAGE:   getRedIBPs(S,p); 
ASSUME:   S is setIBP, and p is a prime number. 
RETURN:   list L, L[1]=indIBP, L[2]=seed where,
          indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. 
          seed contain the indeces correspond to the non-free columns in rref.
KEYWORDS: feynman graph,IBPs
EXAMPLE:  getRedIBPs; shows an example
"
{
  ring R=S.over;
  timer=0;
  
  list ind = getSortedIntegrals(S);
  list val=getRandom(p,npars(R));
  list indIBP;
  int l=1;
  matrix N=setMat(S,val,ind);
  int elapsed_time=timer;
  print("Elapsed time to set the matrix over Fp in seconds:" + string( elapsed_time));  
  ring RZ=(p,t(1..(npars(R)-1)),D),z(1..nvars(R)),dp;
  matrix N=imap(R,N);
  timer=0;
  list Z=gaussred_pivot(N);
  int elapsed_time = timer;
  print("Elapsed time to compute rref in seconds:" +string( elapsed_time)+ ". size of the matrix:"+string(nrows(N))+" * "+string(ncols(N)));
   setring R;
  list Z=imap(RZ,Z);
  for(int j=1;j <= Z[4];j++)
  { for(int k=1;k <= ncols(Z[1]);k++)
    {
      print("Z[1]["+string(j)+","+string(k)+"]: "+string(Z[1][j,k]));  
      if(Z[1][j,k] != 0){
        print("S.IBP["+string(k)+"]: "+string(S.IBP[k]));  
        indIBP[l]=S.IBP[k];
        print("indIBP["+string(l)+"]: "+string(indIBP[l]));  
        l++;
      }
    }
  }
  //identify non-zero columns
  list seed;
  int l=1;
  for(int k=1;k <= ncols(Z[3]);k++){
    for(int j=1;j <= nrows(Z[3]);j++){
      if(Z[3][j,k] != 0){
        seed[l]=ind[k][1];
        l++;
        break;
      }
    }
  }
  return(list(indIBP,seed));
}
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,7853);
$
LIB "setmat.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
 setring R;
  list L=getRedIBPs(S,7853);
 setring R;
  list L=getRedIBPs(S,7853);$
LIB "setmat.lib";
 graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  list targetInt = list(list(1, -1, -1, -1, -3, -1, -1, -1, -1) );
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list L=getRedIBPs(S,7853);
$
LIB "setmat.lib";
graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));
  setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
  
size(ind);
string(ind);
list targetInt = list(list(1, 1, 1, -1, -3, -1, -1, -1, -1)
//, list(1, -1, 1, -1, -3, -1, -1, -4, -1)
);
setIBP S=computeManyIBP(G1, targetInt);
  ring R=S.over;
  setring R;
  list ind = getSortedIntegrals(S);
size(ind);
$
