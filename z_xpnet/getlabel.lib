////////////////////////////////////////////////////////////
version="version classify2.lib 4.3.2.0 Jan_2022 "; // $Id:  $
category="Commutative Algebra";
info="
LIBRARY: feynman.lib   Feynman integrals and IBP

OVERVIEW:
We generate the Feynman integrand associated to a Feynman diagram and compute reduced IBP system to reduce given target integers to master integrals.

KEYWORDS:
Feynman integral;

PROCEDURES:
makeGraph(list, list)                                   generate a graph from a list of vertices and a list of edges
makeLabeledGraph(list, list)                            generate a labeled graph from a list of vertices and a list of edges
printGraph(graph)                                       print procedure for graphs
labelGraph(graph)                                       label a graph with variables for vertices and edges
balancingIdeal(labeledgraph)                            ideal of balancing conditions
eliminateVariables(labeledgraph)                        eliminate variables according to balancing condition
propagators(labeledgraph)         	                    generate ideal generated by denominators of the Feynman integral assocated to graph
ISP(labeledgraph)			                                  extend the propagators to a basis of the quadratic forms
removeElimVars(labeledgraph)                            Removes the variables from G.elimvars. This key is generated by the procedure eliminateVariables.
computeBaikovMatrix(graph)                              computes the Baikov matrix of G defined in G1.baikovover and stores it in G1.baikovmatrix
computeM1(labeledgraph)                                 generate the module M1 over G1.baikovover that requires to compute IBP identities 
computeM2(labeledgraph,list)                            generate the module M2 over G1.baikovover that requires to compute IBP identities 
computeIBP(labeledgraph,list)                           generate the set of IBPS correspond to the given indices of denominators of the feynman integral.
getSector(list)                                         returns the sector (a list of 1s and 0s) that the integral belongs
listCombintions(list,int)                               returns the list of r-combinations of the elements in the list L
generateWebSectors(list)                                generate the Web structure of the sectors L, where L is the list and L[1] is the sector that correspond to the seed and 
                                                        L[i]  contain the subsectors of the sectors in L[i-1]. Not that sector maps between the sectors have not been setted.
isSubList(l1,l2)                                        return 1 if elements in l1 contain in l2  0 if elements in l1 do not contain in l2
getSectorMap(L1,L2)                                     L1 where sectorMap  of each sector in the list L1 is filled.
setSectorMap(sectorWeb)                                 sectorWeb where the field sectorMap field of each sector in sectorWeb is filled.
findSector(sectorWeb,currentPosition,L)                 return position of the sector in the sectorWeb, where the L belongs. return -1, if the sector is not found
updateOneSector(sectorWeb,currentPosition,oneInt)       updated sectorWeb, where the oneInt is assigned to the targetInts field of the seector correspond to provided oneInt
updateWeb(sectorWeb,currentPosition,setInt)             return a list(sectorWeb,MasterInt,notInWeb) where,sectorWeb is the updated web by assingning integrals to correspondng sectors, masterInt is the list integrals belong to the sector at currentPosition notInWeb is the list of integrals that are not belong the integral family associated the SectorWeb.
pickHighestSector(targetInt)                            return the intgral that belong to the heighest sector, if all integrals belong to the same sector web; otherwise, it returns a list of collection of integrals each need to be handled using different sector webs
getSortMeasures(l)                                      return list of sort measures that are used in Laporta Algorithm
extractCoef(I,ind,l)                                    return list of values where, the i-th element is the evaluation of coefficient function  at values in the list l of the IBP relation oneIBP, whose index is i=ind[i][1]. Columns of the matrix correspond to the all used indices in the setIBP which are ordered with respect to the output ofgetSortMeasures.
setMat(S,val)                                           return matrix,where i-th row correspond to the evaluation of coefficient functions of i-th IBP in setIBP. 
getRedIBPs(S,p)                                         list L, L[1]=indIBP, L[2]=seed where, indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. seed contain the indeces correspond to the non-free columns in rref.
getSortedIntegrals(I)                                            return list ind where each entry is a pair (indv,sortmeasures), indv is the list of indices(seed) appered in the setIBP and sortmeasures is the output of getSortMeasures(indv).The function getSortedIntegrals extract the seeds appeared in the IBP identities of the setIBP, sort them lexicographically based on the values got from getSortMeasures and return the output.
computeManyIBP(G0,setNu)                                return setIBP S, where it contains all the IBP relations obtained by module intersection and seeding
getReducedIBPSystem(G,targetInt )                       return reduced IBP systerm together with master integrals which are sufficent for reduction of targetInt to master integrals
";

LIB "linalg.lib";
LIB "ellipticcovers.lib"; //For integer partition

proc mod_init()
{
LIB "general.lib";
newstruct("graph","list vertices, list edges");
newstruct("labeledgraph","list vertices, list edges, ring over, list labels, ring overpoly, list elimvars, ring baikovover, matrix baikovmatrix");
newstruct("Net","list rows");
newstruct("oneIBP","list c, list i");
newstruct("setIBP","ring over,list seed,list IBP");
newstruct("oneSector","list lab, list sectorMap ,list targetInts ");
newstruct("MI","list masterIntegrals");
system("install","labeledgraph","print",printLabeledGraph,1);
system("install","graph","print",printGraph,1);
system("install","oneIBP","print",printIBP,1);
system("install","MI","print",printMI,1);
system("install","setIBP","print",printsetIBP,1);
system("install","Net","print",printNet,1);

system("install","Net","+",catNet,2);
option(noredefine);
}


proc getSector(list l)
"USAGE:   getSector(l); l list@*
ASSUME:   l is a list of integer indices of a Feynman integral 
RETURN:   list L, L[1]=s The sector (a list of 1s and 0s) that the corresponding integral belongs
          L[2]=n The sector in that the integral belongs 
KEYWORDS: Feynman graph
"
{
  print("in getSector, l.size(): " + string(size(l)));
  list s;
  list n;
  int i;
  int size_l = size(l);
  for(i=1; i<=size_l; i=i+1)
  {
    if(l[i] > 0)
    {
      s[i] = 1;
      n[size(n)+1] = i;
    }
    else
    {
      s[i] = 0;
    }
  }
  print("in getSector, s: " + string(s));
  print("in getSector, n: " + string(n));
  return(list(s,n));
}
example
{ "EXAMPLE:"; echo=2;
  list l=list(1,2,-3,-4,0,1);
  list s=getSector(l);
  s;
}


proc getCombinations(list L,int r,list pre)
{
  int n=size(L);
  list op;
  if(size(pre)==r){
    op[size(op)+1]=pre;
    return(op);
  }
  if(n==0)
  {
    return(list());
  }
  list remL=delete(L,1);
  list npre=pre;
  npre[size(npre)+1]=L[1];
  list ex1=getCombinations(remL,r,npre);
  list ex2=getCombinations(remL,r,pre);
return(ex1+ex2);
}


proc listCombinations(list L,int r)
"USAGE:   listCombintions(L,r); L list, r int@*
ASSUME:  
RETURN:   list of r-combinations of the elements in the list L 
KEYWORDS: feynman graph
EXAMPLE:  example listCombinations; shows an example
"
{
  
  return(getCombinations(L,r,list()));
}

example{"EXAMPLE:"; echo=2;
ring R=0,(x,y,z),dp;
list L=listCombinations(list(1,2,3,4),3);
L[1];

}


proc generateWebSectors(list seed)
"USAGE:   generateWebSectors(seed);seed list@*
ASSUME:   seed is a list of integer values.
RETURN:   Web structure of the sectors L, where L is the list and L[1] is the sector that correspond to the  given seed and L[i] 
          contain the subsectors of the sectors in L[i-1]. Note that sector maps between the sectors have not been setted. 
KEYWORDS: feynman graph
EXAMPLE:  example generateWebSectors; shows an example
"
{
list L=getSector(seed);
list sector=L[1];
int nSectors=2^size(L[2]);
list sectorWeb;
for(int i=0;i<size(L[2]);i++)
  {
    list comb=listCombinations(L[2],size(L[2])-i);
    list l;
    for(int j=1;j<=size(comb);j++){
      oneSector s;
      s.lab=comb[j];
      l[j]=s;
    }
  sectorWeb[i+1]=l;
  }
return(sectorWeb);
}
example{

  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
}



proc isSubList(list l1,list l2)
"USAGE:   isSubList(l1,l2); l1 list, l2 list@*
ASSUME:   l1 and l2 are list of positive integers
RETURN:   1 if elements in l1 contain in l2
          0 if elements in l1 do not contain in l2
KEYWORDS: 
EXAMPLE:  isSubList; shows an example
"
{
  if(size(l1) > size(l2)){
    return(-1);
  }
  else{
    int ind=0;
    for(int i=1;i <= size(l1);i++){
      for(int j=1;j <= size(l2);j++){
        if(l2[j]==l1[i]){
          ind=ind+1;
        }
      }
    }
    if(ind==size(l1)){
      return(1);
    }
    else{
      return(0);
    }
  }
}
example{"EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  list l1=list(1,2,3,4,5,6,7);
  list l2=list(1,4,6);
  list l3=list(1,2,8);
  list l4=list(1,4,6);
  isSubList(l2,l1);
  isSubList(l3,l1);
  isSubList(l1,l2);
  isSubList(l2,l4);
}





proc getSectorMap(list L1,list L2)
"USAGE:   getSectorMap(L1,L2); L1 list, L2 list, sector@*
ASSUME:   L1 and L2 are lists of sectors where the lab field of each sector in both lists are filled(i.e. two layers of a sector web)
RETURN:   L1 where sectorMap  of each sector in the list L1 is filled.
KEYWORDS: sector,graph,feynman,setIBP
EXAMPLE:  getSectorMap; shows an example
"

{
//compare the containment
for(int i=1;i<=size(L1);i++)
{

  for(int j=1;j<=size(L2);j++)
  {
    oneSector s=L2[j];
    if(isSubList(L2[j].lab,L1[i].lab)==1)
    {
      L1[i].sectorMap[size(L1[i].sectorMap)+1]=j;
    }
  }
}
return(L1);
}
example{"EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=getSectorMap(w[1],w[2]);
  w1[1].sectorMap;
  list w2=getSectorMap(w[2],w[3]);
  w2[2].sectorMap;
}


proc setSectorMap(list sectorWeb)
"USAGE:   setSectorMap(sectorWeb); sectorWeb list, sector@*
ASSUME:   sectorWeb is an output produced by the function @*generateWebSectors
RETURN:   sectorWeb where the field sectorMap field of each sector in sectorWeb is filled.
KEYWORDS: sector, generateWebSectors, getSectorMap
EXAMPLE:  setSectorMap; shows an example
"
{
  for(int i=1;i<=size(sectorWeb)-1;i++)
  {
    list L1=sectorWeb[i];
    list L2=sectorWeb[i+1];
    sectorWeb[i]=getSectorMap(L1,L2);
  }
  return(sectorWeb);
}
example{
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=setSectorMap(w);

}

proc findSector(list sectorWeb, list currentPosition, list L)
"USAGE:   findSector(sectorWeb,currentPosition,L); sectorWeb list,currentPosition list,L list,
ASSUME:   sectorWeb is an output produced by the function generateWebSectors@*, L is an output produced by the function getSector@*
RETURN:   position of the sector in the sectorWeb, where the L belongs. 
          -1, if the sector is not found
KEYWORDS: sector, generateWebSectors, getSectorMap
EXAMPLE:  findSector; shows an example
"
{ 
  list pos;
  for(int i=currentPosition[1];i <= size(sectorWeb);i++)
  {
    for(int j=currentPosition[2]; j<= size(sectorWeb[i]);j++)
    {
      if(isSubList(L,sectorWeb[i][j].lab) ==  1 and isSubList(sectorWeb[i][j].lab,L)  ==  1)
      {
          pos[1]=i;
          pos[2]=j;
      } 
    }

  }
  if(size(pos)==0){
    return(-1);
  }
  else
  {
    return(pos);
  }

}
example{
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=setSectorMap(w);
  list oneInt=list(4,-1,-1,0,-1,-2);
  list L=getSector(oneInt);
  def pos=findSector(w1,list(1,1),L[2]);
  isSubList(w[pos[1]][pos[2]].lab,L[2])==1 && isSubList(L[2],w[pos[1]][pos[2]].lab); //this returns 1, since the given integral is in the sector at pos.

  //example for a integral that is not in the set
  list oneInt=list(4,1,0,-1,-2,3);
  list L=getSector(oneInt);
  def pos=findSector(w1,list(1,1),L[2]);
  pos;
  
}

proc pickHighestSector(list targetInt)
"USAGE:  pickHighestSector(targetInt); G is a list of list of integers of same length
ASSUME:  targetInt is the list of target integrals 
RETURN:  the intgral that belong to the heighest sector, if all integrals belong to the same sector web; otherwise, it returns a list of collection of integrals 
         each need to be handled using different sector webs,
KEYWORDS: Feynman graph
"
{
  list sortedInt1;
  list sortedInt2;
  list intsWithSectors;
  
  for(int i=1;i <= size(targetInt);i++)
  {
    list L=getSector(targetInt[i]);
    intsWithSectors[size(intsWithSectors)+1]=list(list(L[2],targetInt[i]),list(size(L[2])));
  }
  list L=lexSort(intsWithSectors);
  for(int i=size(L);i>=1;i--)
  {
    if(size(sortedInt1)==0)
    {
      sortedInt1[1]=L[i][1][1];
      sortedInt2[1]=list(L[i][1][2]);
    }
    else
    { 
      int id=0;
      for(int j=1;j<=size(sortedInt1);j++)
      { 
        if( isSubList(L[i][1][1],sortedInt1[j])==1)
        {
          sortedInt2[j][size(sortedInt2[j])+1]=L[i][1][2];
          id=id+1;
        }
      }
      if(id==0)
      {
        sortedInt1[size(sortedInt1)+1]=L[i][1][1];
        sortedInt2[size(sortedInt2)+1]=list(L[i][1][2]);
      }
    }
  } 
 
return(sortedInt2);
}
example{"EXAMPLE:"; echo=2;
  list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web
  list L=pickHighestSector(setInt);
  size(L);

  list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2)); //here we need more than one web
  list L=pickHighestSector(setInt);
  size(L);
}

proc lexSort(list L)
{
  int n=size(L);
  for(int i=1;i<n;i++)
  {
    for(int j=1;j <= n-i;j++)
    {
      if(comp_lex(L[j][2],L[j+1][2])==1)
      {
        list temp=L[j];
        L[j]=L[j+1];
        L[j+1]=temp;
      }
    }
  }
  return(L);
}


proc getSector(list l)
"USAGE:   getSector(l); l list@*
ASSUME:   l is a list of integer indices of a Feynman integral 
RETURN:   list L, L[1]=s The sector (a list of 1s and 0s) that the corresponding integral belongs
          L[2]=n The sector in that the integral belongs 
KEYWORDS: Feynman graph
"
{
  print("in getSector, l.size(): " + string(size(l)));
  list s;
  list n;
  
  for(int i=1;i<=size(l);i++){
    if(l[i]>0){ //changed
      s[i]=1;
      n[size(n)+1]=i;
    }
    else
    {
      s[i]=0;
    }
  }
  print("in getSector, s: " + string(s));
  print("in getSector, n: " + string(n));
  return(list(s,n));
}
example
{ "EXAMPLE:"; echo=2;
  list l=list(1,2,-3,-4,0,1);
  list s=getSector(l);
  s;
}

proc getCombinations(list L,int r,list pre)
{
  int n=size(L);
  list op;
  if(size(pre)==r){
    op[size(op)+1]=pre;
    return(op);
  }
  if(n==0)
  {
    return(list());
  }
  list remL=delete(L,1);
  list npre=pre;
  npre[size(npre)+1]=L[1];
  list ex1=getCombinations(remL,r,npre);
  list ex2=getCombinations(remL,r,pre);
return(ex1+ex2);
}


proc listCombinations(list L,int r)
"USAGE:   listCombintions(L,r); L list, r int@*
ASSUME:  
RETURN:   list of r-combinations of the elements in the list L 
KEYWORDS: feynman graph
EXAMPLE:  example listCombinations; shows an example
"
{
  
  return(getCombinations(L,r,list()));
}

example{"EXAMPLE:"; echo=2;
ring R=0,(x,y,z),dp;
list L=listCombinations(list(1,2,3,4),3);
L[1];

}


proc generateWebSectors(list seed)
"USAGE:   generateWebSectors(seed);seed list@*
ASSUME:   seed is a list of integer values.
RETURN:   Web structure of the sectors L, where L is the list and L[1] is the sector that correspond to the  given seed and L[i] 
          contain the subsectors of the sectors in L[i-1]. Note that sector maps between the sectors have not been setted. 
KEYWORDS: feynman graph
EXAMPLE:  example generateWebSectors; shows an example
"
{
list L=getSector(seed);
list sector=L[1];
int nSectors=2^size(L[2]);
list sectorWeb;
for(int i=0;i<size(L[2]);i++)
  {
    list comb=listCombinations(L[2],size(L[2])-i);
    list l;
    for(int j=1;j<=size(comb);j++){
      oneSector s;
      s.lab=comb[j];
      l[j]=s;
    }
  sectorWeb[i+1]=l;
  }
return(sectorWeb);
}
example{

  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
}



proc isSubList(list l1,list l2)
"USAGE:   isSubList(l1,l2); l1 list, l2 list@*
ASSUME:   l1 and l2 are list of positive integers
RETURN:   1 if elements in l1 contain in l2
          0 if elements in l1 do not contain in l2
KEYWORDS: 
EXAMPLE:  isSubList; shows an example
"
{
  if(size(l1) > size(l2)){
    return(-1);
  }
  else{
    int ind=0;
    for(int i=1;i <= size(l1);i++){
      for(int j=1;j <= size(l2);j++){
        if(l2[j]==l1[i]){
          ind=ind+1;
        }
      }
    }
    if(ind==size(l1)){
      return(1);
    }
    else{
      return(0);
    }
  }
}
example{"EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  list l1=list(1,2,3,4,5,6,7);
  list l2=list(1,4,6);
  list l3=list(1,2,8);
  list l4=list(1,4,6);
  isSubList(l2,l1);
  isSubList(l3,l1);
  isSubList(l1,l2);
  isSubList(l2,l4);
}

proc getSectorMap(list L1,list L2)
"USAGE:   getSectorMap(L1,L2); L1 list, L2 list, sector@*
ASSUME:   L1 and L2 are lists of sectors where the lab field of each sector in both lists are filled(i.e. two layers of a sector web)
RETURN:   L1 where sectorMap  of each sector in the list L1 is filled.
KEYWORDS: sector,graph,feynman,setIBP
EXAMPLE:  getSectorMap; shows an example
"

{
//compare the containment
for(int i=1;i<=size(L1);i++)
{

  for(int j=1;j<=size(L2);j++)
  {
    oneSector s=L2[j];
    if(isSubList(L2[j].lab,L1[i].lab)==1)
    {
      L1[i].sectorMap[size(L1[i].sectorMap)+1]=j;
    }
  }
}
return(L1);
}
example{"EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  list l=list(1,-1,0,1,2,-2);
  list w=generateWebSectors(l);
  list w1=getSectorMap(w[1],w[2]);
  w1[1].sectorMap;
  list w2=getSectorMap(w[2],w[3]);
  w2[2].sectorMap;
}


proc getlabels(list web, int i, int j)
{
  list labs = web[i][j].lab;
  return(labs);  
}

proc getGraph(list T)
{
list vertices = list();
list edges = list();
list labels = list();
int v_idx = 1;
int e_idx = 1;
print("size of web T: "+string(size(T)));

// Generate vertices and labels
for (int i = 1; i <= size(T); i++)
{
  print("size of T[: "+string(i)+"]: "+string(size(T[i])));

for (int j = 1; j <= size(T[i]); j++)
{
//  print("size of T[: "+string(i)+"]["+string(j)+"]: "+string(size(T[i][j])));
vertices[v_idx] = list(i, j);
labels[v_idx] = T[i][j].lab;
v_idx++;
}
}
print("Vertices:");
for (int i = 1; i <= size(vertices); i++)
{
print("("+string(vertices[i][1]) + ", " + string(vertices[i][2])+")"+  "    ("+string(labels[i])+")");
}


// Generate edges
for (int i = 1; i < size(T); i++)
{
  for (int j = 1; j <= size(T[i]); j++)
{
    for (int k = 1; k <= size(T[i+1]); k++)
{
if (subset(T[i+1][k].lab, T[i][j].lab))
{
edges[e_idx] = list(list(i,j), list(i+1,k));
e_idx++;
}
}
}
}
print("Edges:");
for (int i = 1; i <= size(edges); i++)
{
print("("+string(edges[i][1][1]) + ", " + string(edges[i][1][2])+")"+  "    ("+string(edges[i][2][1]) + ", " + string(edges[i][2][2])+")");
}
return(list(vertices, edges, labels));
}
// Helper function to determine subset
proc subset(list small, list big)
{
for (int i = 1; i <= size(small); i++)

{
  if (!contains(big, small[i])) 
      {return(0);}
  }
return(1);
}
// Helper function to check if list contains element
proc contains(list L, int x)
{

for (int i = 1; i <= size(L); i++)
{
  if (L[i] == x){
    return (1);
  }
}
return(0);
}


//************************************************************************************************************************** */


proc web_g(list targetInt)
{

  print("targetInt: " + string(targetInt[1]));
  list LL = pickHighestSector(targetInt[1]);
  // print L
  print("L=pickHighestSector(targetInt[1]): " + string(LL));
  print("LL[1].size(): " + string(size(LL[1])));
  print("LL[1][1]: " + string(LL[1][1]));

  list web = generateWebSectors(LL[1][1]);

  return(web);
}


proc comp_lex(list l1,list l2)
{
  for(int i=1;i <= size(l1);i++){
    if(l1[i]<l2[i]) {return(-1);} //l1<l2
    if(l1[i]>l2[i]) {return(1);} //l1>l2 
  }
  return(0); // l1=l2
}
proc getlabels(list web, int i, int j)
{
  list labs = web[i][j].lab;
  return(labs);  
}

proc print_web(list web)
"USAGE: print_web(web); web = list of lists of oneSector structs"
{
  print(" web is :");
  if (size(web) == 0) {
    print("  (empty list)");
    return;
  }
  int i, j, k, l;
  for (i = 1; i <= size(web); i++) {
    print("  Layer " + string(i) + ":");
    list layer = web[i];
    for (j = 1; j <= size(layer); j++) {
      if (typeof(layer[j]) == "oneSector" && defined(layer[j].lab)) {
        print("    Sector " + string(j) + ":");
        print("      lab = " + string(layer[j].lab));
        print("      sectorMap = " + string(layer[j].sectorMap));
        print("      targetInts:");
        for (k = 1; k <= size(layer[j].targetInts); k++) {
          string s = "        [" + string(k) + "] = ";
          for (l = 1; l <= size(layer[j].targetInts[k]); l++) {
            s = s + string(layer[j].targetInts[k][l]);
            if (l < size(layer[j].targetInts[k])) { s = s + ","; }
          }
          print(s);
        }
      } else {
        print("    Sector " + string(j) + " = (invalid or undefined)");
      }
    }
  }
}
example{"EXAMPLE:"; echo=2;



 list userInput;
   //userInput[1]=list(list(1,1,1,-1,-1,-1,-1,0,0),list(1,-1,1,-1,-1,-1,-1,0,0));
   list tail_00 = list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));
   list targetInt = list(list(1, 1, 1, 1, -3, -1, -1, -1, -1), list(1, -1, 1, -1, -3, -1, -1, -4, -1));

   //list tail_01 = list(list(1,1,1,1,1,1,1,0,-5), list(1,1,1,1,1,1,1,-1,-4));
//list tail= list(list(1,1,1,1,1,1,1,-5,0),list(1,1,1,1,1,1,1,0,-5),list(0,1,1,1,1,1,1,-5,0),list(1,0,1,1,1,1,1,0,-5),list(1,1,0,1,1,1,1,-5,0),list(1,1,1,0,1,1,1,0,-5),list(1,1,1,1,0,1,1,-5,0),list(1,1,1,1,1,0,1,0,-5),list(1,1,1,1,1,1,0,-5,0),list(0,1,1,1,1,1,1,0,-5),list(1,0,1,1,1,1,1,-5,0),list(1,1,0,1,1,1,1,0,-5),list(1,1,0,1,1,1,1,0,-5),list(1,1,1,0,1,1,1,-5,0),list(1,1,1,1,0,1,1,0,-5),list(1,1,1,1,1,0,1,-5,0),list(1,1,1,1,1,1,0,0,-5));


   //userInput[1]=tail_00;
   userInput[1]=targetInt;

//sector at(1,1), label:{1,2,3} computations
print("starting sector at(1,1)");
  list web=web_g(userInput);
  print_web(web);
  getGraph(web);
  list label_11=getlabels(web,1,1);
}